/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _sdktools_tempents_included
 #endinput
#endif
#define _sdktools_tempents_included

/**
 * Called when a temp entity is going to be sent.
 *
 * @param te_name       TE name.
 * @param Players       Array containing target player indexes.
 * @param numClients    Number of players in the array.
 * @param delay         Delay in seconds to send the TE.
 * @return              Plugin_Continue to allow the transmission of the TE, Plugin_Stop to block it.
 */
typedef TEHook = function Action (const char[] te_name, const int[] Players, int numClients, float delay);

/**
 * Hooks a temp entity.
 *
 * @param te_name       TE name to hook.
 * @param hook          Function to use as a hook.
 * @error               Temp Entity name not available or invalid function hook.
 */
native void AddTempEntHook(const char[] te_name, TEHook hook);

/**
 * Removes a temp entity hook.
 *
 * @param te_name       TE name to unhook.
 * @param hook          Function used for the hook.
 * @error               Temp Entity name not available or invalid function hook.
 */
native void RemoveTempEntHook(const char[] te_name, TEHook hook);

/**
 * Starts a temp entity transmission.
 *
 * @param te_name       TE name.
 * @error               Temp Entity name not available.
 */
native void TE_Start(const char[] te_name);

/**
 * Checks if a certain TE property exists.
 *
 * @param prop          Property to use.
 * @return              True if the property exists, otherwise false.
 */
native bool TE_IsValidProp(const char[] prop);

/**
 * Sets an integer value in the current temp entity.
 *
 * @param prop          Property to use.
 * @param value         Integer value to set.
 * @error               Property not found.
 */
native void TE_WriteNum(const char[] prop, int value);

/**
 * Reads an integer value in the current temp entity.
 *
 * @param prop          Property to use.
 * @return              Property value.
 * @error               Property not found.
 */
native int TE_ReadNum(const char[] prop);

/**
 * Sets a floating point number in the current temp entity.
 *
 * @param prop          Property to use.
 * @param value         Floating point number to set.
 * @error               Property not found.
 */
native void TE_WriteFloat(const char[] prop, float value);

/**
 * Reads a floating point number in the current temp entity.
 *
 * @param prop          Property to use.
 * @return              Property value.
 * @error               Property not found.
 */
native float TE_ReadFloat(const char[] prop);

/**
 * Sets a vector in the current temp entity.
 *
 * @param prop          Property to use.
 * @param vector        Vector to set.
 * @error               Property not found.
 */
native void TE_WriteVector(const char[] prop, const float vector[3]);

/**
 * Reads a vector in the current temp entity.
 *
 * @param prop          Property to use.
 * @param vector        Vector to read.
 * @error               Property not found.
 */
native void TE_ReadVector(const char[] prop, float vector[3]);

/**
 * Sets a QAngle in the current temp entity.
 *
 * @param prop          Property to use.
 * @param angles        Angles to set.
 * @error               Property not found.
 */
native void TE_WriteAngles(const char[] prop, const float angles[3]);

/**
 * Sets an array of floats in the current temp entity.
 *
 * @param prop          Property to use.
 * @param array         Array of values to copy.
 * @param arraySize     Number of values to copy.
 * @error               Property not found.
 */
native void TE_WriteFloatArray(const char[] prop, const float[] array, int arraySize);

/**
 * Sends the current temp entity to one or more clients.
 *
 * @param clients       Array containing player indexes to broadcast to.
 * @param numClients    Number of players in the array.
 * @param delay         Delay in seconds to send the TE.
 * @error               Invalid client index or client not in game.
 */
native void TE_Send(const int[] clients, int numClients, float delay=0.0);

/**
 * Sets an encoded entity index in the current temp entity.
 * (This is usually used for m_nStartEntity and m_nEndEntity).
 *
 * @param prop          Property to use.
 * @param value         Value to set.
 * @error               Property not found.
 */
stock void TE_WriteEncodedEnt(const char[] prop, int value)
{
	int encvalue = (value & 0x0FFF) | ((1 & 0xF)<<12);
	TE_WriteNum(prop, encvalue);
}

/**
 * Broadcasts the current temp entity to all clients.
 * @note See TE_Start().
 *
 * @param delay         Delay in seconds to send the TE.
 */
stock void TE_SendToAll(float delay=0.0)
{
	int total = 0;
	int[] clients = new int[MaxClients];
	for (int i=1; i<=MaxClients; i++)
	{
		if (IsClientInGame(i))
		{
			clients[total++] = i;
		}
	}
	TE_Send(clients, total, delay);
}

/**
 * Sends the current TE to only a client.
 * @note See TE_Start().
 *
 * @param client        Client to send to.
 * @param delay         Delay in seconds to send the TE.
 * @error               Invalid client index or client not in game.
 */
stock void TE_SendToClient(int client, float delay=0.0)
{
	int players[1];

	players[0] = client;

	TE_Send(players, 1, delay);
}

/**
 * Sends the current TE to all clients that are in
 * visible or audible range of the origin.
 * @note See TE_Start().
 * @note See GetClientsInRange()
 *
 * @param origin        Coordinates from which to test range.
 * @param rangeType     Range type to use for filtering clients.
 * @param delay         Delay in seconds to send the TE.
 */
stock void TE_SendToAllInRange(float origin[3], ClientRangeType rangeType, float delay=0.0)
{
	int[] clients = new int[MaxClients];
	int total = GetClientsInRange(origin, rangeType, clients, MaxClients);
	TE_Send(clients, total, delay);
}
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */
 
#if defined _version_included
 #endinput
#endif
#define _version_included

#define SOURCEMOD_V_MAJOR		$PMAJOR$				/**< SourceMod Major version */
#define SOURCEMOD_V_MINOR		$PMINOR$				/**< SourceMod Minor version */
#define SOURCEMOD_V_RELEASE		$PREVISION$				/**< SourceMod Release version */

#define SOURCEMOD_VERSION	"$PMAJOR$.$PMINOR$.$PREVISION$$BUILD_STRING$"	/**< SourceMod version string (major.minor.release.build) */
/**
 * vim: set ts=4 sw=4 tw=99 noet :
 * =============================================================================
 * SourceMod (C)2004-2014 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _bitbuffer_included
 #endinput
#endif
#define _bitbuffer_included

methodmap BfWrite < Handle
{
	// Writes a single bit to a writable bitbuffer (bf_write).
	//
	// @param bit       Bit to write (true for 1, false for 0).
	public native void WriteBool(bool bit);
	 
	// Writes a byte to a writable bitbuffer (bf_write).
	//
	// @param byte      Byte to write (value will be written as 8bit).
	public native void WriteByte(int byte);

	// Writes a byte to a writable bitbuffer (bf_write).
	//
	// @param chr       Character to write.
	public native void WriteChar(int chr);

	// Writes a 16bit integer to a writable bitbuffer (bf_write).
	//
	// @param num       Integer to write (value will be written as 16bit).
	public native void WriteShort(int num);

	// Writes a 16bit unsigned integer to a writable bitbuffer (bf_write).
	//
	// @param num       Integer to write (value will be written as 16bit).
	public native void WriteWord(int num);

	// Writes a normal integer to a writable bitbuffer (bf_write).
	//
	// @param num       Integer to write (value will be written as 32bit).
	public native void WriteNum(int num);

	// Writes a floating point number to a writable bitbuffer (bf_write).
	//
	// @param num       Number to write.
	public native void WriteFloat(float num);

	// Writes a string to a writable bitbuffer (bf_write).
	//
	// @param string    Text string to write.
	public native void WriteString(const char[] string);

	// Writes an entity to a writable bitbuffer (bf_write).
	//
	// @param ent       Entity index to write.
	public native void WriteEntity(int ent);

	// Writes a bit angle to a writable bitbuffer (bf_write).
	//
	// @param angle     Angle to write.
	// @param numBits   Optional number of bits to use.
	public native void WriteAngle(float angle, int numBits=8);

	// Writes a coordinate to a writable bitbuffer (bf_write).
	//
	// @param coord     Coordinate to write.
	public native void WriteCoord(float coord);

	// Writes a 3D vector of coordinates to a writable bitbuffer (bf_write).
	//
	// @param coord     Coordinate array to write.
	public native void WriteVecCoord(float coord[3]);

	// Writes a 3D normal vector to a writable bitbuffer (bf_write).
	//
	// @param vec       Vector to write.
	public native void WriteVecNormal(float vec[3]);

	// Writes a 3D angle vector to a writable bitbuffer (bf_write).
	//
	// @param angles    Angle vector to write.
	public native void WriteAngles(float angles[3]);
};

methodmap BfRead < Handle
{
	// Reads a single bit from a readable bitbuffer (bf_read).
	//
	// @return          Bit value read.
	public native bool ReadBool();

	// Reads a byte from a readable bitbuffer (bf_read).
	//
	// @return          Byte value read (read as 8bit).
	public native int ReadByte();

	// Reads a character from a readable bitbuffer (bf_read).
	//
	// @return          Character value read.
	public native int ReadChar();

	// Reads a 16bit integer from a readable bitbuffer (bf_read).
	//
	// @param bf        bf_read handle to read from.
	// @return          Integer value read (read as 16bit).
	public native int ReadShort();

	// Reads a 16bit unsigned integer from a readable bitbuffer (bf_read).
	//
	// @param bf        bf_read handle to read from.
	// @return          Integer value read (read as 16bit).
	public native int ReadWord();

	// Reads a normal integer to a readable bitbuffer (bf_read).
	//
	// @return          Integer value read (read as 32bit).
	public native int ReadNum();

	// Reads a floating point number from a readable bitbuffer (bf_read).
	//
	// @return          Floating point value read.
	public native float ReadFloat();

	// Reads a string from a readable bitbuffer (bf_read).
	//
	// @param buffer    Destination string buffer.
	// @param maxlength Maximum length of output string buffer.
	// @param line      If true the buffer will be copied until it reaches a '\n' or a null terminator.
	// @return          Number of bytes written to the buffer.  If the bitbuffer stream overflowed, 
	//                  that is, had no terminator before the end of the stream, then a negative 
	//                  number will be returned equal to the number of characters written to the 
	//                  buffer minus 1.  The buffer will be null terminated regardless of the 
	//                  return value.
	public native int ReadString(char[] buffer, int maxlength, bool line=false);

	// Reads an entity from a readable bitbuffer (bf_read).
	//
	// @return          Entity index read.
	public native int ReadEntity();

	// Reads a bit angle from a readable bitbuffer (bf_read).
	//
	// @param numBits   Optional number of bits to use.
	// @return          Angle read.
	public native float ReadAngle(int numBits=8);

	// Reads a coordinate from a readable bitbuffer (bf_read).
	//
	// @return          Coordinate read.
	public native float ReadCoord();

	// Reads a 3D vector of coordinates from a readable bitbuffer (bf_read).
	//
	// @param coord     Destination coordinate array.
	public native void ReadVecCoord(float coord[3]);

	// Reads a 3D normal vector from a readable bitbuffer (bf_read).
	//
	// @param vec       Destination vector array.
	public native void ReadVecNormal(float vec[3]);

	// Reads a 3D angle vector from a readable bitbuffer (bf_read).
	//
	// @param angles    Destination angle vector.
	public native void ReadAngles(float angles[3]);

	// Returns the number of bytes left in a readable bitbuffer (bf_read).
	property int BytesLeft {
		public native get();
	}
};

/** 
 * Writes a single bit to a writable bitbuffer (bf_write).
 *
 * @param bf            bf_write handle to write to.
 * @param bit           Bit to write (true for 1, false for 0).
 * @error               Invalid or incorrect Handle.
 */
native void BfWriteBool(Handle bf, bool bit);
 
/**
 * Writes a byte to a writable bitbuffer (bf_write).
 *
 * @param bf            bf_write handle to write to.
 * @param byte          Byte to write (value will be written as 8bit).
 * @error               Invalid or incorrect Handle.
 */
native void BfWriteByte(Handle bf, int byte);

/**
 * Writes a byte to a writable bitbuffer (bf_write).
 *
 * @param bf            bf_write handle to write to.
 * @param chr           Character to write.
 * @error               Invalid or incorrect Handle.
 */
native void BfWriteChar(Handle bf, int chr);

/**
 * Writes a 16bit integer to a writable bitbuffer (bf_write).
 *
 * @param bf            bf_write handle to write to.
 * @param num           Integer to write (value will be written as 16bit).
 * @error               Invalid or incorrect Handle.
 */
native void BfWriteShort(Handle bf, int num);

/**
 * Writes a 16bit unsigned integer to a writable bitbuffer (bf_write).
 *
 * @param bf            bf_write handle to write to.
 * @param num           Integer to write (value will be written as 16bit).
 * @error               Invalid or incorrect Handle.
 */
native void BfWriteWord(Handle bf, int num);

/**
 * Writes a normal integer to a writable bitbuffer (bf_write).
 *
 * @param bf            bf_write handle to write to.
 * @param num           Integer to write (value will be written as 32bit).
 * @error               Invalid or incorrect Handle.
 */
native void BfWriteNum(Handle bf, int num);

/**
 * Writes a floating point number to a writable bitbuffer (bf_write).
 *
 * @param bf            bf_write handle to write to.
 * @param num           Number to write.
 * @error               Invalid or incorrect Handle.
 */
native void BfWriteFloat(Handle bf, float num);

/**
 * Writes a string to a writable bitbuffer (bf_write).
 *
 * @param bf            bf_write handle to write to.
 * @param string        Text string to write.
 * @error               Invalid or incorrect Handle.
 */
native void BfWriteString(Handle bf, const char[] string);

/**
 * Writes an entity to a writable bitbuffer (bf_write).
 * @note This is a wrapper around BfWriteShort().
 *
 * @param bf            bf_write handle to write to.
 * @param ent           Entity index to write.
 * @error               Invalid or incorrect Handle, or invalid entity.
 */
native void BfWriteEntity(Handle bf, int ent);

/**
 * Writes a bit angle to a writable bitbuffer (bf_write).
 *
 * @param bf            bf_write handle to write to.
 * @param angle         Angle to write.
 * @param numBits       Optional number of bits to use.
 * @error               Invalid or incorrect Handle.
 */
native void BfWriteAngle(Handle bf, float angle, int numBits=8);

/**
 * Writes a coordinate to a writable bitbuffer (bf_write).
 *
 * @param bf            bf_write handle to write to.
 * @param coord         Coordinate to write.
 * @error               Invalid or incorrect Handle.
 */
native void BfWriteCoord(Handle bf, float coord);

/**
 * Writes a 3D vector of coordinates to a writable bitbuffer (bf_write).
 *
 * @param bf            bf_write handle to write to.
 * @param coord         Coordinate array to write.
 * @error               Invalid or incorrect Handle.
 */
native void BfWriteVecCoord(Handle bf, float coord[3]);

/**
 * Writes a 3D normal vector to a writable bitbuffer (bf_write).
 *
 * @param bf            bf_write handle to write to.
 * @param vec           Vector to write.
 * @error               Invalid or incorrect Handle.
 */
native void BfWriteVecNormal(Handle bf, float vec[3]);

/**
 * Writes a 3D angle vector to a writable bitbuffer (bf_write).
 *
 * @param bf            bf_write handle to write to.
 * @param angles        Angle vector to write.
 * @error               Invalid or incorrect Handle.
 */
native void BfWriteAngles(Handle bf, float angles[3]);

/** 
 * Reads a single bit from a readable bitbuffer (bf_read).
 *
 * @param bf            bf_read handle to read from.
 * @return              Bit value read.
 * @error               Invalid or incorrect Handle.
 */
native bool BfReadBool(Handle bf);

/**
 * Reads a byte from a readable bitbuffer (bf_read).
 *
 * @param bf            bf_read handle to read from.
 * @return              Byte value read (read as 8bit).
 * @error               Invalid or incorrect Handle.
 */
native int BfReadByte(Handle bf);

/**
 * Reads a character from a readable bitbuffer (bf_read).
 *
 * @param bf            bf_read handle to read from.
 * @return              Character value read.
 * @error               Invalid or incorrect Handle.
 */
native int BfReadChar(Handle bf);

/**
 * Reads a 16bit integer from a readable bitbuffer (bf_read).
 *
 * @param bf            bf_read handle to read from.
 * @return              Integer value read (read as 16bit).
 * @error               Invalid or incorrect Handle.
 */
native int BfReadShort(Handle bf);

/**
 * Reads a 16bit unsigned integer from a readable bitbuffer (bf_read).
 *
 * @param bf            bf_read handle to read from.
 * @return              Integer value read (read as 16bit).
 * @error               Invalid or incorrect Handle.
 */
native int BfReadWord(Handle bf);

/**
 * Reads a normal integer to a readable bitbuffer (bf_read).
 *
 * @param bf            bf_read handle to read from.
 * @return              Integer value read (read as 32bit).
 * @error               Invalid or incorrect Handle.
 */
native int BfReadNum(Handle bf);

/**
 * Reads a floating point number from a readable bitbuffer (bf_read).
 *
 * @param bf            bf_read handle to read from.
 * @return              Floating point value read.
 * @error               Invalid or incorrect Handle.
 */
native float BfReadFloat(Handle bf);

/**
 * Reads a string from a readable bitbuffer (bf_read).
 *
 * @param bf            bf_read handle to read from.
 * @param buffer        Destination string buffer.
 * @param maxlength     Maximum length of output string buffer.
 * @param line          If true the buffer will be copied until it reaches a '\n' or a null terminator.
 * @return              Number of bytes written to the buffer.  If the bitbuffer stream overflowed, 
 *                      that is, had no terminator before the end of the stream, then a negative 
 *                      number will be returned equal to the number of characters written to the 
 *                      buffer minus 1.  The buffer will be null terminated regardless of the 
 *                      return value.
 * @error               Invalid or incorrect Handle.
 */
native int BfReadString(Handle bf, char[] buffer, int maxlength, bool line=false);

/**
 * Reads an entity from a readable bitbuffer (bf_read).
 * @note This is a wrapper around BfReadShort().
 *
 * @param bf            bf_read handle to read from.
 * @return              Entity index read.
 * @error               Invalid or incorrect Handle.
 */
native int BfReadEntity(Handle bf);

/**
 * Reads a bit angle from a readable bitbuffer (bf_read).
 *
 * @param bf            bf_read handle to read from.
 * @param numBits       Optional number of bits to use.
 * @return              Angle read.
 * @error               Invalid or incorrect Handle.
 */
native float BfReadAngle(Handle bf, int numBits=8);

/**
 * Reads a coordinate from a readable bitbuffer (bf_read).
 *
 * @param bf            bf_read handle to read from.
 * @return              Coordinate read.
 * @error               Invalid or incorrect Handle.
 */
native float BfReadCoord(Handle bf);

/**
 * Reads a 3D vector of coordinates from a readable bitbuffer (bf_read).
 *
 * @param bf            bf_read handle to read from.
 * @param coord         Destination coordinate array.
 * @error               Invalid or incorrect Handle.
 */
native void BfReadVecCoord(Handle bf, float coord[3]);

/**
 * Reads a 3D normal vector from a readable bitbuffer (bf_read).
 *
 * @param bf            bf_read handle to read from.
 * @param vec           Destination vector array.
 * @error               Invalid or incorrect Handle.
 */
native void BfReadVecNormal(Handle bf, float vec[3]);

/**
 * Reads a 3D angle vector from a readable bitbuffer (bf_read).
 *
 * @param bf            bf_read handle to read from.
 * @param angles        Destination angle vector.
 * @error               Invalid or incorrect Handle.
 */
native void BfReadAngles(Handle bf, float angles[3]);

/**
 * Returns the number of bytes left in a readable bitbuffer (bf_read).
 *
 * @param bf            bf_read handle to read from.
 * @return              Number of bytes left unread.
 * @error               Invalid or incorrect Handle.
 */
native int BfGetNumBytesLeft(Handle bf);
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _commandline_included_
 #endinput
#endif
#define _commandline_included_

/**
 * Gets the full command line the server was launched with.
 *
 * @param commandLine   Buffer to store the command line in.
 * @param maxlen        Maximum length of the command line buffer.
 * @return              True if the command line is valid; otherwise, false.
 * @error               No command line available, or no mod support.
 */
native bool GetCommandLine(char[] commandLine, int maxlen);

/**
 * Gets the value of a command line parameter the server was launched with.
 *
 * @param param         The command line parameter to get the value of.
 * @param value         Buffer to store the parameter value in.
 * @param maxlen        Maximum length of the value buffer.
 * @param defValue      The default value to return if the parameter wasn't specified.
 * @error               No command line available, or no mod support.
 */
native void GetCommandLineParam(const char[] param, char[] value, int maxlen, const char[] defValue="");

/**
 * Gets the value of a command line parameter the server was launched with.
 *
 * @param param         The command line parameter to get the value of.
 * @param defValue      The default value to return if the parameter wasn't specified.
 * @return              The integer value of the command line parameter value.
 * @error               No command line available, or no mod support.
 */
native int GetCommandLineParamInt(const char[] param, int defValue=0);

/**
 * Gets the value of a command line parameter the server was launched with.
 *
 * @param param         The command line parameter to get the value of.
 * @param defValue      The default value to return if the parameter wasn't specified.
 * @return              The floating point value of the command line parameter value.
 * @error               No command line available, or no mod support.
 */
native float GetCommandLineParamFloat(const char[] param, float defValue=0.0);

/**
 * Determines if a specific command line parameter is present.
 *
 * @param param         The command line parameter to test.
 * @return              True if the command line parameter is specified; otherwise, false.
 * @error               No command line available, or no mod support.
 */
native bool FindCommandLineParam(const char[] param);
/**
 * vim: set ts=4 sw=4 tw=99 noet :
 * =============================================================================
 * SourceMod (C)2013 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _protobuf_included
 #endinput
#endif
#define _protobuf_included

#define PB_FIELD_NOT_REPEATED -1

methodmap Protobuf < Handle
{
	// Reads an int32, uint32, sint32, fixed32, sfixed32, or enum value from a protobuf message.
	//
	// @param field      Field name.
	// @param index      Index into repeated field.
	// @return           Integer value read.
	// @error            Non-existent field, or incorrect field type.
	public native int ReadInt(const char[] field, int index = PB_FIELD_NOT_REPEATED);

	// Reads an int64, uint64, sint64, fixed64, sfixed64 from a protobuf message.
	//
	// @param field      Field name.
	// @param value      Array to represent the large integer (0=High bits, 1=Low bits).
	// @param index      Index into repeated field.
	// @error            Non-existent field, or incorrect field type.
	public native void ReadInt64(const char[] field, int value[2], int index = PB_FIELD_NOT_REPEATED);

	// Reads a float or downcasted double from a protobuf message.
	//
	// @param field      Field name.
	// @param index      Index into repeated field.
	// @return           Float value read.
	// @error            Non-existent field, or incorrect field type.
	public native float ReadFloat(const char[] field, int index = PB_FIELD_NOT_REPEATED);

	// Reads a bool from a protobuf message.
	//
	// @param field      Field name.
	// @param index      Index into repeated field.
	// @return           Boolean value read.
	// @error            Non-existent field, or incorrect field type.
	public native bool ReadBool(const char[] field, int index = PB_FIELD_NOT_REPEATED);

	// Reads a string from a protobuf message.
	//
	// @param field      Field name.
	// @param buffer     Destination string buffer.
	// @param maxlength  Maximum length of output string buffer.
	// @param index      Index into repeated field.
	// @error            Non-existent field, or incorrect field type.
	public native void ReadString(const char[] field, char[] buffer, int maxlength, int index = PB_FIELD_NOT_REPEATED);

	// Reads an RGBA color value from a protobuf message.
	//
	// @param field      Field name.
	// @param buffer     Destination color buffer.
	// @param index      Index into repeated field.
	// @error            Non-existent field, or incorrect field type.
	public native void ReadColor(const char[] field, int buffer[4], int index = PB_FIELD_NOT_REPEATED);

	// Reads an XYZ angle value from a protobuf message.
	//
	// @param field      Field name.
	// @param buffer     Destination angle buffer.
	// @param index      Index into repeated field.
	// @error            Non-existent field, or incorrect field type.
	public native void ReadAngle(const char[] field, float buffer[3], int index = PB_FIELD_NOT_REPEATED);

	// Reads an XYZ vector value from a protobuf message.
	//
	// @param pb         protobuf handle.
	// @param field      Field name.
	// @param buffer     Destination vector buffer.
	// @param index      Index into repeated field.
	// @error            Non-existent field, or incorrect field type.
	public native void ReadVector(const char[] field, float buffer[3], int index = PB_FIELD_NOT_REPEATED);

	// Reads an XY vector value from a protobuf message.
	//
	// @param field      Field name.
	// @param buffer     Destination vector buffer.
	// @param index      Index into repeated field.
	// @error            Non-existent field, or incorrect field type.
	public native void ReadVector2D(const char[] field, float buffer[2], int index = PB_FIELD_NOT_REPEATED);

	// Gets the number of elements in a repeated field of a protobuf message.
	//
	// @param field      Field name.
	// @return           Number of elements in the field.
	// @error            Non-existent field, or non-repeated field.
	public native int GetRepeatedFieldCount(const char[] field);

	// Returns whether or not the named, non-repeated field has a value set.
	//
	// @param field      Field name.
	// @return           True if value has been set, else false.
	// @error            Non-existent field, or repeated field.
	public native bool HasField(const char[] field);

	// Sets an int32, uint32, sint32, fixed32, sfixed32, or enum value on a protobuf message.
	//
	// @param field      Field name.
	// @param value      Integer value to set.
	// @param index      Index into repeated field.
	// @error            Non-existent field, or incorrect field type.
	public native void SetInt(const char[] field, int value, int index = PB_FIELD_NOT_REPEATED);

	// Sets an int64, uint64, sint64, fixed64, sfixed64 on a protobuf message.
	//
	// @param field      Field name.
	// @param value      Large integer value to set (0=High bits, 1=Low bits).
	// @param index      Index into repeated field.
	// @error            Non-existent field, or incorrect field type.
	public native void SetInt64(const char[] field, int value[2], int index = PB_FIELD_NOT_REPEATED);

	// Sets a float or double on a protobuf message.
	//
	// @param field      Field name.
	// @param value      Float value to set.
	// @param index      Index into repeated field.
	// @error            Non-existent field, or incorrect field type.
	public native void SetFloat(const char[] field, float value, int index = PB_FIELD_NOT_REPEATED);

	// Sets a bool on a protobuf message.
	//
	// @param field      Field name.
	// @param value      Boolean value to set.
	// @param index      Index into repeated field.
	// @error            Non-existent field, or incorrect field type.
	public native void SetBool(const char[] field, bool value, int index = PB_FIELD_NOT_REPEATED);

	// Sets a string on a protobuf message.
	//
	// @param field      Field name.
	// @param value      String value to set.
	// @param index      Index into repeated field.
	// @error            Non-existent field, or incorrect field type.
	public native void SetString(const char[] field, const char[] value, int index = PB_FIELD_NOT_REPEATED);

	// Sets an RGBA color on a protobuf message.
	//
	// @param field      Field name.
	// @param color      Color value to set.
	// @param index      Index into repeated field.
	// @error            Non-existent field, or incorrect field type.
	public native void SetColor(const char[] field, const int color[4], int index = PB_FIELD_NOT_REPEATED);

	// Sets an XYZ angle on a protobuf message.
	//
	// @param field      Field name.
	// @param angle      Angle value to set.
	// @param index      Index into repeated field.
	// @error            Non-existent field, or incorrect field type.
	public native void SetAngle(const char[] field, const float angle[3], int index = PB_FIELD_NOT_REPEATED);

	// Sets an XYZ vector on a protobuf message.
	//
	// @param field      Field name.
	// @param vec        Vector value to set.
	// @param index      Index into repeated field.
	// @error            Non-existent field, or incorrect field type.
	public native void SetVector(const char[] field, const float vec[3], int index = PB_FIELD_NOT_REPEATED);

	// Sets an XY vector on a protobuf message.
	//
	// @param field      Field name.
	// @param vec        Vector value to set.
	// @param index      Index into repeated field.
	// @error            Non-existent field, or incorrect field type.
	public native void SetVector2D(const char[] field, const float vec[2], int index = PB_FIELD_NOT_REPEATED);

	// Add an int32, uint32, sint32, fixed32, sfixed32, or enum value to a protobuf message repeated field.
	//
	// @param field      Field name.
	// @param value      Integer value to add.
	// @error            Non-existent field, or incorrect field type.
	public native void AddInt(const char[] field, int value);

	// Add an int64, uint64, sint64, fixed64, sfixed64 to a protobuf message repeated field.
	//
	// @param field      Field name.
	// @param value      Large integer value to add (0=High bits, 1=Low bits).
	// @error            Non-existent field, or incorrect field type.
	public native void AddInt64(const char[] field, int value[2]);

	// Add a float or double to a protobuf message repeated field.
	//
	// @param field      Field name.
	// @param value      Float value to add.
	// @error            Non-existent field, or incorrect field type.
	public native void AddFloat(const char[] field, float value);

	// Add a bool to a protobuf message repeated field.
	//
	// @param field      Field name.
	// @param value      Boolean value to add.
	// @error            Non-existent field, or incorrect field type.
	public native void AddBool(const char[] field, bool value);

	// Add a string to a protobuf message repeated field.
	//
	// @param field      Field name.
	// @param value      String value to add.
	// @error            Non-existent field, or incorrect field type.
	public native void AddString(const char[] field, const char[] value);

	// Add an RGBA color to a protobuf message repeated field.
	//
	// @param field      Field name.
	// @param color      Color value to add.
	// @error            Non-existent field, or incorrect field type.
	public native void AddColor(const char[] field, const int color[4]);

	// Add an XYZ angle to a protobuf message repeated field.
	//
	// @param field      Field name.
	// @param angle      Angle value to add.
	// @error            Non-existent field, or incorrect field type.
	public native void AddAngle(const char[] field, const float angle[3]);

	// Add an XYZ vector to a protobuf message repeated field.
	//
	// @param field      Field name.
	// @param vec        Vector value to add.
	// @error            Non-existent field, or incorrect field type.
	public native void AddVector(const char[] field, const float vec[3]);

	// Add an XY vector to a protobuf message repeated field.
	//
	// @param field      Field name.
	// @param vec        Vector value to add.
	// @error            Non-existent field, or incorrect field type.
	public native void AddVector2D(const char[] field, const float vec[2]);

	// Removes a value by index from a protobuf message repeated field.
	//
	// @param field      Field name.
	// @param index      Index into repeated field.
	// @error            Non-existent field, or incorrect field type.
	public native void RemoveRepeatedFieldValue(const char[] field, int index);

	// Retrieve a handle to an embedded protobuf message in a protobuf message.
	//
	// @param field      Field name.
	// @return           Protobuf handle to embedded message.
	// @error            Non-existent field, or incorrect field type.
	public native Protobuf ReadMessage(const char[] field);

	// Retrieve a handle to an embedded protobuf message in a protobuf message
	// repeated field.
	//
	// @param field      Field name.
	// @param index      Index in the repeated field.
	// @return           Protobuf handle to embedded message.
	// @error            Non-existent field, or incorrect field type.
	public native Protobuf ReadRepeatedMessage(const char[] field, int index);

	// Adds an embedded protobuf message to a protobuf message repeated field.
	//
	// @param field      Field name.
	// @return           Protobuf handle to added, embedded message.
	// @error            Non-existent field, or incorrect field type.
	public native Protobuf AddMessage(const char[] field);
};

/**
 * Reads an int32, uint32, sint32, fixed32, sfixed32, or enum value from a protobuf message.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param index         Index into repeated field.
 * @return              Integer value read.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native int PbReadInt(Handle pb, const char[] field, int index = PB_FIELD_NOT_REPEATED);

/**
 * Reads a float or downcasted double from a protobuf message.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param index         Index into repeated field.
 * @return              Float value read.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native float PbReadFloat(Handle pb, const char[] field, int index = PB_FIELD_NOT_REPEATED);

/**
 * Reads a bool from a protobuf message.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param index         Index into repeated field.
 * @return              Boolean value read.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native bool PbReadBool(Handle pb, const char[] field, int index = PB_FIELD_NOT_REPEATED);

/**
 * Reads a string from a protobuf message.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param buffer        Destination string buffer.
 * @param maxlength     Maximum length of output string buffer.
 * @param index         Index into repeated field.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native void PbReadString(Handle pb, const char[] field, char[] buffer, int maxlength, int index = PB_FIELD_NOT_REPEATED);

/**
 * Reads an RGBA color value from a protobuf message.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param buffer        Destination color buffer.
 * @param index         Index into repeated field.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native void PbReadColor(Handle pb, const char[] field, int buffer[4], int index = PB_FIELD_NOT_REPEATED);

/**
 * Reads an XYZ angle value from a protobuf message.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param buffer        Destination angle buffer.
 * @param index         Index into repeated field.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native void PbReadAngle(Handle pb, const char[] field, float buffer[3], int index = PB_FIELD_NOT_REPEATED);

/**
 * Reads an XYZ vector value from a protobuf message.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param buffer        Destination vector buffer.
 * @param index         Index into repeated field.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native void PbReadVector(Handle pb, const char[] field, float buffer[3], int index = PB_FIELD_NOT_REPEATED);

/**
 * Reads an XY vector value from a protobuf message.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param buffer        Destination vector buffer.
 * @param index         Index into repeated field.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native void PbReadVector2D(Handle pb, const char[] field, float buffer[2], int index = PB_FIELD_NOT_REPEATED);

/**
 * Gets the number of elements in a repeated field of a protobuf message.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @return              Number of elements in the field.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native int PbGetRepeatedFieldCount(Handle pb, const char[] field);

/**
 * Sets an int32, uint32, sint32, fixed32, sfixed32, or enum value on a protobuf message.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param value         Integer value to set.
 * @param index         Index into repeated field.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native void PbSetInt(Handle pb, const char[] field, int value, int index = PB_FIELD_NOT_REPEATED);

/**
 * Sets a float or double on a protobuf message.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param value         Float value to set.
 * @param index         Index into repeated field.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native void PbSetFloat(Handle pb, const char[] field, float value, int index = PB_FIELD_NOT_REPEATED);

/**
 * Sets a bool on a protobuf message.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param value         Boolean value to set.
 * @param index         Index into repeated field.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native void PbSetBool(Handle pb, const char[] field, bool value, int index = PB_FIELD_NOT_REPEATED);

/**
 * Sets a string on a protobuf message.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param value         String value to set.
 * @param index         Index into repeated field.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native void PbSetString(Handle pb, const char[] field, const char[] value, int index = PB_FIELD_NOT_REPEATED);

/**
 * Sets an RGBA color on a protobuf message.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param color         Color value to set.
 * @param index         Index into repeated field.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native void PbSetColor(Handle pb, const char[] field, const int color[4], int index = PB_FIELD_NOT_REPEATED);

/**
 * Sets an XYZ angle on a protobuf message.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param angle         Angle value to set.
 * @param index         Index into repeated field.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native void PbSetAngle(Handle pb, const char[] field, const float angle[3], int index = PB_FIELD_NOT_REPEATED);

/**
 * Sets an XYZ vector on a protobuf message.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param vec           Vector value to set.
 * @param index         Index into repeated field.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native void PbSetVector(Handle pb, const char[] field, const float vec[3], int index = PB_FIELD_NOT_REPEATED);

/**
 * Sets an XY vector on a protobuf message.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param vec           Vector value to set.
 * @param index         Index into repeated field.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native void PbSetVector2D(Handle pb, const char[] field, const float vec[2], int index = PB_FIELD_NOT_REPEATED);

/**
 * Add an int32, uint32, sint32, fixed32, sfixed32, or enum value to a protobuf message repeated field.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param value         Integer value to add.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native void PbAddInt(Handle pb, const char[] field, int value);

/**
 * Add a float or double to a protobuf message repeated field.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param value         Float value to add.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native void PbAddFloat(Handle pb, const char[] field, float value);

/**
 * Add a bool to a protobuf message repeated field.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param value         Boolean value to add.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native void PbAddBool(Handle pb, const char[] field, bool value);

/**
 * Add a string to a protobuf message repeated field.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param value         String value to add.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native void PbAddString(Handle pb, const char[] field, const char[] value);

/**
 * Add an RGBA color to a protobuf message repeated field.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param color         Color value to add.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native void PbAddColor(Handle pb, const char[] field, const int color[4]);

/**
 * Add an XYZ angle to a protobuf message repeated field.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param angle         Angle value to add.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native void PbAddAngle(Handle pb, const char[] field, const float angle[3]);

/**
 * Add an XYZ vector to a protobuf message repeated field.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param vec           Vector value to add.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native void PbAddVector(Handle pb, const char[] field, const float vec[3]);

/**
 * Add an XY vector to a protobuf message repeated field.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param vec           Vector value to add.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native void PbAddVector2D(Handle pb, const char[] field, const float vec[2]);

/**
 * Removes a value by index from a protobuf message repeated field.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param index         Index into repeated field.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native void PbRemoveRepeatedFieldValue(Handle pb, const char[] field, int index);

/**
 * Retrieve a handle to an embedded protobuf message in a protobuf message.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @return              protobuf handle to embedded message.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native Handle PbReadMessage(Handle pb, const char[] field);

/**
 * Retrieve a handle to an embedded protobuf message in a protobuf message repeated field.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @param index         Index in the repeated field.
 * @return              protobuf handle to embedded message.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native Handle PbReadRepeatedMessage(Handle pb, const char[] field, int index);

/**
 * Adds an embedded protobuf message to a protobuf message repeated field.
 *
 * @param pb            protobuf handle.
 * @param field         Field name.
 * @return              protobuf handle to added, embedded message.
 * @error               Invalid or incorrect Handle, non-existent field, or incorrect field type.
 */
native Handle PbAddMessage(Handle pb, const char[] field);
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2017 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _sdktools_included
 #endinput
#endif
#define _sdktools_included

#include <core>
#include <sdktools_engine>
#include <sdktools_functions>
#if !defined SDKTOOLS_DISABLE_SOUNDAPI
#include <sdktools_sound>
#endif
#include <sdktools_stringtables>
#include <sdktools_trace>
#include <sdktools_tempents>
#include <sdktools_tempents_stocks>
#include <sdktools_voice>
#include <sdktools_variant_t>
#include <sdktools_entinput>
#include <sdktools_entoutput>
#include <sdktools_hooks>
#include <sdktools_gamerules>
#include <sdktools_client>

enum SDKCallType
{
	SDKCall_Static,         /**< Static call */
	SDKCall_Entity,         /**< CBaseEntity call */
	SDKCall_Player,         /**< CBasePlayer call */
	SDKCall_GameRules,      /**< CGameRules call */
	SDKCall_EntityList,     /**< CGlobalEntityList call */
	SDKCall_Raw             /**< |this| pointer with an arbitrary address */
};

enum SDKLibrary
{
	SDKLibrary_Server,      /**< server.dll/server_i486.so */
	SDKLibrary_Engine       /**< engine.dll/engine_*.so */
};

enum SDKFuncConfSource
{
	SDKConf_Virtual = 0,    /**< Read a virtual index from the Offsets section */
	SDKConf_Signature = 1,  /**< Read a signature from the Signatures section */
	SDKConf_Address = 2     /**< Read an address from the Addresses section */
};

enum SDKType
{
	SDKType_CBaseEntity,    /**< CBaseEntity (always as pointer) */
	SDKType_CBasePlayer,    /**< CBasePlayer (always as pointer) */
	SDKType_Vector,         /**< Vector (pointer, byval, or byref) */
	SDKType_QAngle,         /**< QAngles (pointer, byval, or byref) */
	SDKType_PlainOldData,   /**< Integer/generic data <=32bit (any) */
	SDKType_Float,          /**< Float (any) */
	SDKType_Edict,          /**< edict_t (always as pointer) */
	SDKType_String,         /**< NULL-terminated string (always as pointer) */
	SDKType_Bool            /**< Boolean (any) */
};

enum SDKPassMethod
{
	SDKPass_Pointer,        /**< Pass as a pointer */
	SDKPass_Plain,          /**< Pass as plain data */
	SDKPass_ByValue,        /**< Pass an object by value */
	SDKPass_ByRef           /**< Pass an object by reference */
};

#define VDECODE_FLAG_ALLOWNULL      (1<<0)    /**< Allow NULL for pointers */
#define VDECODE_FLAG_ALLOWNOTINGAME (1<<1)    /**< Allow players not in game */
#define VDECODE_FLAG_ALLOWWORLD     (1<<2)    /**< Allow World entity */
#define VDECODE_FLAG_BYREF          (1<<3)    /**< Floats/ints by reference */

#define VENCODE_FLAG_COPYBACK       (1<<0)    /**< Copy back data once done */

/**
 * Starts the preparation of an SDK call.
 *
 * @param type          Type of function call this will be.
 */
native void StartPrepSDKCall(SDKCallType type);

/**
 * Sets the virtual index of the SDK call if it is virtual.
 *
 * @param vtblidx       Virtual table index.
 */
native void PrepSDKCall_SetVirtual(int vtblidx);

/**
 * Finds an address in a library and sets it as the address to use for the SDK call.
 *
 * @param lib           Library to use.
 * @param signature     Binary data to search for in the library.  If it starts with '@',
 *                      the bytes parameter is ignored and the signature is interpreted
 *                      as a symbol lookup in the library.
 * @param bytes         Number of bytes in the binary search string.
 * @return              True on success, false if nothing was found.
 */
native bool PrepSDKCall_SetSignature(SDKLibrary lib, const char[] signature, int bytes);

/**
 * Uses the given function address for the SDK call.
 *
 * @param addr          Address of function to use.
 * @return              True on success, false on failure.
 */
native bool PrepSDKCall_SetAddress(Address addr);

/**
 * Finds an address or virtual function index in a GameConfig file and sets it as
 * the calling information for the SDK call.
 *
 * @param gameconf      GameConfig Handle, or INVALID_HANDLE to use sdktools.games.txt.
 * @param source        Whether to look in Offsets or Signatures.
 * @param name          Name of the property to find.
 * @return              True on success, false if nothing was found.
 */
native bool PrepSDKCall_SetFromConf(Handle gameconf, SDKFuncConfSource source, const char[] name);

/**
 * Sets the return information of an SDK call.  Do not call this if there is no return data.
 * This must be called if there is a return value (i.e. it is not necessarily safe to ignore
 * the data).
 *
 * @param type          Data type to convert to/from.
 * @param pass          How the data is passed in C++.
 * @param decflags      Flags on decoding from the plugin to C++.
 * @param encflags      Flags on encoding from C++ to the plugin.
 */
native void PrepSDKCall_SetReturnInfo(SDKType type, SDKPassMethod pass, int decflags=0, int encflags=0);

/**
 * Adds a parameter to the calling convention.  This should be called in normal ascending order.
 *
 * @param type          Data type to convert to/from.
 * @param pass          How the data is passed in C++.
 * @param decflags      Flags on decoding from the plugin to C++.
 * @param encflags      Flags on encoding from C++ to the plugin.
 */
native void PrepSDKCall_AddParameter(SDKType type, SDKPassMethod pass, int decflags=0, int encflags=0);

/**
 * Finalizes an SDK call preparation and returns the resultant Handle.
 *
 * @return              A new SDKCall Handle on success, or INVALID_HANDLE on failure.
 */
native Handle EndPrepSDKCall();

/**
 * Calls an SDK function with the given parameters.
 *
 * If the call type is Entity or Player, the index MUST ALWAYS be the FIRST parameter passed.
 * If the call type is GameRules, then nothing special needs to be passed.
 * If the return value is a Vector or QAngles, the SECOND parameter must be a Float[3].
 * If the return value is a string, the THIRD parameter must be a String buffer, and the
 *  FOURTH parameter must be the maximum length.
 * All parameters must be passed after the above is followed.  Failure to follow these
 *  rules will result in crashes or wildly unexpected behavior!
 *
 * If the return value is a float or integer, the return value will be this value.
 * If the return value is a CBaseEntity, CBasePlayer, or edict, the return value will
 *  always be the entity index, or -1 for NULL.
 *
 * @param call          SDKCall Handle.
 * @param ...           Call Parameters.
 * @return              Simple return value, if any.
 * @error               Invalid Handle or internal decoding error.
 */
native any SDKCall(Handle call, any ...);

/**
 * Returns the entity index of the player resource/manager entity.
 *
 * @return              Index of resource entity or -1 if not found.
 */
native int GetPlayerResourceEntity();

#include <sdktools_stocks>

/**
 * Do not edit below this line!
 */
public Extension __ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
#if defined AUTOLOAD_EXTENSIONS
	autoload = 1,
#else
	autoload = 0,
#endif
#if defined REQUIRE_EXTENSIONS
	required = 1,
#else
	required = 0,
#endif
};
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2018 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _profiler_included
 #endinput
#endif
#define _profiler_included

/**
 * ONLY AVAILABLE ON WINDOWS RIGHT NOW K.
 */

methodmap Profiler < Handle
{
	// Creates a new profile object.  The Handle must be freed
	// using delete or CloseHandle().
	//
	// @return              A new Profiler Handle.
	public native Profiler();
	
	// Starts a cycle for profiling.
	public native void Start();

	// Stops a cycle for profiling.
	//
	// @error               Profiler was never started.
	public native void Stop();
	
	// Returns the amount of high-precision time in seconds
	// that passed during the profiler's last start/stop 
	// cycle.
	//
	// @return              Time elapsed in seconds.
	property float Time {
		public native get();
	}
};

/**
 * Creates a new profile object.  The Handle must be freed
 * using delete or CloseHandle().
 *
 * @return              Handle to the profiler object.
 */
native Profiler CreateProfiler();

/**
 * Starts profiling.
 *
 * @param prof          Profiling object.
 * @error               Invalid Handle.
 */
native void StartProfiling(Handle prof);

/**
 * Stops profiling.
 *
 * @param prof          Profiling object.
 * @error               Invalid Handle or profiling was never started.
 */
native void StopProfiling(Handle prof);

/**
 * Returns the amount of high-precision time in seconds
 * that passed during the profiler's last start/stop 
 * cycle.
 *
 * @param prof          Profiling object.
 * @return              Time elapsed in seconds.
 * @error               Invalid Handle.
 */
native float GetProfilerTime(Handle prof);

/**
 * Mark the start of a profiling event.
 *
 * @param group     Budget group. This can be "all" for a default, or a short
 *                  description like "Timers" or "Events".
 * @param name      A name to attribute to this profiling event.
 */
native void EnterProfilingEvent(const char[] group, const char[] name);

/**
 * Mark the end of the last profiling event. This must be called in the same
 * stack frame as StartProfilingEvent(). Not doing so, or throwing errors,
 * will make the resulting profile very wrong.
 */
native void LeaveProfilingEvent();

/**
 * Returns true if the global profiler is enabled; false otherwise. It is
 * not necessary to call this before Enter/LeaveProfilingEvent.
 */
native bool IsProfilingActive();
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _sdktools_stocks_included
 #endinput
#endif
#define _sdktools_stocks_included

/**
 * Given a partial team name, attempts to find a matching team.
 *
 * The search is performed case insensitively and only against the 
 * first N characters of the team names, where N is the number of 
 * characters in the search pattern.
 *
 * @param name          Partial or full team name.  
 * @return              A valid team index on success.
 *                      -1 if no team matched.
 *                      -2 if more than one team matched.
 */
stock int FindTeamByName(const char[] name)
{
	int name_len = strlen(name);
	int num_teams = GetTeamCount();
	char team_name[32];
	int found_team = -1;

	for (int i = 0; i < num_teams; i++)
	{
		GetTeamName(i, team_name, sizeof(team_name));

		if (strncmp(team_name, name, name_len, false) == 0)
		{
			if (found_team >= 0)
			{
				return -2;
			}
			else
			{
				found_team = i;
			}
		}
	}

	return found_team;
}
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2014 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _nextmap_included_
 #endinput
#endif
#define _nextmap_included_

/**
 * Sets SourceMod's internal nextmap.
 * Equivalent to changing sm_nextmap but with an added validity check.
 *
 * @param map           Next map to set.
 * @return              True if the nextmap was set, false if map was invalid.
 */
native bool SetNextMap(const char[] map);

/**
 * Returns SourceMod's internal nextmap.
 *
 * @param map           Buffer to store the nextmap name.
 * @param maxlen        Maximum length of the map buffer.
 * @return              True if a Map was found and copied, false if no nextmap is set (map will be unchanged).
 */
native bool GetNextMap(char[] map, int maxlen);

/**
 * Changes the current map and records the reason for the change with maphistory
 *
 * @param map           Map to change to.
 * @param reason        Reason for change.
 */
native void ForceChangeLevel(const char[] map, const char[] reason);

/**
 * Gets the current number of maps in the map history
 *
 * @return              Number of maps.
 */
native int GetMapHistorySize();

/**
 * Retrieves a map from the map history list.
 *
 * @param item          Item number. Must be 0 or greater and less than GetMapHistorySize().
 * @param map           Buffer to store the map name.
 * @param mapLen        Length of map buffer.
 * @param reason        Buffer to store the change reason.
 * @param reasonLen     Length of the reason buffer.
 * @param startTime     Time the map started.
 * @error               Invalid item number.
 */
native void GetMapHistory(int item, char[] map, int mapLen, char[] reason, int reasonLen, int &startTime);
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _te_stocks_included
 #endinput
#endif
#define _te_stocks_included

/**
 * @section TE Explosion flags.
 */
#define TE_EXPLFLAG_NONE            0x0   /**< all flags clear makes default Half-Life explosion */
#define TE_EXPLFLAG_NOADDITIVE      0x1   /**< sprite will be drawn opaque (ensure that the sprite you send is a non-additive sprite) */
#define TE_EXPLFLAG_NODLIGHTS       0x2   /**< do not render dynamic lights */
#define TE_EXPLFLAG_NOSOUND         0x4   /**< do not play client explosion sound */
#define TE_EXPLFLAG_NOPARTICLES     0x8   /**< do not draw particles */
#define TE_EXPLFLAG_DRAWALPHA       0x10  /**< sprite will be drawn alpha */
#define TE_EXPLFLAG_ROTATE          0x20  /**< rotate the sprite randomly */
#define TE_EXPLFLAG_NOFIREBALL      0x40  /**< do not draw a fireball */
#define TE_EXPLFLAG_NOFIREBALLSMOKE 0x80  /**< do not draw smoke with the fireball */

/**
 * @endsection
 */

/**
 * @section TE Beam flags.
 */
#define FBEAM_STARTENTITY   0x00000001
#define FBEAM_ENDENTITY     0x00000002
#define FBEAM_FADEIN        0x00000004
#define FBEAM_FADEOUT       0x00000008
#define FBEAM_SINENOISE     0x00000010
#define FBEAM_SOLID         0x00000020
#define FBEAM_SHADEIN       0x00000040
#define FBEAM_SHADEOUT      0x00000080
#define FBEAM_ONLYNOISEONCE 0x00000100  /**< Only calculate our noise once */
#define FBEAM_NOTILE        0x00000200
#define FBEAM_USE_HITBOXES  0x00000400  /**< Attachment indices represent hitbox indices instead when this is set. */
#define FBEAM_STARTVISIBLE  0x00000800  /**< Has this client actually seen this beam's start entity yet? */
#define FBEAM_ENDVISIBLE    0x00001000  /**< Has this client actually seen this beam's end entity yet? */
#define FBEAM_ISACTIVE      0x00002000
#define FBEAM_FOREVER       0x00004000
#define FBEAM_HALOBEAM      0x00008000  /**< When drawing a beam with a halo, don't ignore the segments and endwidth */

/**
 * @endsection
 */

/**
 * Sets up a sparks effect.
 *
 * @param pos           Position of the sparks.
 * @param dir           Direction of the sparks.
 * @param Magnitude     Sparks size.
 * @param TrailLength   Trail lenght of the sparks.
 */
stock void TE_SetupSparks(const float pos[3], const float dir[3], int Magnitude, int TrailLength)
{
	TE_Start("Sparks");
	TE_WriteVector("m_vecOrigin[0]", pos);
	TE_WriteVector("m_vecDir", dir);
	TE_WriteNum("m_nMagnitude", Magnitude);
	TE_WriteNum("m_nTrailLength", TrailLength);
}

/**
 * Sets up a smoke effect.
 *
 * @param pos           Position of the smoke.
 * @param Model         Precached model index.
 * @param Scale         Scale of the smoke.
 * @param FrameRate     Frame rate of the smoke.
 */
stock void TE_SetupSmoke(const float pos[3], int Model, float Scale, int FrameRate)
{
	TE_Start("Smoke");
	TE_WriteVector("m_vecOrigin", pos);
	TE_WriteNum("m_nModelIndex", Model);
	TE_WriteFloat("m_fScale", Scale);
	TE_WriteNum("m_nFrameRate", FrameRate);
}

/**
 * Sets up a dust cloud effect.
 *
 * @param pos           Position of the dust.
 * @param dir           Direction of the dust.
 * @param Size          Dust cloud size.
 * @param Speed         Dust cloud speed.
 */
stock void TE_SetupDust(const float pos[3], const float dir[3], float Size, float Speed)
{
	TE_Start("Dust");
	TE_WriteVector("m_vecOrigin[0]", pos);
	TE_WriteVector("m_vecDirection", dir);
	TE_WriteFloat("m_flSize", Size);
	TE_WriteFloat("m_flSpeed", Speed);
}

/**
 * Sets up a muzzle flash effect.
 *
 * @param pos           Position of the muzzle flash.
 * @param angles        Rotation angles of the muzzle flash.
 * @param Scale         Scale of the muzzle flash.
 * @param Type          Muzzle flash type to render (Mod specific).
 */
stock void TE_SetupMuzzleFlash(const float pos[3], const float angles[3], float Scale, int Type)
{
	TE_Start("MuzzleFlash");
	TE_WriteVector("m_vecOrigin", pos);
	TE_WriteVector("m_vecAngles", angles);
	TE_WriteFloat("m_flScale", Scale);
	TE_WriteNum("m_nType", Type);
}

/**
 * Sets up a metal sparks effect.
 *
 * @param pos           Position of the metal sparks.
 * @param dir           Direction of the metal sparks.
 */
stock void TE_SetupMetalSparks(const float pos[3], const float dir[3])
{
	TE_Start("Metal Sparks");
	TE_WriteVector("m_vecPos", pos);
	TE_WriteVector("m_vecDir", dir);
}

/**
 * Sets up an energy splash effect.
 *
 * @param pos           Position of the energy splash.
 * @param dir           Direction of the energy splash.
 * @param Explosive     Makes the effect explosive.
 */
stock void TE_SetupEnergySplash(const float pos[3], const float dir[3], bool Explosive)
{
	TE_Start("Energy Splash");
	TE_WriteVector("m_vecPos", pos);
	TE_WriteVector("m_vecDir", dir);
	TE_WriteNum("m_bExplosive", Explosive);
}

/**
 * Sets up an armor ricochet effect.
 *
 * @param pos           Position of the armor ricochet.
 * @param dir           Direction of the armor ricochet.
 */
stock void TE_SetupArmorRicochet(const float pos[3], const float dir[3])
{
	TE_Start("Armor Ricochet");
	TE_WriteVector("m_vecPos", pos);
	TE_WriteVector("m_vecDir", dir);
}

/**
 * Sets up a glowing sprite effect.
 *
 * @param pos           Position of the sprite.
 * @param Model         Precached model index.
 * @param Life          Time duration of the sprite.
 * @param Size          Sprite size.
 * @param Brightness    Sprite brightness.
 */
stock void TE_SetupGlowSprite(const float pos[3], int Model, float Life, float Size, int Brightness)
{
	TE_Start("GlowSprite");
	TE_WriteVector("m_vecOrigin", pos);
	TE_WriteNum("m_nModelIndex", Model);
	TE_WriteFloat("m_fScale", Size);
	TE_WriteFloat("m_fLife", Life);
	TE_WriteNum("m_nBrightness", Brightness);
}

/**
 * Sets up a explosion effect.
 *
 * @param pos           Explosion position.
 * @param Model         Precached model index.
 * @param Scale         Explosion scale.
 * @param Framerate     Explosion frame rate.
 * @param Flags         Explosion flags.
 * @param Radius        Explosion radius.
 * @param Magnitude     Explosion size.
 * @param normal        Normal vector to the explosion.
 * @param MaterialType  Exploded material type.
 */
stock void TE_SetupExplosion(const float pos[3], int Model, float Scale, int Framerate, int Flags, int Radius, int Magnitude, const float normal[3]={0.0, 0.0, 1.0}, int MaterialType='C')
{
	TE_Start("Explosion");
	TE_WriteVector("m_vecOrigin[0]", pos);
	TE_WriteVector("m_vecNormal", normal);
	TE_WriteNum("m_nModelIndex", Model);
	TE_WriteFloat("m_fScale", Scale);
	TE_WriteNum("m_nFrameRate", Framerate);
	TE_WriteNum("m_nFlags", Flags);
	TE_WriteNum("m_nRadius", Radius);
	TE_WriteNum("m_nMagnitude", Magnitude);
	TE_WriteNum("m_chMaterialType", MaterialType);
}

/**
 * Sets up a blood sprite effect.
 *
 * @param pos             Position of the sprite.
 * @param dir             Sprite direction.
 * @param color           Color array (r, g, b, a).
 * @param Size            Sprite size.
 * @param SprayModel      Precached model index.
 * @param BloodDropModel  Precached model index.
 */
stock void TE_SetupBloodSprite(const float pos[3], const float dir[3], const int color[4], int Size, int SprayModel, int BloodDropModel)
{
	TE_Start("Blood Sprite");
	TE_WriteVector("m_vecOrigin", pos);
	TE_WriteVector("m_vecDirection", dir);
	TE_WriteNum("r", color[0]);
	TE_WriteNum("g", color[1]);
	TE_WriteNum("b", color[2]);
	TE_WriteNum("a", color[3]);
	TE_WriteNum("m_nSize", Size);
	TE_WriteNum("m_nSprayModel", SprayModel);
	TE_WriteNum("m_nDropModel", BloodDropModel);
}

/**
 * Sets up a beam ring point effect.
 *
 * @param center        Center position of the ring.
 * @param Start_Radius  Initial ring radius.
 * @param End_Radius    Final ring radius.
 * @param ModelIndex    Precached model index.
 * @param HaloIndex     Precached model index.
 * @param StartFrame    Initial frame to render.
 * @param FrameRate     Ring frame rate.
 * @param Life          Time duration of the ring.
 * @param Width         Beam width.
 * @param Amplitude     Beam amplitude.
 * @param Color         Color array (r, g, b, a).
 * @param Speed         Speed of the beam.
 * @param Flags         Beam flags.
 */
stock void TE_SetupBeamRingPoint(const float center[3], float Start_Radius, float End_Radius, int ModelIndex, int HaloIndex, int StartFrame, 
				int FrameRate, float Life, float Width, float Amplitude, const int Color[4], int Speed, int Flags)
{
	TE_Start("BeamRingPoint");
	TE_WriteVector("m_vecCenter", center);
	TE_WriteFloat("m_flStartRadius", Start_Radius);
	TE_WriteFloat("m_flEndRadius", End_Radius);
	TE_WriteNum("m_nModelIndex", ModelIndex);
	TE_WriteNum("m_nHaloIndex", HaloIndex);
	TE_WriteNum("m_nStartFrame", StartFrame);
	TE_WriteNum("m_nFrameRate", FrameRate);
	TE_WriteFloat("m_fLife", Life);
	TE_WriteFloat("m_fWidth", Width);
	TE_WriteFloat("m_fEndWidth", Width);
	TE_WriteFloat("m_fAmplitude", Amplitude);
	TE_WriteNum("r", Color[0]);
	TE_WriteNum("g", Color[1]);
	TE_WriteNum("b", Color[2]);
	TE_WriteNum("a", Color[3]);
	TE_WriteNum("m_nSpeed", Speed);
	TE_WriteNum("m_nFlags", Flags);
	TE_WriteNum("m_nFadeLength", 0);
}

/**
 * Sets up a point to point beam effect.
 *
 * @param start         Start position of the beam.
 * @param end           End position of the beam.
 * @param ModelIndex    Precached model index.
 * @param HaloIndex     Precached model index.
 * @param StartFrame    Initial frame to render.
 * @param FrameRate     Beam frame rate.
 * @param Life          Time duration of the beam.
 * @param Width         Initial beam width.
 * @param EndWidth      Final beam width.
 * @param FadeLength    Beam fade time duration.
 * @param Amplitude     Beam amplitude.
 * @param Color         Color array (r, g, b, a).
 * @param Speed         Speed of the beam.
 */
stock void TE_SetupBeamPoints(const float start[3], const float end[3], int ModelIndex, int HaloIndex, int StartFrame, int FrameRate, float Life, 
				float Width, float EndWidth, int FadeLength, float Amplitude, const int Color[4], int Speed)
{
	TE_Start("BeamPoints");
	TE_WriteVector("m_vecStartPoint", start);
	TE_WriteVector("m_vecEndPoint", end);
	TE_WriteNum("m_nModelIndex", ModelIndex);
	TE_WriteNum("m_nHaloIndex", HaloIndex);
	TE_WriteNum("m_nStartFrame", StartFrame);
	TE_WriteNum("m_nFrameRate", FrameRate);
	TE_WriteFloat("m_fLife", Life);
	TE_WriteFloat("m_fWidth", Width);
	TE_WriteFloat("m_fEndWidth", EndWidth);
	TE_WriteFloat("m_fAmplitude", Amplitude);
	TE_WriteNum("r", Color[0]);
	TE_WriteNum("g", Color[1]);
	TE_WriteNum("b", Color[2]);
	TE_WriteNum("a", Color[3]);
	TE_WriteNum("m_nSpeed", Speed);
	TE_WriteNum("m_nFadeLength", FadeLength);
}

/**
 * Sets up an entity to entity laser effect.
 *
 * @param StartEntity   Entity index from where the beam starts.
 * @param EndEntity     Entity index from where the beam ends.
 * @param ModelIndex    Precached model index.
 * @param HaloIndex     Precached model index.
 * @param StartFrame    Initial frame to render.
 * @param FrameRate     Beam frame rate.
 * @param Life          Time duration of the beam.
 * @param Width         Initial beam width.
 * @param EndWidth      Final beam width.
 * @param FadeLength    Beam fade time duration.
 * @param Amplitude     Beam amplitude.
 * @param Color         Color array (r, g, b, a).
 * @param Speed         Speed of the beam.
 */
stock void TE_SetupBeamLaser(int StartEntity, int EndEntity, int ModelIndex, int HaloIndex, int StartFrame, int FrameRate, float Life, 
				float Width, float EndWidth, int FadeLength, float Amplitude, const int Color[4], int Speed)
{
	TE_Start("BeamLaser");
	TE_WriteEncodedEnt("m_nStartEntity", StartEntity);
	TE_WriteEncodedEnt("m_nEndEntity", EndEntity);
	TE_WriteNum("m_nModelIndex", ModelIndex);
	TE_WriteNum("m_nHaloIndex", HaloIndex);
	TE_WriteNum("m_nStartFrame", StartFrame);
	TE_WriteNum("m_nFrameRate", FrameRate);
	TE_WriteFloat("m_fLife", Life);
	TE_WriteFloat("m_fWidth", Width);
	TE_WriteFloat("m_fEndWidth", EndWidth);
	TE_WriteFloat("m_fAmplitude", Amplitude);
	TE_WriteNum("r", Color[0]);
	TE_WriteNum("g", Color[1]);
	TE_WriteNum("b", Color[2]);
	TE_WriteNum("a", Color[3]);
	TE_WriteNum("m_nSpeed", Speed);
	TE_WriteNum("m_nFadeLength", FadeLength);
}

/**
 * Sets up a beam ring effect.
 *
 * @param StartEntity   Entity index from where the ring starts.
 * @param EndEntity     Entity index from where the ring ends.
 * @param ModelIndex    Precached model index.
 * @param HaloIndex     Precached model index.
 * @param StartFrame    Initial frame to render.
 * @param FrameRate     Ring frame rate.
 * @param Life          Time duration of the ring.
 * @param Width         Beam width.
 * @param Amplitude     Beam amplitude.
 * @param Color         Color array (r, g, b, a).
 * @param Speed         Speed of the beam.
 * @param Flags         Beam flags.
 */
stock void TE_SetupBeamRing(int StartEntity, int EndEntity, int ModelIndex, int HaloIndex, int StartFrame, int FrameRate, float Life, float Width, float Amplitude, const int Color[4], int Speed, int Flags)
{
	TE_Start("BeamRing");
	TE_WriteEncodedEnt("m_nStartEntity", StartEntity);
	TE_WriteEncodedEnt("m_nEndEntity", EndEntity);
	TE_WriteNum("m_nModelIndex", ModelIndex);
	TE_WriteNum("m_nHaloIndex", HaloIndex);
	TE_WriteNum("m_nStartFrame", StartFrame);
	TE_WriteNum("m_nFrameRate", FrameRate);
	TE_WriteFloat("m_fLife", Life);
	TE_WriteFloat("m_fWidth", Width);
	TE_WriteFloat("m_fEndWidth", Width);
	TE_WriteFloat("m_fAmplitude", Amplitude);
	TE_WriteNum("r", Color[0]);
	TE_WriteNum("g", Color[1]);
	TE_WriteNum("b", Color[2]);
	TE_WriteNum("a", Color[3]);
	TE_WriteNum("m_nSpeed", Speed);
	TE_WriteNum("m_nFadeLength", 0);
	TE_WriteNum("m_nFlags", Flags);
}

/**
 * Sets up a follow beam effect.
 *
 * @param EntIndex      Entity index from where the beam starts.
 * @param ModelIndex    Precached model index.
 * @param HaloIndex     Precached model index.
 * @param Life          Time duration of the beam.
 * @param Width         Initial beam width.
 * @param EndWidth      Final beam width.
 * @param FadeLength    Beam fade time duration.
 * @param Color         Color array (r, g, b, a).
 */
stock void TE_SetupBeamFollow(int EntIndex, int ModelIndex, int HaloIndex, float Life, float Width, float EndWidth, int FadeLength, const int Color[4])
{
	TE_Start("BeamFollow");
	TE_WriteEncodedEnt("m_iEntIndex", EntIndex);
	TE_WriteNum("m_nModelIndex", ModelIndex);
	TE_WriteNum("m_nHaloIndex", HaloIndex);
	TE_WriteNum("m_nStartFrame", 0);
	TE_WriteNum("m_nFrameRate", 0);
	TE_WriteFloat("m_fLife", Life);
	TE_WriteFloat("m_fWidth", Width);
	TE_WriteFloat("m_fEndWidth", EndWidth);
	TE_WriteNum("m_nFadeLength", FadeLength);
	TE_WriteNum("r", Color[0]);
	TE_WriteNum("g", Color[1]);
	TE_WriteNum("b", Color[2]);
	TE_WriteNum("a", Color[3]);
}
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2009 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _sdktools_hooks_included
 #endinput
#endif
#define _sdktools_hooks_included

#define FEATURECAP_PLAYERRUNCMD_11PARAMS    "SDKTools PlayerRunCmd 11Params"

/**
 * Called when a clients movement buttons are being processed
 *
 * @param client        Index of the client.
 * @param buttons       Copyback buffer containing the current commands (as bitflags - see entity_prop_stocks.inc).
 * @param impulse       Copyback buffer containing the current impulse command.
 * @param vel           Players desired velocity.
 * @param angles        Players desired view angles.
 * @param weapon        Entity index of the new weapon if player switches weapon, 0 otherwise.
 * @param subtype       Weapon subtype when selected from a menu.
 * @param cmdnum        Command number. Increments from the first command sent.
 * @param tickcount     Tick count. A client's prediction based on the server's GetGameTickCount value.
 * @param seed          Random seed. Used to determine weapon recoil, spread, and other predicted elements.
 * @param mouse         Mouse direction (x, y).
 * @return              Plugin_Handled to block the commands from being processed, Plugin_Continue otherwise.
 *
 * @note To see if all 11 params are available, use FeatureType_Capability and FEATURECAP_PLAYERRUNCMD_11PARAMS.
 */
forward Action OnPlayerRunCmd(int client, int &buttons, int &impulse, float vel[3], float angles[3], int &weapon, int &subtype, int &cmdnum, int &tickcount, int &seed, int mouse[2]);

/**
 * Called after a clients movement buttons were processed.
 *
 * @param client        Index of the client.
 * @param buttons       The current commands (as bitflags - see entity_prop_stocks.inc).
 * @param impulse       The current impulse command.
 * @param vel           Players desired velocity.
 * @param angles        Players desired view angles.
 * @param weapon        Entity index of the new weapon if player switches weapon, 0 otherwise.
 * @param subtype       Weapon subtype when selected from a menu.
 * @param cmdnum        Command number. Increments from the first command sent.
 * @param tickcount     Tick count. A client's prediction based on the server's GetGameTickCount value.
 * @param seed          Random seed. Used to determine weapon recoil, spread, and other predicted elements.
 * @param mouse         Mouse direction (x, y).
 */
forward void OnPlayerRunCmdPost(int client, int buttons, int impulse, const float vel[3], const float angles[3], int weapon, int subtype, int cmdnum, int tickcount, int seed, const int mouse[2]);

/**
 * Called when a client requests a file from the server.
 *
 * @param client        Client index.
 * @param sFile         Requested file path.
 *
 * @return              Plugin_Handled to block the transfer, Plugin_Continue to let it proceed.
 */
forward Action OnFileSend(int client, const char[] sFile);

/**
 * Called when a client sends a file to the server.
 *
 * @param client        Client index.
 * @param sFile         Requested file path.
 *
 * @return              Plugin_Handled to block the transfer, Plugin_Continue to let it proceed.
 */
forward Action OnFileReceive(int client, const char[] sFile);
/**
 * vim: set ts=4 sw=4 tw=99 noet :
 * =============================================================================
 * SourceMod (C)2004-2014 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */
 
#if defined _dbi_included
 #endinput
#endif
#define _dbi_included

/**
 * Describes a database field fetch status.
 */
enum DBResult
{
	DBVal_Error = 0,        /**< Column number/field is invalid. */
	DBVal_TypeMismatch = 1, /**< You cannot retrieve this data with this type. */
	DBVal_Null = 2,         /**< Field has no data (NULL) */
	DBVal_Data = 3          /**< Field has data */
};

/**
 * Describes binding types.
 */
enum DBBindType
{
	DBBind_Int = 0,         /**< Bind an integer. */
	DBBind_Float = 1,       /**< Bind a float. */
	DBBind_String = 2       /**< Bind a string. */
};

/**
 * Threading priority level.
 */
enum DBPriority
{
	DBPrio_High = 0,        /**< High priority. */
	DBPrio_Normal = 1,      /**< Normal priority. */
	DBPrio_Low = 2          /**< Low priority. */
};

// A Driver represents a database backend, currently MySQL or SQLite.
//
// Driver handles cannot be closed.
methodmap DBDriver < Handle
{
	// Finds the driver associated with a name.
	//
	// Supported driver strings:
	//    mysql
	//    sqlite
	//
	// @param name          Driver identification string, or an empty string
	//                      to return the default driver.
	// @return              Driver handle, or null on failure.
	public static native DBDriver Find(const char[] name = "");

	// Retrieves a driver's identification string.
	//
	// Example: "mysql", "sqlite"
	//
	// @param ident         Identification string buffer.
	// @param maxlength     Maximum length of the buffer.
	public native void GetIdentifier(char[] ident, int maxlength);

	// Retrieves a driver's product string.
	//
	// Example: "MySQL", "SQLite"
	//
	// @param product       Product string buffer.
	// @param maxlength     Maximum length of the buffer.
	public native void GetProduct(char[] product, int maxlength);
};

// Represents a set of results returned from executing a query.
methodmap DBResultSet < Handle
{
	// Advances to the next set of results.
	//
	// In some SQL implementations, multiple result sets can exist on one query.  
	// This is possible in MySQL with simple queries when executing a CALL 
	// query.  If this is the case, all result sets must be processed before
	// another query is made.
	//
	// @return             True if there was another result set, false otherwise.
	public native bool FetchMoreResults();

	// Returns whether or not a result set exists.  This will
	// return true even if 0 results were returned, but false
	// on queries like UPDATE, INSERT, or DELETE.
	property bool HasResults {
		public native get();
	}

	// Retrieves the number of rows in the last result set.
	// 
	// @param query        A query (or statement) Handle.
	// @return             Number of rows in the current result set.
	property int RowCount {
		public native get();
	}

	// Retrieves the number of fields in the last result set.
	property int FieldCount {
		public native get();
	}

	// Returns the number of affected rows from the query that generated this
	// result set.
	property int AffectedRows {
		public native get();
	}

	// Returns the insert id from the query that generated this result set.
	property int InsertId {
		public native get();
	}

	// Retrieves the name of a field by index.
	// 
	// @param field        Field number (starting from 0).
	// @param name         Name buffer.
	// @param maxlength    Maximum length of the name buffer.
	// @error              Invalid field index, or no current result set.
	public native void FieldNumToName(int field, char[] name, int maxlength);

	// Retrieves a field index by name.
	// 
	// @param name         Name of the field (case sensitive).
	// @param field        Variable to store field index in.
	// @return             True if found, false if not found.
	// @error              No current result set.
	public native bool FieldNameToNum(const char[] name, int &field);

	// Fetches a row from the current result set.  This must be 
	// successfully called before any results are fetched.
	//
	// If this function fails, _MoreResults can be used to
	// tell if there was an error or the result set is finished.
	// 
	// @return             True if a row was fetched, false otherwise.
	public native bool FetchRow();

	// Returns if there are more rows.
	// 
	// @return             True if there are more rows, false otherwise.
	property bool MoreRows {
		public native get();
	}

	// Rewinds a result set back to the first result.
	// 
	// @return             True on success, false otherwise.
	// @error              No current result set.
	public native bool Rewind();

	// Fetches a string from a field in the current row of a result set.  
	// If the result is NULL, an empty string will be returned.  A NULL 
	// check can be done with the result parameter, or SQL_IsFieldNull().
	// 
	// @param field        The field index (starting from 0).
	// @param buffer       String buffer.
	// @param maxlength    Maximum size of the string buffer.
	// @param result       Optional variable to store the status of the return value.
	// @return             Number of bytes written.
	// @error              Invalid field index, invalid type conversion requested
	//                     from the database, or no current result set.
	public native int FetchString(int field, char[] buffer, int maxlength, DBResult &result=DBVal_Error);

	// Fetches a float from a field in the current row of a result set.  
	// If the result is NULL, a value of 0.0 will be returned.  A NULL 
	// check can be done with the result parameter, or SQL_IsFieldNull().
	// 
	// @param field        The field index (starting from 0).
	// @param result       Optional variable to store the status of the return value.
	// @return             A float value.
	// @error              Invalid field index, invalid type conversion requested
	//                     from the database, or no current result set.
	public native float FetchFloat(int field, DBResult &result=DBVal_Error);

	// Fetches an integer from a field in the current row of a result set.  
	// If the result is NULL, a value of 0 will be returned.  A NULL 
	// check can be done with the result parameter, or SQL_IsFieldNull().
	// 
	// @param field        The field index (starting from 0).
	// @param result       Optional variable to store the status of the return value.
	// @return             An integer value.
	// @error              Invalid field index, invalid type conversion requested
	//                     from the database, or no current result set.
	public native int FetchInt(int field, DBResult &result=DBVal_Error);

	// Returns whether a field's data in the current row of a result set is 
	// NULL or not.  NULL is an SQL type which means "no data."
	// 
	// @param field        The field index (starting from 0).
	// @return             True if data is NULL, false otherwise.
	// @error              Invalid field index, or no current result set.
	public native bool IsFieldNull(int field);

	// Returns the length of a field's data in the current row of a result
	// set.  This only needs to be called for strings to determine how many
	// bytes to use.  Note that the return value does not include the null
	// terminator.
	// 
	// @param field        The field index (starting from 0).
	// @return             Number of bytes for the field's data size.
	// @error              Invalid field index or no current result set.
	public native int FetchSize(int field);
};

typeset SQLTxnSuccess
{
	// Callback for a successful transaction.
	// 
	// @param db            Database handle.
	// @param data          Data value passed to SQL_ExecuteTransaction().
	// @param numQueries    Number of queries executed in the transaction.
	// @param results       An array of Query handle results, one for each of numQueries. They are closed automatically.
	// @param queryData     An array of each data value passed to SQL_AddQuery().
	function void (Database db, any data, int numQueries, Handle[] results, any[] queryData);
	
	// Callback for a successful transaction.
	// 
	// @param db            Database handle.
	// @param data          Data value passed to SQL_ExecuteTransaction().
	// @param numQueries    Number of queries executed in the transaction.
	// @param results       An array of DBResultSet results, one for each of numQueries. They are closed automatically.
	// @param queryData     An array of each data value passed to SQL_AddQuery().
	function void (Database db, any data, int numQueries, DBResultSet[] results, any[] queryData);	
}

/**
 * Callback for a failed transaction.
 *
 * @param db            Database handle.
 * @param data          Data value passed to SQL_ExecuteTransaction().
 * @param numQueries    Number of queries executed in the transaction.
 * @param error         Error message.
 * @param failIndex     Index of the query that failed, or -1 if something else.
 * @param queryData     An array of each data value passed to SQL_AddQuery().
 */
typedef SQLTxnFailure = function void (Database db, any data, int numQueries, const char[] error, int failIndex, any[] queryData);

// A Transaction is a collection of SQL statements that must all execute
// successfully or not at all.
methodmap Transaction < Handle
{
	// Create a new transaction.
	public native Transaction();

	// Adds a query to the transaction.
	//
	// @param query        Query string.
	// @param data         Extra data value to pass to the final callback.
	// @return             The index of the query in the transaction's query list.
	public native int AddQuery(const char[] query, any data=0);
};

// A DBStatement is a pre-compiled SQL query that may be executed multiple
// times with different parameters. A DBStatement holds a reference to the
// Database that prepared it.
methodmap DBStatement < Handle
{
	// Binds a parameter in a prepared statement to a given integer value.
	// 
	// @param param         The parameter index (starting from 0).
	// @param number        The number to bind.
	// @param signed        True to bind the number as signed, false to 
	//                      bind it as unsigned.
	// @error               Invalid parameter index, or SQL error.
	public native void BindInt(int param, int number, bool signed=true);

	// Binds a parameter in a prepared statement to a given float value.
	// 
	// @param param         The parameter index (starting from 0).
	// @param value         The float number to bind.
	// @error               Invalid parameter index, or SQL error.
	public native void BindFloat(int param, float value);

	// Binds a parameter in a prepared statement to a given string value.
	// 
	// @param param         The parameter index (starting from 0).
	// @param value         The string to bind.
	// @param copy          Whether or not SourceMod should copy the value
	//                      locally if necessary.  If the string contents
	//                      won't change before calling SQL_Execute(), this
	//                      can be set to false for optimization.
	// @error               Invalid parameter index, or SQL error.
	public native void BindString(int param, const char[] value, bool copy);
};

/**
 * Callback for receiving asynchronous database connections.
 *
 * @param db            Handle to the database connection.
 * @param error         Error string if there was an error.  The error could be 
 *                      empty even if an error condition exists, so it is important 
 *                      to check the actual Handle value instead.
 * @param data          Data passed in via the original threaded invocation.
 */
typedef SQLConnectCallback = function void (Database db, const char[] error, any data);

/**
 * Callback for receiving asynchronous database query results.
 *
 * @param db            Cloned handle to the database connection.
 * @param results       Result object, or null on failure.
 * @param error         Error string if there was an error.  The error could be 
 *                      empty even if an error condition exists, so it is important 
 *                      to check the actual results value instead.
 * @param data          Data passed in via the original threaded invocation.
 */
typedef SQLQueryCallback = function void (Database db, DBResultSet results, const char[] error, any data);

// A Database represents a live connection to a database, either over the
// wire, through a unix domain socket, or over an open file.
methodmap Database < Handle
{
	// Connects to a database asynchronously, so the game thread is not blocked.
	//
	// @param callback      Callback. If no driver was found, the owner is null.
	// @param name          Database configuration name.
	// @param data          Extra data value to pass to the callback.
	public static native void Connect(SQLConnectCallback callback, const char[] name="default", any data=0);

	// Returns the driver for this database connection.
	property DBDriver Driver {
		public native get();
	}

	// Sets the character set of the connection. 
	// Like SET NAMES .. in mysql, but stays after connection problems.
	// 
	// Example: "utf8", "latin1"
	//
	// @param characterset  The character set string to change to.
	// @return              True, if character set was changed, false otherwise.
	public native bool SetCharset(const char[] charset);

	// Escapes a database string for literal insertion.  This is not needed
	// for binding strings in prepared statements.  
	//
	// Generally, database strings are inserted into queries enclosed in 
	// single quotes (').  If user input has a single quote in it, the 
	// quote needs to be escaped.  This function ensures that any unsafe 
	// characters are safely escaped according to the database engine and 
	// the database's character set.
	//
	// NOTE: SourceMod only guarantees properly escaped strings when the query
	// encloses the string in ''. While drivers tend to allow " instead, the string
	// may be not be escaped (for example, on SQLite)!
	//
	// @param string        String to quote.
	// @param buffer        Buffer to store quoted string in.
	// @param maxlength     Maximum length of the buffer.
	// @param written       Optionally returns the number of bytes written.
	// @return              True on success, false if buffer is not big enough.
	//                      The buffer must be at least 2*strlen(string)+1.
	public native bool Escape(const char[] string, char[] buffer, int maxlength, int &written=0);

	// Formats a string according to the SourceMod format rules (see documentation).
	// All format specifiers are escaped (see SQL_EscapeString) unless the '!' flag is used.
	//
	// @param buffer        Destination string buffer.
	// @param maxlength     Maximum length of output string buffer.
	// @param format        Formatting rules.
	// @param ...           Variable number of format parameters.
	// @return              Number of cells written.
	public native int Format(const char[] buffer, int maxlength, const char[] format, any ...);

	// Returns whether a database is the same connection as another database.
	public native bool IsSameConnection(Database other);

	// Executes a query via a thread. The result handle is passed through the
	// callback.
	//
	// The database handle returned through the callback is always a new Handle,
	// and if necessary, IsSameConnection() should be used to test against other
	// connections.
	//
	// The result handle returned through the callback is temporary and destroyed 
	// at the end of the callback.
	//
	// @param callback       Callback.
	// @param query          Query string.
	// @param data           Extra data value to pass to the callback.
	// @param prio           Priority queue to use.
	public native void Query(SQLQueryCallback callback, const char[] query,
	                         any data = 0,
	                         DBPriority prio = DBPrio_Normal);

	// Sends a transaction to the database thread. The transaction handle is
	// automatically closed. When the transaction completes, the optional
	// callback is invoked.
	//
	// @param txn            A transaction handle.
	// @param onSuccess      An optional callback to receive a successful transaction.
	// @param onError        An optional callback to receive an error message.
	// @param data           An optional value to pass to callbacks.
	// @param prio           Priority queue to use.
	public native void Execute(Transaction txn,
	                           SQLTxnSuccess onSuccess = INVALID_FUNCTION,
	                           SQLTxnFailure onError = INVALID_FUNCTION,
	                           any data = 0,
	                           DBPriority priority = DBPrio_Normal);
};

/**
 * Creates an SQL connection from a named configuration.
 *
 * @param confname      Named configuration.
 * @param persistent    True to re-use a previous persistent connection if
 *                      possible, false otherwise.
 * @param error         Error buffer.
 * @param maxlength     Maximum length of the error buffer.
 * @return              A database connection Handle, or INVALID_HANDLE on failure.
 */
native Database SQL_Connect(const char[] confname, bool persistent, char[] error, int maxlength);

/**
 * Creates a default SQL connection.
 *
 * @param error         Error buffer.
 * @param maxlength     Maximum length of the error buffer.
 * @param persistent    True to re-use a previous persistent connection
 *                      if possible, false otherwise.
 * @return              A database connection Handle, or INVALID_HANDLE on failure.
 *                      On failure the error buffer will be filled with a message.
 */
stock Database SQL_DefConnect(char[] error, int maxlength, bool persistent=true)
{
	return SQL_Connect("default", persistent, error, maxlength);
}

/**
 * Connects to a database using key value pairs containing the database info.
 * The key/value pairs should match what would be in databases.cfg.
 *
 * I.e. "driver" should be "default" or a driver name (or omitted for 
 * the default).  For SQLite, only the "database" parameter is needed in addition.
 * For drivers which require external connections, more of the parameters may be 
 * needed.
 *
 * In general it is discouraged to use this function.  Connections should go through 
 * databases.cfg for greatest flexibility on behalf of users.
 *
 * @param keyvalues     Key/value pairs from a KeyValues handle, describing the connection.
 * @param error         Error buffer.
 * @param maxlength     Maximum length of the error buffer.
 * @param persistent    True to re-use a previous persistent connection if
 *                      possible, false otherwise.
 * @return              A database connection Handle, or INVALID_HANDLE on failure.
 *                      On failure the error buffer will be filled with a message.
 * @error               Invalid KeyValues handle.
 */
native Database SQL_ConnectCustom(Handle keyvalues,
								  char[] error,
								  int maxlength,
								  bool persistent);

/**
 * Grabs a handle to an SQLite database, creating one if it does not exist.  
 *
 * Unless there are extenuating circumstances, you should consider using "sourcemod-local" as the 
 * database name.  This provides some unification between plugins on behalf of users.
 *
 * As a precaution, you should always create some sort of unique prefix to your table names so 
 * there are no conflicts, and you should never drop or modify tables that you do not own.
 *
 * @param database      Database name.  
 * @param error         Error buffer.
 * @param maxlength     Maximum length of the error buffer.
 * @return              A database connection Handle, or INVALID_HANDLE on failure.
 *                      On failure the error buffer will be filled with a message.
 */
stock Database SQLite_UseDatabase(const char[] database, char[] error, int maxlength)
{
	KeyValues kv = new KeyValues("");
	kv.SetString("driver", "sqlite");
	kv.SetString("database", database);

	Database db = SQL_ConnectCustom(kv, error, maxlength, false);

	delete kv;

	return db;
}

/**
 * This function is deprecated.  Use SQL_ConnectCustom or SQLite_UseDatabase instead.
 * @deprecated
 */
#pragma deprecated Use SQL_ConnectCustom instead.
native Handle SQL_ConnectEx(Handle driver, 
							const char[] host,
							const char[] user, 
							const char[] pass,
							const char[] database,
							char[] error,
							int maxlength,
							bool persistent=true,
							int port=0,
							int maxTimeout=0);
							
/**
 * Returns if a named configuration is present in databases.cfg.
 *
 * @param name          Configuration name.
 * @return              True if it exists, false otherwise.
 */
native bool SQL_CheckConfig(const char[] name);

/**
 * Returns a driver Handle from a name string.
 *
 * If the driver is not found, SourceMod will attempt
 * to load an extension named dbi.<name>.ext.[dll|so].
 *
 * @param name          Driver identification string, or an empty
 *                      string to return the default driver.
 * @return              Driver Handle, or INVALID_HANDLE on failure.
 */
native Handle SQL_GetDriver(const char[] name="");

/**
 * Reads the driver of an opened database.
 *
 * @param database      Database Handle.
 * @param ident         Option buffer to store the identification string.
 * @param ident_length  Maximum length of the buffer.
 * @return              Driver Handle.
 */
native Handle SQL_ReadDriver(Handle database, char[] ident="", int ident_length=0);

/**
 * Retrieves a driver's identification string.
 *
 * Example: "mysql", "sqlite"
 *
 * @param driver        Driver Handle, or INVALID_HANDLE for the default driver.
 * @param ident         Identification string buffer.
 * @param maxlength     Maximum length of the buffer.
 * @error               Invalid Handle other than INVALID_HANDLE.
 */
native void SQL_GetDriverIdent(Handle driver, char[] ident, int maxlength);

/**
 * Retrieves a driver's product string.
 *
 * Example: "MySQL", "SQLite"
 *
 * @param driver        Driver Handle, or INVALID_HANDLE for the default driver.
 * @param product       Product string buffer.
 * @param maxlength     Maximum length of the buffer.
 * @error               Invalid Handle other than INVALID_HANDLE.
 */
native void SQL_GetDriverProduct(Handle driver, char[] product, int maxlength);

/**
 * Sets the character set of the current connection. 
 * Like SET NAMES .. in mysql, but stays after connection problems.
 * 
 * Example: "utf8", "latin1"
 *
 * @param database      Database Handle.
 * @param characterset  The character set string to change to.
 * @return              True, if character set was changed, false otherwise.
 */
native bool SQL_SetCharset(Handle database, const char[] charset);

/**
 * Returns the number of affected rows from the last query.
 *
 * @param hndl          A database OR statement Handle.
 * @return              Number of rows affected by the last query.
 * @error               Invalid database or statement Handle.
 */
native int SQL_GetAffectedRows(Handle hndl);

/**
 * Returns the last query's insertion id.
 *
 * @param hndl          A database, query, OR statement Handle.
 * @return              Last query's insertion id.
 * @error               Invalid database, query, or statement Handle.
 */
native int SQL_GetInsertId(Handle hndl);

/**
 * Returns the error reported by the last query.
 *
 * @param hndl          A database, query, OR statement Handle.
 * @param error         Error buffer.
 * @param maxlength     Maximum length of the buffer.
 * @return              True if there was an error, false otherwise.
 * @error               Invalid database, query, or statement Handle.
 */
native bool SQL_GetError(Handle hndl, char[] error, int maxlength);

/**
 * Escapes a database string for literal insertion.  This is not needed
 * for binding strings in prepared statements.  
 *
 * Generally, database strings are inserted into queries enclosed in 
 * single quotes (').  If user input has a single quote in it, the 
 * quote needs to be escaped.  This function ensures that any unsafe 
 * characters are safely escaped according to the database engine and 
 * the database's character set.
 *
 * NOTE: SourceMod only guarantees properly escaped strings when the query
 * encloses the string in ''. While drivers tend to allow " instead, the string
 * may be not be escaped (for example, on SQLite)!
 *
 * @param database      A database Handle.
 * @param string        String to quote.
 * @param buffer        Buffer to store quoted string in.
 * @param maxlength     Maximum length of the buffer.
 * @param written       Optionally returns the number of bytes written.
 * @return              True on success, false if buffer is not big enough.
 *                      The buffer must be at least 2*strlen(string)+1.
 * @error               Invalid database or statement Handle.
 */
native bool SQL_EscapeString(Handle database, 
							 const char[] string, 
							 char[] buffer, 
							 int maxlength, 
							 int &written=0);

/**
 * Formats a string according to the SourceMod format rules (see documentation).
 * All format specifiers are escaped (see SQL_EscapeString) unless the '!' flag is used.
 *
 * @param database      A database Handle.
 * @param buffer        Destination string buffer.
 * @param maxlength     Maximum length of output string buffer.
 * @param format        Formatting rules.
 * @param ...           Variable number of format parameters.
 * @return              Number of cells written.
 */
native int SQL_FormatQuery(Handle database, const char[] buffer, int maxlength, const char[] format, any ...);

/**
 * This function is deprecated.  Use SQL_EscapeString instead.
 * @deprecated
 */
#pragma deprecated Use SQL_EscapeString instead.
stock bool SQL_QuoteString(Handle database,
						   const char[] string,
						   char[] buffer,
						   int maxlength,
						   int &written=0)
{
	return SQL_EscapeString(database, string, buffer, maxlength, written);
}

/**
 * Executes a query and ignores the result set.
 *
 * @param database      A database Handle.
 * @param query         Query string.
 * @param len           Optional parameter to specify the query length, in 
 *                      bytes.  This can be used to send binary queries that 
 *                      have a premature terminator.
 * @return              True if query succeeded, false otherwise.  Use
 *                      SQL_GetError to find the last error.
 * @error               Invalid database Handle.
 */
native bool SQL_FastQuery(Handle database, const char[] query, int len=-1);

/**
 * Executes a simple query and returns a new query Handle for
 * receiving the results.
 *
 * @param database      A database Handle.
 * @param query         Query string.
 * @param len           Optional parameter to specify the query length, in 
 *                      bytes.  This can be used to send binary queries that 
 *                      have a premature terminator.
 * @return              A new Query Handle on success, INVALID_HANDLE
 *                      otherwise.  The Handle must be freed with CloseHandle().
 * @error               Invalid database Handle.
 */
native DBResultSet SQL_Query(Handle database, const char[] query, int len=-1);

/**
 * Creates a new prepared statement query.  Prepared statements can
 * be executed any number of times.  They can also have placeholder
 * parameters, similar to variables, which can be bound safely and
 * securely (for example, you do not need to quote bound strings).
 *
 * Statement handles will work in any function that accepts a Query handle.
 *
 * @param database      A database Handle.
 * @param query         Query string.
 * @param error         Error buffer.
 * @param maxlength     Maximum size of the error buffer.
 * @return              A new statement Handle on success, INVALID_HANDLE
 *                      otherwise.  The Handle must be freed with CloseHandle().
 * @error               Invalid database Handle.
 */
native DBStatement SQL_PrepareQuery(Handle database, const char[] query, char[] error, int maxlength);

/**
 * Advances to the next set of results.
 *
 * In some SQL implementations, multiple result sets can exist on one query.  
 * This is possible in MySQL with simple queries when executing a CALL 
 * query.  If this is the case, all result sets must be processed before
 * another query is made.
 *
 * @param query         A query Handle.
 * @return              True if there was another result set, false otherwise.
 * @error               Invalid query Handle.
 */
native bool SQL_FetchMoreResults(Handle query);

/**
 * Returns whether or not a result set exists.  This will
 * return true even if 0 results were returned, but false
 * on queries like UPDATE, INSERT, or DELETE.
 *
 * @param query         A query (or statement) Handle.
 * @return              True if there is a result set, false otherwise.
 * @error               Invalid query Handle.
 */
native bool SQL_HasResultSet(Handle query);

/**
 * Retrieves the number of rows in the last result set.
 * 
 * @param query         A query (or statement) Handle.
 * @return              Number of rows in the current result set.
 * @error               Invalid query Handle.
 */
native int SQL_GetRowCount(Handle query);

/**
 * Retrieves the number of fields in the last result set.
 * 
 * @param query         A query (or statement) Handle.
 * @return              Number of fields in the current result set.
 * @error               Invalid query Handle.
 */
native int SQL_GetFieldCount(Handle query);

/**
 * Retrieves the name of a field by index.
 * 
 * @param query         A query (or statement) Handle.
 * @param field         Field number (starting from 0).
 * @param name          Name buffer.
 * @param maxlength     Maximum length of the name buffer.
 * @error               Invalid query Handle, invalid field index, or
 *                      no current result set.
 */
native void SQL_FieldNumToName(Handle query, int field, char[] name, int maxlength);

/**
 * Retrieves a field index by name.
 * 
 * @param query         A query (or statement) Handle.
 * @param name          Name of the field (case sensitive).
 * @param field         Variable to store field index in.
 * @return              True if found, false if not found.
 * @error               Invalid query Handle or no current result set.
 */
native bool SQL_FieldNameToNum(Handle query, const char[] name, int &field);

/**
 * Fetches a row from the current result set.  This must be 
 * successfully called before any results are fetched.
 *
 * If this function fails, SQL_MoreResults() can be used to
 * tell if there was an error or the result set is finished.
 * 
 * @param query         A query (or statement) Handle.
 * @return              True if a row was fetched, false otherwise.
 * @error               Invalid query Handle.
 */
native bool SQL_FetchRow(Handle query);

/**
 * Returns if there are more rows.
 * 
 * @param query         A query (or statement) Handle.
 * @return              True if there are more rows, false otherwise.
 * @error               Invalid query Handle.
 */
native bool SQL_MoreRows(Handle query);

/**
 * Rewinds a result set back to the first result.
 * 
 * @param query         A query (or statement) Handle.
 * @return              True on success, false otherwise.
 * @error               Invalid query Handle or no current result set.
 */
native bool SQL_Rewind(Handle query);

/**
 * Fetches a string from a field in the current row of a result set.  
 * If the result is NULL, an empty string will be returned.  A NULL 
 * check can be done with the result parameter, or SQL_IsFieldNull().
 * 
 * @param query         A query (or statement) Handle.
 * @param field         The field index (starting from 0).
 * @param buffer        String buffer.
 * @param maxlength     Maximum size of the string buffer.
 * @param result        Optional variable to store the status of the return value.
 * @return              Number of bytes written.
 * @error               Invalid query Handle or field index, invalid
 *                      type conversion requested from the database,
 *                      or no current result set.
 */
native int SQL_FetchString(Handle query, int field, char[] buffer, int maxlength, DBResult &result=DBVal_Error);

/**
 * Fetches a float from a field in the current row of a result set.  
 * If the result is NULL, a value of 0.0 will be returned.  A NULL 
 * check can be done with the result parameter, or SQL_IsFieldNull().
 * 
 * @param query         A query (or statement) Handle.
 * @param field         The field index (starting from 0).
 * @param result        Optional variable to store the status of the return value.
 * @return              A float value.
 * @error               Invalid query Handle or field index, invalid
 *                      type conversion requested from the database,
 *                      or no current result set.
 */
native float SQL_FetchFloat(Handle query, int field, DBResult &result=DBVal_Error);

/**
 * Fetches an integer from a field in the current row of a result set.  
 * If the result is NULL, a value of 0 will be returned.  A NULL 
 * check can be done with the result parameter, or SQL_IsFieldNull().
 * 
 * @param query         A query (or statement) Handle.
 * @param field         The field index (starting from 0).
 * @param result        Optional variable to store the status of the return value.
 * @return              An integer value.
 * @error               Invalid query Handle or field index, invalid
 *                      type conversion requested from the database,
 *                      or no current result set.
 */
native int SQL_FetchInt(Handle query, int field, DBResult &result=DBVal_Error);

/**
 * Returns whether a field's data in the current row of a result set is 
 * NULL or not.  NULL is an SQL type which means "no data."
 * 
 * @param query         A query (or statement) Handle.
 * @param field         The field index (starting from 0).
 * @return              True if data is NULL, false otherwise.
 * @error               Invalid query Handle or field index, or no
 *                      current result set.
 */
native bool SQL_IsFieldNull(Handle query, int field);

/**
 * Returns the length of a field's data in the current row of a result
 * set.  This only needs to be called for strings to determine how many
 * bytes to use.  Note that the return value does not include the null
 * terminator.
 * 
 * @param query         A query (or statement) Handle.
 * @param field         The field index (starting from 0).
 * @return              Number of bytes for the field's data size.
 * @error               Invalid query Handle or field index or no
 *                      current result set.
 */
native int SQL_FetchSize(Handle query, int field);

/**
 * Binds a parameter in a prepared statement to a given integer value.
 * 
 * @param statement     A statement (prepared query) Handle.
 * @param param         The parameter index (starting from 0).
 * @param number        The number to bind.
 * @param signed        True to bind the number as signed, false to 
 *                      bind it as unsigned.
 * @error               Invalid statement Handle or parameter index, or
 *                      SQL error.
 */
native void SQL_BindParamInt(Handle statement, int param, int number, bool signed=true);

/**
 * Binds a parameter in a prepared statement to a given float value.
 * 
 * @param statement     A statement (prepared query) Handle.
 * @param param         The parameter index (starting from 0).
 * @param value         The float number to bind.
 * @error               Invalid statement Handle or parameter index, or
 *                      SQL error.
 */
native void SQL_BindParamFloat(Handle statement, int param, float value);

/**
 * Binds a parameter in a prepared statement to a given string value.
 * 
 * @param statement     A statement (prepared query) Handle.
 * @param param         The parameter index (starting from 0).
 * @param value         The string to bind.
 * @param copy          Whether or not SourceMod should copy the value
 *                      locally if necessary.  If the string contents
 *                      won't change before calling SQL_Execute(), this
 *                      can be set to false for optimization.
 * @error               Invalid statement Handle or parameter index, or
 *                      SQL error.
 */
native void SQL_BindParamString(Handle statement, int param, const char[] value, bool copy);

/**
 * Executes a prepared statement.  All parameters must be bound beforehand.
 *
 * @param statement     A statement (prepared query) Handle.
 * @return              True on success, false on failure.
 * @error               Invalid statement Handle.
 */
native bool SQL_Execute(Handle statement);

/**
 * Locks a database so threading operations will not interrupt.
 * 
 * If you are using a database Handle for both threading and non-threading,
 * this MUST be called before doing any set of non-threading DB operations.
 * Otherwise you risk corrupting the database driver's memory or network
 * connection.
 * 
 * Leaving a lock on a database and then executing a threaded query results
 * in a dead lock! Make sure to call SQL_UnlockDatabase()!
 *
 * If the lock cannot be acquired, the main thread will pause until the 
 * threaded operation has concluded.
 *
 * @param database      A database Handle.
 * @error               Invalid database Handle.
 */
native void SQL_LockDatabase(Handle database);

/**
 * Unlocks a database so threading operations may continue.
 *
 * @param database      A database Handle.
 * @error               Invalid database Handle.
 */
native void SQL_UnlockDatabase(Handle database);

/**
 * General callback for threaded SQL stuff.
 * 
 * @param owner         Parent object of the Handle (or INVALID_HANDLE if none).
 * @param hndl          Handle to the child object (or INVALID_HANDLE if none).
 * @param error         Error string if there was an error.  The error could be 
 *                      empty even if an error condition exists, so it is important 
 *                      to check the actual Handle value instead.
 * @param data          Data passed in via the original threaded invocation.
 */
typedef SQLTCallback = function void (Handle owner, Handle hndl, const char[] error, any data);

/**
 * Tells whether two database handles both point to the same database 
 * connection.
 *
 * @param hndl1         First database Handle.
 * @param hndl2         Second database Handle.
 * @return              True if the Handles point to the same 
 *                      connection, false otherwise.
 * @error               Invalid Handle.
 */
native bool SQL_IsSameConnection(Handle hndl1, Handle hndl2);

/**
 * Connects to a database via a thread.  This can be used instead of
 * SQL_Connect() if you wish for non-blocking functionality.
 *
 * It is not necessary to use this to use threaded queries.  However, if you 
 * don't (or you mix threaded/non-threaded queries), you should see 
 * SQL_LockDatabase().
 *
 * @param callback      Callback; new Handle will be in hndl, owner is the driver.
 *                      If no driver was found, the owner is INVALID_HANDLE.
 * @param name          Database name.
 * @param data          Extra data value to pass to the callback.
 */
native void SQL_TConnect(SQLTCallback callback, const char[] name="default", any data=0);

/**
 * Executes a simple query via a thread.  The query Handle is passed through
 * the callback.
 *
 * The database Handle returned through the callback is always a new Handle,
 * and if necessary, SQL_IsSameConnection() should be used to test against
 * other connections.
 *
 * The query Handle returned through the callback is temporary and destroyed 
 * at the end of the callback.  If you need to hold onto it, use CloneHandle().
 *
 * @param database      A database Handle.
 * @param callback      Callback; database is in "owner" and the query Handle
 *                      is passed in "hndl".
 * @param query         Query string.
 * @param data          Extra data value to pass to the callback.
 * @param prio          Priority queue to use.
 * @error               Invalid database Handle.
 */
native void SQL_TQuery(Handle database, SQLTCallback callback, const char[] query, any data=0, DBPriority prio=DBPrio_Normal);

/**
 * Creates a new transaction object. A transaction object is a list of queries
 * that can be sent to the database thread and executed as a single transaction.
 *
 * @return              A transaction handle.
 */
native Transaction SQL_CreateTransaction();

/**
 * Adds a query to a transaction object.
 *
 * @param txn           A transaction handle.
 * @param query         Query string.
 * @param data          Extra data value to pass to the final callback.
 * @return              The index of the query in the transaction's query list.
 * @error               Invalid transaction handle.
 */
native int SQL_AddQuery(Transaction txn, const char[] query, any data=0);

/**
 * Sends a transaction to the database thread. The transaction handle is
 * automatically closed. When the transaction completes, the optional
 * callback is invoked.
 *
 * @param db            A database handle.
 * @param txn           A transaction handle.
 * @param onSuccess     An optional callback to receive a successful transaction.
 * @param onError       An optional callback to receive an error message.
 * @param data          An optional value to pass to callbacks.
 * @param prio          Priority queue to use.
 * @error               An invalid handle.
 */
native void SQL_ExecuteTransaction(
		Handle db,
		Transaction txn,
		SQLTxnSuccess onSuccess = INVALID_FUNCTION,
		SQLTxnFailure onError = INVALID_FUNCTION,
		any data=0,
		DBPriority priority=DBPrio_Normal);
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2017 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _sdktools_entoutput_included
 #endinput
#endif
#define _sdktools_entoutput_included

/**
 * Called when an entity output is fired.
 *
 * @param output        Name of the output that fired.
 * @param caller        Entity index of the caller.
 * @param activator     Entity index of the activator.
 * @param delay         Delay in seconds? before the event gets fired.
 * @return              Anything other than Plugin_Continue will supress this event,
 *                      returning Plugin_Continue will allow it to propagate the results
 *                      of this output to any entity inputs.
 */
typeset EntityOutput
{
	function void (const char[] output, int caller, int activator, float delay);
	function Action (const char[] output, int caller, int activator, float delay);
};

/**
 * Add an entity output hook on a entity classname
 *
 * @param classname     The classname to hook.
 * @param output        The output name to hook.
 * @param callback      An EntityOutput function pointer.
 * @error               Entity Outputs disabled.
 */
native void HookEntityOutput(const char[] classname, const char[] output, EntityOutput callback);

/**
 * Remove an entity output hook.
 * @param classname     The classname to hook.
 * @param output        The output name to hook.
 * @param callback      An EntityOutput function pointer.
 * @return              True on success, false if no valid hook was found.
 * @error               Entity Outputs disabled.
 */
native bool UnhookEntityOutput(const char[] classname, const char[] output, EntityOutput callback);

/**
 * Add an entity output hook on a single entity instance
 *
 * @param entity        The entity on which to add a hook.
 * @param output        The output name to hook.
 * @param callback      An EntityOutput function pointer.
 * @param once          Only fire this hook once and then remove itself.
 * @error               Entity Outputs disabled or Invalid Entity index.
 */
native void HookSingleEntityOutput(int entity, const char[] output, EntityOutput callback, bool once=false);

/**
 * Remove a single entity output hook.
 *
 * @param entity        The entity on which to remove the hook.
 * @param output        The output name to hook.
 * @param callback      An EntityOutput function pointer.
 * @return              True on success, false if no valid hook was found.
 * @error               Entity Outputs disabled or Invalid Entity index.
 */
native bool UnhookSingleEntityOutput(int entity, const char[] output, EntityOutput callback);

/**
 * Fire a named output on an entity.
 *
 * After completion (successful or not), the current global variant is re-initialized.
 *
 * @param caller        Entity index from where the output is fired.
 * @param output        Output name.
 * @param activator     Entity index which initiated the sequence of actions (-1 for a NULL entity).
 * @param delay         Delay before firing the output.
 * @error               Invalid entity index or no mod support.
 */
native void FireEntityOutput(int caller, const char[] output, int activator=-1, float delay=0.0);
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2011 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _entity_included
 #endinput
#endif
#define _entity_included

/**
 * Property types for entities.
 */
enum PropType
{
	Prop_Send = 0,  /**< This property is networked. */
	Prop_Data = 1   /**< This property is for save game data fields. */
};

/**
 * @section For more information on these, see the HL2SDK (public/edict.h)
 */
#define FL_EDICT_CHANGED                (1<<0)  /**< Game DLL sets this when the entity state changes
                                                     Mutually exclusive with FL_EDICT_PARTIAL_CHANGE. */
#define FL_EDICT_FREE                   (1<<1)  /**< this edict if free for reuse */
#define FL_EDICT_FULL                   (1<<2)  /**< this is a full server entity */
#define FL_EDICT_FULLCHECK              (0<<0)  /**< call ShouldTransmit() each time, this is a fake flag */
#define FL_EDICT_ALWAYS                 (1<<3)  /**< always transmit this entity */
#define FL_EDICT_DONTSEND               (1<<4)  /**< don't transmit this entity */
#define FL_EDICT_PVSCHECK               (1<<5)  /**< always transmit entity, but cull against PVS */
#define FL_EDICT_PENDING_DORMANT_CHECK  (1<<6)
#define FL_EDICT_DIRTY_PVS_INFORMATION  (1<<7)
#define FL_FULL_EDICT_CHANGED           (1<<8)

enum PropFieldType
{
	PropField_Unsupported,      /**< The type is unsupported. */
	PropField_Integer,          /**< Valid for SendProp and Data fields */
	PropField_Float,            /**< Valid for SendProp and Data fields */
	PropField_Entity,           /**< Valid for Data fields only (SendProp shows as int) */
	PropField_Vector,           /**< Valid for SendProp and Data fields */
	PropField_String,           /**< Valid for SendProp and Data fields */
	PropField_String_T,         /**< Valid for Data fields.  Read only.
	                                 Note that the size of a string_t is dynamic, and
	                                 thus FindDataMapOffs() will return the constant size
	                                 of the string_t container (which is 32 bits right now). */
	PropField_Variant           /**< Valid for Data fields only Type is not known at the field level,
                                     (for this call), but dependent on current field value. */
};

/**
 * @endsection
 */

/**
 * Returns the maximum number of networked entities.
 *
 * Note: For legacy reasons, this only returns the maximum
 * networked entities (maximum edicts), rather than total
 * maximum entities.
 *
 * @return              Maximum number of networked entities.
 */
native int GetMaxEntities();

/**
 * Returns the number of networked entities in the server.
 *
 * Note: For legacy reasons, this only returns the current count
 * of networked entities (current edicts), rather than total
 * count of current entities.
 *
 * @return              Number of entities in the server.
 */
native int GetEntityCount();

/**
 * Returns whether or not an entity is valid.  Returns false
 * if there is no matching CBaseEntity for this entity index.
 *
 * @param entity        Index of the entity.
 * @return              True if valid, false otherwise.
 */
native bool IsValidEntity(int entity);

/**
 * Returns whether or not an edict index is valid.
 *
 * @param edict         Index of the edict.
 * @return              True if valid, false otherwise.
 */
native bool IsValidEdict(int edict);

/**
 * Returns whether or not an entity has a valid networkable edict.
 *
 * @param entity        Index of the entity.
 * @return              True if networkable, false if invalid or not networkable.
 */
native bool IsEntNetworkable(int entity);

/**
 * Creates a new edict (the basis of a networkable entity)
 *
 * @return              Index of the edict, 0 on failure.
 */
native int CreateEdict();

/**
 * Removes an edict from the world.
 *
 * @param edict         Index of the edict.
 * @error               Invalid edict index.
 */
native void RemoveEdict(int edict);

/**
 * Marks an entity for deletion.
 *
 * @param entity        Index of the entity.
 * @error               Invalid entity index.
 */
native void RemoveEntity(int entity);

/**
 * Returns the flags on an edict.  These are not the same as entity flags.
 *
 * @param edict         Index of the entity.
 * @return              Edict flags.
 * @error               Invalid edict index.
 */
native int GetEdictFlags(int edict);

/**
 * Sets the flags on an edict.  These are not the same as entity flags.
 *
 * @param edict         Index of the entity.
 * @param flags         Flags to set.
 * @error               Invalid edict index.
 */
native void SetEdictFlags(int edict, int flags);

/**
 * Retrieves an edict classname.
 *
 * @param edict         Index of the entity.
 * @param clsname       Buffer to store the classname.
 * @param maxlength     Maximum length of the buffer.
 * @return              True on success, false if there is no classname set.
 */
native bool GetEdictClassname(int edict, char[] clsname, int maxlength);

/**
 * Retrieves an entity's networkable serverclass name.
 * This is not the same as the classname and is used for networkable state changes.
 *
 * @param edict         Index of the entity.
 * @param clsname       Buffer to store the serverclass name.
 * @param maxlength     Maximum length of the buffer.
 * @return              True on success, false if the edict is not networkable.
 * @error               Invalid edict index.
 */
native bool GetEntityNetClass(int edict, char[] clsname, int maxlength);

/**
 * @section Entity offset functions
 *
 * Offsets should be specified in byte distance from the CBaseEntity
 * structure, not short (double byte) or integer (four byte) multiples.
 * It is somewhat common practice to use offsets aligned to their final
 * type, and thus make sure you are not falling to this error in SourceMod.
 * For example, if your "integer-aligned" offset was 119, your byte-aligned
 * offset is 119*4, or 476.

 * Specifying incorrect offsets or the incorrect data type for an offset
 * can have fatal consequences.  If you are hardcoding offsets, and the
 * layout of CBaseEntity does not match, you can easily crash the server.
 *
 * The reasonable bounds for offsets is greater than or equal to 0 and
 * below 32768.  Offsets out of these bounds will throw an error.  However,
 * this does not represent any real range, it is simply a sanity check for
 * illegal values.  Any range outside of the CBaseEntity structure's private
 * size will cause undefined behavior or even crash.
 */

/**
 * Marks an entity as state changed.  This can be useful if you set an offset
 * and wish for it to be immediately changed over the network.  By default this
 * is not done for offset setting functions.
 *
 * @param edict         Index to the edict.
 * @param offset        Offset to mark as changed.  If 0,
 *                      the entire edict is marked as changed.
 * @error               Invalid entity or offset out of bounds.
 */
native void ChangeEdictState(int edict, int offset = 0);

/**
 * Peeks into an entity's object data and retrieves the integer value at
 * the given offset.
 *
 * @param entity        Edict index.
 * @param offset        Offset to use.
 * @param size          Number of bytes to read (valid values are 1, 2, or 4).
 * @return              Value at the given memory location.
 * @error               Invalid entity or offset out of reasonable bounds.
 */
native int GetEntData(int entity, int offset, int size=4);

/**
 * Peeks into an entity's object data and sets the integer value at
 * the given offset.
 *
 * @param entity        Edict index.
 * @param offset        Offset to use.
 * @param value         Value to set.
 * @param size          Number of bytes to write (valid values are 1, 2, or 4).
 * @param changeState   If true, change will be sent over the network.
 * @error               Invalid entity or offset out of reasonable bounds.
 */
native void SetEntData(int entity, int offset, any value, int size=4, bool changeState=false);

/**
 * Peeks into an entity's object data and retrieves the float value at
 * the given offset.
 *
 * @param entity        Edict index.
 * @param offset        Offset to use.
 * @return              Value at the given memory location.
 * @error               Invalid entity or offset out of reasonable bounds.
 */
native float GetEntDataFloat(int entity, int offset);

/**
 * Peeks into an entity's object data and sets the float value at
 * the given offset.
 *
 * @param entity        Edict index.
 * @param offset        Offset to use.
 * @param value         Value to set.
 * @param changeState   If true, change will be sent over the network.
 * @error               Invalid entity or offset out of reasonable bounds.
 */
native void SetEntDataFloat(int entity, int offset, float value, bool changeState=false);

/**
 * This function is deprecated.  Use GetEntDataEnt2 instead, for
 * reasons explained in the notes.
 *
 * Note: This function returns 0 on failure, which may be misleading,
 * as the number 0 is also used for the world entity index.
 *
 * Note: This function makes no attempt to validate the returned
 * entity, and in fact, it could be garbage or completely unexpected.
 *
 * @param entity        Edict index.
 * @param offset        Offset to use.
 * @return              Entity index at the given location, or 0 if none.
 * @error               Invalid entity or offset out of reasonable bounds.
 * @deprecated          Use GetEntDataEnt2() instead.
 */
#pragma deprecated Use GetEntDataEnt2() instead.
native int GetEntDataEnt(int entity, int offset);

/**
 * This function is deprecated.   Use SetEntDataEnt2 instead, for
 * reasons explained in the notes.
 *
 * Note: This function uses 0 as an indicator to unset data, but
 * 0 is also the world entity index.  Thus, a property cannot
 * be set to the world entity using this native.
 *
 * @param entity        Edict index.
 * @param offset        Offset to use.
 * @param other         Entity index to set, or 0 to clear.
 * @param changeState   If true, change will be sent over the network.
 * @error               Invalid entity or offset out of reasonable bounds.
 * @deprecated          Use SetEntDataEnt2() instead.
 */
#pragma deprecated Use SetEntDataEnt2() instead.
native void SetEntDataEnt(int entity, int offset, int other, bool changeState=false);

/**
 * Peeks into an entity's object data and retrieves the entity index
 * at the given offset.
 *
 * Note: This will only work on offsets that are stored as "entity
 * handles" (which usually looks like m_h* in properties).  These
 * are not SourceMod Handles, but internal Source structures.
 *
 * @param entity        Edict index.
 * @param offset        Offset to use.
 * @return              Entity index at the given location.  If there is no entity,
 *                      or the stored entity is invalid, then -1 is returned.
 * @error               Invalid input entity, or offset out of reasonable bounds.
 */
native int GetEntDataEnt2(int entity, int offset);

/**
 * Peeks into an entity's object data and sets the entity index at the
 * given offset.
 *
 * Note: This will only work on offsets that are stored as "entity
 * handles" (which usually looks like m_h* in properties).  These
 * are not SourceMod Handles, but internal Source structures.
 *
 * @param entity        Edict index.
 * @param offset        Offset to use.
 * @param other         Entity index to set, or -1 to clear.
 * @param changeState   If true, change will be sent over the network.
 * @error               Invalid input entity, or offset out of reasonable bounds.
 */
native void SetEntDataEnt2(int entity, int offset, int other, bool changeState=false);

/**
 * Peeks into an entity's object data and retrieves the vector at the
 * given offset.
 * @note Both a Vector and a QAngle are three floats.  This is a
 *       convenience function and will work with both types.
 *
 * @param entity        Edict index.
 * @param offset        Offset to use.
 * @param vec           Vector buffer to store data in.
 * @error               Invalid entity or offset out of reasonable bounds.
 */
native void GetEntDataVector(int entity, int offset, float vec[3]);

/**
 * Peeks into an entity's object data and sets the vector at the given
 * offset.
 * @note Both a Vector and a QAngle are three floats.  This is a
 *       convenience function and will work with both types.
 *
 * @param entity        Edict index.
 * @param offset        Offset to use.
 * @param vec           Vector to set.
 * @param changeState   If true, change will be sent over the network.
 * @error               Invalid entity or offset out of reasonable bounds.
 */
native void SetEntDataVector(int entity, int offset, const float vec[3], bool changeState=false);

/**
 * Peeks into an entity's object data and retrieves the string at
 * the given offset.
 *
 * @param entity        Edict index.
 * @param offset        Offset to use.
 * @param buffer        Destination string buffer.
 * @param maxlen        Maximum length of output string buffer.
 * @return              Number of non-null bytes written.
 * @error               Invalid entity or offset out of reasonable bounds.
 */
native int GetEntDataString(int entity, int offset, char[] buffer, int maxlen);

/**
 * Peeks into an entity's object data and sets the string at
 * the given offset.
 *
 * @param entity        Edict index.
 * @param offset        Offset to use.
 * @param buffer        String to set.
 * @param maxlen        Maximum length of bytes to write.
 * @param changeState   If true, change will be sent over the network.
 * @return              Number of non-null bytes written.
 * @error               Invalid entity or offset out of reasonable bounds.
 */
native int SetEntDataString(int entity, int offset, const char[] buffer, int maxlen, bool changeState=false);

/**
 * @endsection
 */

/**
 * Given a ServerClass name, finds a networkable send property offset.
 * This information is cached for future calls.
 *
 * Note, this function may return offsets that do not work!
 * If a property is nested beneath a parent object, the resulting offset
 * will be invalid for direct use with data functions.  Therefore, you
 * should use FindSendPropInfo() instead.  An example of such a property is
 * CTFPlayer::DT_LocalPlayer.m_nDisguiseClass on Team Fortress.
 *
 * @param cls           Classname.
 * @param prop          Property name.
 * @return              An offset, or -1 on failure.
 * @deprecated          Use FindSendPropInfo instead, or HasEntProp if you just want to check for existence.
 */
#pragma deprecated Use FindSendPropInfo instead, or HasEntProp if you just want to check for existence.
native int FindSendPropOffs(const char[] cls, const char[] prop);

/**
 * Given a ServerClass name, finds a networkable send property offset.
 * This information is cached for future calls.
 *
 * @param cls           Classname.
 * @param prop          Property name.
 * @param type          Optional parameter to store the type.
 * @param num_bits      Optional parameter to store the number of bits the field
 *                      uses, if applicable (otherwise 0 is stored).  The number
 *                      of bits varies for integers and floats, and is always 0
 *                      for strings.
 * @param local_offset  Optional parameter to store the local offset, as
 *                      FindSendPropOffs() would return.
 * @return              On success, returns an absolutely computed offset.
 *                      If no offset is available, 0 is returned.
 *                      If the property is not found, -1 is returned.
 */
native int FindSendPropInfo(const char[] cls,
						const char[] prop,
						PropFieldType &type=view_as<PropFieldType>(0),
						int &num_bits=0,
						int &local_offset=0);

/**
 * Given an entity, finds a datamap property offset.
 * This information is cached for future calls.
 *
 * @param entity        Entity index.
 * @param prop          Property name.
 * @param type          Optional parameter to store the type.
 * @param num_bits      Optional parameter to store the number of bits the field
 *                      uses.  The bit count will either be 1 (for boolean) or
 *                      divisible by 8 (including 0 if unknown).
 * @return              An offset, or -1 on failure.
 * @deprecated          Use FindDataMapInfo instead, or HasEntProp if you just want to check for existence.
 */
#pragma deprecated Use FindDataMapInfo instead, or HasEntProp if you just want to check for existence.
native int FindDataMapOffs(int entity,
					   const char[] prop,
					   PropFieldType &type=view_as<PropFieldType>(0),
					   int &num_bits=0);

/**
 * Given an entity, finds a nested datamap property offset.
 * This information is cached for future calls.
 *
 * @param entity        Entity index.
 * @param prop          Property name.
 * @param type          Optional parameter to store the type.
 * @param num_bits      Optional parameter to store the number of bits the field
 *                      uses.  The bit count will either be 1 (for boolean) or
 *                      divisible by 8 (including 0 if unknown).
 * @param local_offset  Optional parameter to store the local offset, as
 *                      FindDataMapOffs() would return.
 * @return              An offset, or -1 on failure.
 */
native int FindDataMapInfo(int entity,
					   const char[] prop,
					   PropFieldType &type=view_as<PropFieldType>(0),
					   int &num_bits=0,
					   int &local_offset=0);

/**
 * Wrapper function for finding a send property for a particular entity.
 *
 * @param ent           Entity index.
 * @param prop          Property name.
 * @param actual        Defaults to false for backwards compatibility.
 *                      If true, the newer FindSendPropInfo() function
 *                      is used instead.
 * @return              An offset, or -1 on failure.
 */
stock int GetEntSendPropOffs(int ent, const char[] prop, bool actual=false)
{
	char cls[64];

	if (!GetEntityNetClass(ent, cls, sizeof(cls)))
	{
		return -1;
	}

	int local = -1;
	int offset = FindSendPropInfo(cls, prop, _, _, local);

	if (actual)
	{
		return offset;
	}

	return local;
}

/**
 * Checks if an entity property exists on an entity.
 *
 * @param entity        Entity/edict index.
 * @param type          Property type.
 * @param prop          Property name.
 * @return              Whether the property exists on the entity.
 * @error               Invalid entity.
 */
stock bool HasEntProp(int entity, PropType type, const char[] prop)
{
	if (type == Prop_Data)
	{
		return (FindDataMapInfo(entity, prop) != -1);
	}

	if (type != Prop_Send)
	{
		return false;
	}

	char cls[64];
	if (!GetEntityNetClass(entity, cls, sizeof(cls)))
	{
		return false;
	}

	return (FindSendPropInfo(cls, prop) != -1);
}

/**
 * Retrieves an integer value from an entity's property.
 *
 * This function is considered safer and more robust over GetEntData,
 * because it performs strict offset checking and typing rules.
 *
 * @param entity        Entity/edict index.
 * @param type          Property type.
 * @param prop          Property name.
 * @param size          Number of bytes to write (valid values are 1, 2, or 4).
 *                      This value is auto-detected, and the size parameter is
 *                      only used as a fallback in case detection fails.
 * @param element       Element # (starting from 0) if property is an array.
 * @return              Value at the given property offset.
 * @error               Invalid entity or property not found.
 */
native int GetEntProp(int entity, PropType type, const char[] prop, int size=4, int element=0);

/**
 * Sets an integer value in an entity's property.
 *
 * This function is considered safer and more robust over SetEntData,
 * because it performs strict offset checking and typing rules.
 *
 * @param entity        Entity/edict index.
 * @param type          Property type.
 * @param prop          Property name.
 * @param value         Value to set.
 * @param size          Number of bytes to write (valid values are 1, 2, or 4).
 *                      This value is auto-detected, and the size parameter is
 *                      only used as a fallback in case detection fails.
 * @param element       Element # (starting from 0) if property is an array.
 * @error               Invalid entity or offset out of reasonable bounds.
 */
native void SetEntProp(int entity, PropType type, const char[] prop, any value, int size=4, int element=0);

/**
 * Retrieves a float value from an entity's property.
 *
 * This function is considered safer and more robust over GetEntDataFloat,
 * because it performs strict offset checking and typing rules.
 *
 * @param entity        Entity/edict index.
 * @param type          Property type.
 * @param prop          Property name.
 * @param element       Element # (starting from 0) if property is an array.
 * @return              Value at the given property offset.
 * @error               Invalid entity or offset out of reasonable bounds.
 */
native float GetEntPropFloat(int entity, PropType type, const char[] prop, int element=0);

/**
 * Sets a float value in an entity's property.
 *
 * This function is considered safer and more robust over SetEntDataFloat,
 * because it performs strict offset checking and typing rules.
 *
 * @param entity        Entity/edict index.
 * @param type          Property type.
 * @param prop          Property name.
 * @param value         Value to set.
 * @param element       Element # (starting from 0) if property is an array.
 * @error               Invalid entity or offset out of reasonable bounds.
 */
native void SetEntPropFloat(int entity, PropType type, const char[] prop, float value, int element=0);

/**
 * Retrieves an entity index from an entity's property.
 *
 * This function is considered safer and more robust over GetEntDataEnt*,
 * because it performs strict offset checking and typing rules.
 *
 * @param entity        Entity/edict index.
 * @param type          Property type.
 * @param prop          Property name.
 * @param element       Element # (starting from 0) if property is an array.
 * @return              Entity index at the given property.
 *                      If there is no entity, or the entity is not valid,
 *                      then -1 is returned.
 * @error               Invalid entity or offset out of reasonable bounds.
 */
native int GetEntPropEnt(int entity, PropType type, const char[] prop, int element=0);

/**
 * Sets an entity index in an entity's property.
 *
 * This function is considered safer and more robust over SetEntDataEnt*,
 * because it performs strict offset checking and typing rules.
 *
 * @param entity        Entity/edict index.
 * @param type          Property type.
 * @param prop          Property name.
 * @param other         Entity index to set, or -1 to unset.
 * @param element       Element # (starting from 0) if property is an array.
 * @error               Invalid entity or offset out of reasonable bounds.
 */
native void SetEntPropEnt(int entity, PropType type, const char[] prop, int other, int element=0);

/**
 * Retrieves a vector of floats from an entity, given a named network property.
 *
 * This function is considered safer and more robust over GetEntDataVector,
 * because it performs strict offset checking and typing rules.
 *
 * @param entity        Entity/edict index.
 * @param type          Property type.
 * @param prop          Property name.
 * @param vec           Vector buffer to store data in.
 * @param element       Element # (starting from 0) if property is an array.
 * @error               Invalid entity, property not found, or property not
 *                      actually a vector data type.
 */
native void GetEntPropVector(int entity, PropType type, const char[] prop, float vec[3], int element=0);

/**
 * Sets a vector of floats in an entity, given a named network property.
 *
 * This function is considered safer and more robust over SetEntDataVector,
 * because it performs strict offset checking and typing rules.
 *
 * @param entity        Entity/edict index.
 * @param type          Property type.
 * @param prop          Property name.
 * @param vec           Vector to set.
 * @param element       Element # (starting from 0) if property is an array.
 * @error               Invalid entity, property not found, or property not
 *                      actually a vector data type.
 */
native void SetEntPropVector(int entity, PropType type, const char[] prop, const float vec[3], int element=0);

/**
 * Gets a network property as a string.
 *
 * @param entity        Edict index.
 * @param type          Property type.
 * @param prop          Property to use.
 * @param buffer        Destination string buffer.
 * @param maxlen        Maximum length of output string buffer.
 * @param element       Element # (starting from 0) if property is an array.
 * @return              Number of non-null bytes written.
 * @error               Invalid entity, offset out of reasonable bounds, or property is not a valid string.
 */
native int GetEntPropString(int entity, PropType type, const char[] prop, char[] buffer, int maxlen, int element=0);

/**
 * Sets a network property as a string.
 *
 * @param entity        Edict index.
 * @param type          Property type.
 * @param prop          Property to use.
 * @param buffer        String to set.
 * @param element       Element # (starting from 0) if property is an array.
 * @return              Number of non-null bytes written.
 * @error               Invalid entity, offset out of reasonable bounds, or property is not a valid string.
 */
native int SetEntPropString(int entity, PropType type, const char[] prop, const char[] buffer, int element=0);

/**
 * Retrieves the count of values that an entity property's array can store.
 *
 * @param entity        Entity/edict index.
 * @param type          Property type.
 * @param prop          Property name.
 * @return              Size of array (in elements) or 1 if property is not an array.
 * @error               Invalid entity or property not found.
 */
native int GetEntPropArraySize(int entity, PropType type, const char[] prop);

/**
 * Copies an array of cells from an entity at a given offset.
 *
 * @param entity        Entity index.
 * @param offset        Offset to use.
 * @param array         Array to read into.
 * @param arraySize     Number of values to read.
 * @param dataSize      Size of each value in bytes (1, 2, or 4).
 * @error               Invalid entity or offset out of reasonable bounds.
 */
stock void GetEntDataArray(int entity, int offset, int[] array, int arraySize, int dataSize=4)
{
	for (int i = 0; i < arraySize; i++)
	{
		array[i] = GetEntData(entity, offset + i*dataSize, dataSize);
	}
}

/**
 * Copies an array of cells to an entity at a given offset.
 *
 * @param entity        Entity index.
 * @param offset        Offset to use.
 * @param array         Array of values to copy.
 * @param arraySize     Number of values to copy.
 * @param dataSize      Size of each value in bytes (1, 2, or 4).
 * @param changeState   True to set the network state as changed; false otherwise.
 * @error               Invalid entity or offset out of reasonable bounds.
 */
stock void SetEntDataArray(int entity, int offset, const int[] array, int arraySize, int dataSize=4, bool changeState=false)
{
	for (int i = 0; i < arraySize; i++)
	{
		SetEntData(entity, offset + i*dataSize, array[i], dataSize, changeState);
	}
}

/**
 * Gets the memory address of an entity.
 *
 * @param entity        Entity index.
 * @return              Address of the entity.
 * @error               Invalid entity.
 */
native Address GetEntityAddress(int entity);

/**
 * Retrieves the classname of an entity.
 * This is like GetEdictClassname(), except it works for ALL
 * entities, not just edicts.
 *
 * @param entity        Index of the entity.
 * @param clsname       Buffer to store the classname.
 * @param maxlength     Maximum length of the buffer.
 * @return              True on success, false if there is no classname set.
 */
stock bool GetEntityClassname(int entity, char[] clsname, int maxlength)
{
	return !!GetEntPropString(entity, Prop_Data, "m_iClassname", clsname, maxlength);
}
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _sdktools_voice_included
 #endinput
#endif
#define _sdktools_voice_included

/**
 * @section voice flags.
 */
#define VOICE_NORMAL        0   /**< Allow the client to listen and speak normally. */
#define VOICE_MUTED         1   /**< Mutes the client from speaking to everyone. */
#define VOICE_SPEAKALL      2   /**< Allow the client to speak to everyone. */
#define VOICE_LISTENALL     4   /**< Allow the client to listen to everyone. */
#define VOICE_TEAM          8   /**< Allow the client to always speak to team, even when dead. */
#define VOICE_LISTENTEAM    16  /**< Allow the client to always hear teammates, including dead ones. */

/**
 * @endsection
 */

enum ListenOverride
{
	Listen_Default = 0, /**< Leave it up to the game */
	Listen_No,          /**< Can't hear */
	Listen_Yes          /**< Can hear */
};

/**
 * Set the client listening flags.
 *
 * @param client        The client index
 * @param flags         The voice flags
 */
native void SetClientListeningFlags(int client, int flags);

/**
 * Retrieve the client current listening flags.
 *
 * @param client        The client index
 * @return              The current voice flags
 */
native int GetClientListeningFlags(int client);

/**
 * Set the receiver ability to listen to the sender.
 *
 * @param iReceiver     The listener index.
 * @param iSender       The sender index.
 * @param bListen       True if the receiver can listen to the sender, false otherwise.
 * @return              True if successful otherwise false.
 * @deprecated          Use SetListenOverride() instead.
 */
#pragma deprecated Use SetListenOverride() instead
native bool SetClientListening(int iReceiver, int iSender, bool bListen);

/**
 * Retrieves if the receiver can listen to the sender.
 *
 * @param iReceiver     The listener index.
 * @param iSender       The sender index.
 * @return              True if successful otherwise false.
 * @deprecated          GetListenOverride() instead.
 */
#pragma deprecated GetListenOverride() instead
native bool GetClientListening(int iReceiver, int iSender);

/**
 * Override the receiver's ability to listen to the sender.
 *
 * @param iReceiver     The listener index.
 * @param iSender       The sender index.
 * @param override      The override of the receiver's ability to listen to the sender.
 * @return              True if successful otherwise false.
 */
native bool SetListenOverride(int iReceiver, int iSender, ListenOverride override);

/**
 * Retrieves the override of the receiver's ability to listen to the sender.
 *
 * @param iReceiver     The listener index.
 * @param iSender       The sender index.
 * @return              The override value.
 */
native ListenOverride GetListenOverride(int iReceiver, int iSender);

/**
 * Retrieves if the muter has muted the mutee.
 *
 * @param iMuter        The muter index.
 * @param iMutee        The mutee index.
 * @return              True if muter has muted mutee, false otherwise.
 */
native bool IsClientMuted(int iMuter, int iMutee);
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _tf2_stocks_included
 #endinput
#endif
#define _tf2_stocks_included

#include <tf2>
#include <sdktools>

#define TF_CONDFLAG_NONE            0
#define TF_CONDFLAG_SLOWED          (1 << 0)
#define TF_CONDFLAG_ZOOMED          (1 << 1)
#define TF_CONDFLAG_DISGUISING      (1 << 2)
#define TF_CONDFLAG_DISGUISED       (1 << 3)
#define TF_CONDFLAG_CLOAKED         (1 << 4)
#define TF_CONDFLAG_UBERCHARGED     (1 << 5)
#define TF_CONDFLAG_TELEPORTGLOW    (1 << 6)
#define TF_CONDFLAG_TAUNTING        (1 << 7)
#define TF_CONDFLAG_UBERCHARGEFADE  (1 << 8)
#define TF_CONDFLAG_CLOAKFLICKER    (1 << 9)
#define TF_CONDFLAG_TELEPORTING     (1 << 10)
#define TF_CONDFLAG_KRITZKRIEGED    (1 << 11)
#define TF_CONDFLAG_DEADRINGERED    (1 << 13)
#define TF_CONDFLAG_BONKED          (1 << 14)
#define TF_CONDFLAG_DAZED           (1 << 15)
#define TF_CONDFLAG_BUFFED          (1 << 16)
#define TF_CONDFLAG_CHARGING        (1 << 17)
#define TF_CONDFLAG_DEMOBUFF        (1 << 18)
#define TF_CONDFLAG_CRITCOLA        (1 << 19)
#define TF_CONDFLAG_INHEALRADIUS    (1 << 20)
#define TF_CONDFLAG_HEALING         (1 << 21)
#define TF_CONDFLAG_ONFIRE          (1 << 22)
#define TF_CONDFLAG_OVERHEALED      (1 << 23)
#define TF_CONDFLAG_JARATED         (1 << 24)
#define TF_CONDFLAG_BLEEDING        (1 << 25)
#define TF_CONDFLAG_DEFENSEBUFFED   (1 << 26)
#define TF_CONDFLAG_MILKED          (1 << 27)
#define TF_CONDFLAG_MEGAHEAL        (1 << 28)
#define TF_CONDFLAG_REGENBUFFED     (1 << 29)
#define TF_CONDFLAG_MARKEDFORDEATH  (1 << 30)

#define TF_DEATHFLAG_KILLERDOMINATION   (1 << 0)
#define TF_DEATHFLAG_ASSISTERDOMINATION (1 << 1)
#define TF_DEATHFLAG_KILLERREVENGE      (1 << 2)
#define TF_DEATHFLAG_ASSISTERREVENGE    (1 << 3)
#define TF_DEATHFLAG_FIRSTBLOOD         (1 << 4)
#define TF_DEATHFLAG_DEADRINGER         (1 << 5)
#define TF_DEATHFLAG_INTERRUPTED        (1 << 6)
#define TF_DEATHFLAG_GIBBED             (1 << 7)
#define TF_DEATHFLAG_PURGATORY          (1 << 8)
#define TF_DEATHFLAG_MINIBOSS           (1 << 9)
#define TF_DEATHFLAG_AUSTRALIUM         (1 << 10)

// Custom kill identifiers for the customkill property on the player_death event
enum {
	TF_CUSTOM_HEADSHOT = 1,
	TF_CUSTOM_BACKSTAB,
	TF_CUSTOM_BURNING,
	TF_CUSTOM_WRENCH_FIX,
	TF_CUSTOM_MINIGUN,
	TF_CUSTOM_SUICIDE,
	TF_CUSTOM_TAUNT_HADOUKEN,
	TF_CUSTOM_BURNING_FLARE,
	TF_CUSTOM_TAUNT_HIGH_NOON,
	TF_CUSTOM_TAUNT_GRAND_SLAM,
	TF_CUSTOM_PENETRATE_MY_TEAM,
	TF_CUSTOM_PENETRATE_ALL_PLAYERS,
	TF_CUSTOM_TAUNT_FENCING,
	TF_CUSTOM_PENETRATE_HEADSHOT,
	TF_CUSTOM_TAUNT_ARROW_STAB,
	TF_CUSTOM_TELEFRAG,
	TF_CUSTOM_BURNING_ARROW,
	TF_CUSTOM_FLYINGBURN,
	TF_CUSTOM_PUMPKIN_BOMB,
	TF_CUSTOM_DECAPITATION,
	TF_CUSTOM_TAUNT_GRENADE,
	TF_CUSTOM_BASEBALL,
	TF_CUSTOM_CHARGE_IMPACT,
	TF_CUSTOM_TAUNT_BARBARIAN_SWING,
	TF_CUSTOM_AIR_STICKY_BURST,
	TF_CUSTOM_DEFENSIVE_STICKY,
	TF_CUSTOM_PICKAXE,
	TF_CUSTOM_ROCKET_DIRECTHIT,
	TF_CUSTOM_TAUNT_UBERSLICE,
	TF_CUSTOM_PLAYER_SENTRY,
	TF_CUSTOM_STANDARD_STICKY,
	TF_CUSTOM_SHOTGUN_REVENGE_CRIT,
	TF_CUSTOM_TAUNT_ENGINEER_SMASH,
	TF_CUSTOM_BLEEDING,
	TF_CUSTOM_GOLD_WRENCH,
	TF_CUSTOM_CARRIED_BUILDING,
	TF_CUSTOM_COMBO_PUNCH,
	TF_CUSTOM_TAUNT_ENGINEER_ARM,
	TF_CUSTOM_FISH_KILL,
	TF_CUSTOM_TRIGGER_HURT,
	TF_CUSTOM_DECAPITATION_BOSS,
	TF_CUSTOM_STICKBOMB_EXPLOSION,
	TF_CUSTOM_AEGIS_ROUND,
	TF_CUSTOM_FLARE_EXPLOSION,
	TF_CUSTOM_BOOTS_STOMP,
	TF_CUSTOM_PLASMA,
	TF_CUSTOM_PLASMA_CHARGED,
	TF_CUSTOM_PLASMA_GIB,
	TF_CUSTOM_PRACTICE_STICKY,
	TF_CUSTOM_EYEBALL_ROCKET,
	TF_CUSTOM_HEADSHOT_DECAPITATION,
	TF_CUSTOM_TAUNT_ARMAGEDDON,
	TF_CUSTOM_FLARE_PELLET,
	TF_CUSTOM_CLEAVER,
	TF_CUSTOM_CLEAVER_CRIT,
	TF_CUSTOM_SAPPER_RECORDER_DEATH,
	TF_CUSTOM_MERASMUS_PLAYER_BOMB,
	TF_CUSTOM_MERASMUS_GRENADE,
	TF_CUSTOM_MERASMUS_ZAP,
	TF_CUSTOM_MERASMUS_DECAPITATION,
	TF_CUSTOM_CANNONBALL_PUSH,
	TF_CUSTOM_TAUNT_ALLCLASS_GUITAR_RIFF,
	TF_CUSTOM_THROWABLE,
	TF_CUSTOM_THROWABLE_KILL,
	TF_CUSTOM_SPELL_TELEPORT,
	TF_CUSTOM_SPELL_SKELETON,
	TF_CUSTOM_SPELL_MIRV,
	TF_CUSTOM_SPELL_METEOR,
	TF_CUSTOM_SPELL_LIGHTNING,
	TF_CUSTOM_SPELL_FIREBALL,
	TF_CUSTOM_SPELL_MONOCULUS,
	TF_CUSTOM_SPELL_BLASTJUMP,
	TF_CUSTOM_SPELL_BATS,
	TF_CUSTOM_SPELL_TINY,
	TF_CUSTOM_KART,
	TF_CUSTOM_GIANT_HAMMER,
	TF_CUSTOM_RUNE_REFLECT,
	TF_CUSTOM_DRAGONS_FURY_IGNITE,
	TF_CUSTOM_DRAGONS_FURY_BONUS_BURNING,
	TF_CUSTOM_SLAP_KILL,
	TF_CUSTOM_CROC,
	TF_CUSTOM_TAUNTATK_GASBLAST,
	TF_CUSTOM_AXTINGUISHER_BOOSTED
};

// Weapon codes as used in some events, such as player_death
// (not to be confused with Item Definition Indexes)
enum {
	TF_WEAPON_NONE = 0,
	TF_WEAPON_BAT,
	TF_WEAPON_BAT_WOOD,
	TF_WEAPON_BOTTLE,
	TF_WEAPON_FIREAXE,
	TF_WEAPON_CLUB,
	TF_WEAPON_CROWBAR,
	TF_WEAPON_KNIFE,
	TF_WEAPON_FISTS,
	TF_WEAPON_SHOVEL,
	TF_WEAPON_WRENCH,
	TF_WEAPON_BONESAW,
	TF_WEAPON_SHOTGUN_PRIMARY,
	TF_WEAPON_SHOTGUN_SOLDIER,
	TF_WEAPON_SHOTGUN_HWG,
	TF_WEAPON_SHOTGUN_PYRO,
	TF_WEAPON_SCATTERGUN,
	TF_WEAPON_SNIPERRIFLE,
	TF_WEAPON_MINIGUN,
	TF_WEAPON_SMG,
	TF_WEAPON_SYRINGEGUN_MEDIC,
	TF_WEAPON_TRANQ,
	TF_WEAPON_ROCKETLAUNCHER,
	TF_WEAPON_GRENADELAUNCHER,
	TF_WEAPON_PIPEBOMBLAUNCHER,
	TF_WEAPON_FLAMETHROWER,
	TF_WEAPON_GRENADE_NORMAL,
	TF_WEAPON_GRENADE_CONCUSSION,
	TF_WEAPON_GRENADE_NAIL,
	TF_WEAPON_GRENADE_MIRV,
	TF_WEAPON_GRENADE_MIRV_DEMOMAN,
	TF_WEAPON_GRENADE_NAPALM,
	TF_WEAPON_GRENADE_GAS,
	TF_WEAPON_GRENADE_EMP,
	TF_WEAPON_GRENADE_CALTROP,
	TF_WEAPON_GRENADE_PIPEBOMB,
	TF_WEAPON_GRENADE_SMOKE_BOMB,
	TF_WEAPON_GRENADE_HEAL,
	TF_WEAPON_GRENADE_STUNBALL,
	TF_WEAPON_GRENADE_JAR,
	TF_WEAPON_GRENADE_JAR_MILK,
	TF_WEAPON_PISTOL,
	TF_WEAPON_PISTOL_SCOUT,
	TF_WEAPON_REVOLVER,
	TF_WEAPON_NAILGUN,
	TF_WEAPON_PDA,
	TF_WEAPON_PDA_ENGINEER_BUILD,
	TF_WEAPON_PDA_ENGINEER_DESTROY,
	TF_WEAPON_PDA_SPY,
	TF_WEAPON_BUILDER,
	TF_WEAPON_MEDIGUN,
	TF_WEAPON_GRENADE_MIRVBOMB,
	TF_WEAPON_FLAMETHROWER_ROCKET,
	TF_WEAPON_GRENADE_DEMOMAN,
	TF_WEAPON_SENTRY_BULLET,
	TF_WEAPON_SENTRY_ROCKET,
	TF_WEAPON_DISPENSER,
	TF_WEAPON_INVIS,
	TF_WEAPON_FLAREGUN,
	TF_WEAPON_LUNCHBOX,
	TF_WEAPON_JAR,
	TF_WEAPON_COMPOUND_BOW,
	TF_WEAPON_BUFF_ITEM,
	TF_WEAPON_PUMPKIN_BOMB,
	TF_WEAPON_SWORD,
	TF_WEAPON_DIRECTHIT,
	TF_WEAPON_LIFELINE,
	TF_WEAPON_LASER_POINTER,
	TF_WEAPON_DISPENSER_GUN,
	TF_WEAPON_SENTRY_REVENGE,
	TF_WEAPON_JAR_MILK,
	TF_WEAPON_HANDGUN_SCOUT_PRIMARY,
	TF_WEAPON_BAT_FISH,
	TF_WEAPON_CROSSBOW,
	TF_WEAPON_STICKBOMB,
	TF_WEAPON_HANDGUN_SCOUT_SEC,
	TF_WEAPON_SODA_POPPER,
	TF_WEAPON_SNIPERRIFLE_DECAP,
	TF_WEAPON_RAYGUN,
	TF_WEAPON_PARTICLE_CANNON,
	TF_WEAPON_MECHANICAL_ARM,
	TF_WEAPON_DRG_POMSON,
	TF_WEAPON_BAT_GIFTWRAP,
	TF_WEAPON_GRENADE_ORNAMENT,
	TF_WEAPON_RAYGUN_REVENGE,
	TF_WEAPON_PEP_BRAWLER_BLASTER,
	TF_WEAPON_CLEAVER,
	TF_WEAPON_GRENADE_CLEAVER,
	TF_WEAPON_STICKY_BALL_LAUNCHER,
	TF_WEAPON_GRENADE_STICKY_BALL,
	TF_WEAPON_SHOTGUN_BUILDING_RESCUE,
	TF_WEAPON_CANNON,
	TF_WEAPON_THROWABLE,
	TF_WEAPON_GRENADE_THROWABLE,
	TF_WEAPON_PDA_SPY_BUILD,
	TF_WEAPON_GRENADE_WATERBALLOON,
	TF_WEAPON_HARVESTER_SAW,
	TF_WEAPON_SPELLBOOK,
	TF_WEAPON_SPELLBOOK_PROJECTILE,
	TF_WEAPON_SNIPERRIFLE_CLASSIC,
	TF_WEAPON_PARACHUTE,
	TF_WEAPON_GRAPPLINGHOOK,
	TF_WEAPON_PASSTIME_GUN,
	TF_WEAPON_CHARGED_SMG,
	TF_WEAPON_BREAKABLE_SIGN,
	TF_WEAPON_ROCKETPACK,
	TF_WEAPON_SLAP,
	TF_WEAPON_JAR_GAS,
	TF_WEAPON_GRENADE_JAR_GAS,
	TF_WEAPON_FLAME_BALL
};

// TF2 Weapon Loadout Slots
enum
{
	TFWeaponSlot_Primary,
	TFWeaponSlot_Secondary,
	TFWeaponSlot_Melee,
	TFWeaponSlot_Grenade,
	TFWeaponSlot_Building,
	TFWeaponSlot_PDA,
	TFWeaponSlot_Item1,
	TFWeaponSlot_Item2
};

// Identifiers for the eventtype property on the teamplay_flag_event event
enum {
	TF_FLAGEVENT_PICKEDUP = 1,
	TF_FLAGEVENT_CAPTURED,
	TF_FLAGEVENT_DEFENDED,
	TF_FLAGEVENT_DROPPED,
	TF_FLAGEVENT_RETURNED
};

enum TFResourceType
{
	TFResource_Ping,
	TFResource_Score,
	TFResource_Deaths,
	TFResource_TotalScore,
	TFResource_Captures,
	TFResource_Defenses,
	TFResource_Dominations,
	TFResource_Revenge,
	TFResource_BuildingsDestroyed,
	TFResource_Headshots,
	TFResource_Backstabs,
	TFResource_HealPoints,
	TFResource_Invulns,
	TFResource_Teleports,
	TFResource_ResupplyPoints,
	TFResource_KillAssists,
	TFResource_MaxHealth,
	TFResource_PlayerClass
};

static const char TFResourceNames[TFResourceType][] =
{
	"m_iPing",
	"m_iScore",
	"m_iDeaths",
	"m_iTotalScore",
	"m_iCaptures",
	"m_iDefenses",
	"m_iDominations",
	"m_iRevenge",
	"m_iBuildingsDestroyed",
	"m_iHeadshots",
	"m_iBackstabs",
	"m_iHealPoints",
	"m_iInvulns",
	"m_iTeleports",
	"m_iResupplyPoints",
	"m_iKillAssists",
	"m_iMaxHealth",
	"m_iPlayerClass"
};

/**
 * Gets a client's current team.
 *
 * @param client        Client index.
 * @return              Current TFTeam of client.
 * @error               Invalid client index.
 */
stock TFTeam TF2_GetClientTeam(int client)
{
	return view_as<TFTeam>(GetClientTeam(client));
}

/**
 * Changes a client's current team.
 *
 * @param client        Client index.
 * @param team          TFTeam team symbol.
 * @error               Invalid client index.
 */
stock void TF2_ChangeClientTeam(int client, TFTeam team)
{
    ChangeClientTeam(client, view_as<int>(team));
}

/**
 * Gets a client's current class.
 *
 * @param client        Player's index.
 * @return              Current TFClassType of player.
 * @error               Invalid client index.
 */
stock TFClassType TF2_GetPlayerClass(int client)
{
	return view_as<TFClassType>(GetEntProp(client, Prop_Send, "m_iClass"));
}

/**
 * Sets a client's class.
 *
 * Note: If setting player class in a player spawn hook weapons should be set to false.
 *
 * @param client        Player's index.
 * @param classType     TFClassType class symbol.
 * @param weapons       This parameter is ignored.
 * @param persistent    If true, changes the player's desired class so the change stays after death.
 * @error               Invalid client index.
 */
stock void TF2_SetPlayerClass(int client, TFClassType classType, bool weapons=true, bool persistent=true)
{
	SetEntProp(client, Prop_Send, "m_iClass", view_as<int>(classType));

	if (persistent)
	{
		SetEntProp(client, Prop_Send, "m_iDesiredPlayerClass", view_as<int>(classType));
	}
}

/**
 * Retrieves client data from the resource entity
 *
 * @param client		Player's index.
 * @param type			ResourceType constant
 * @return				Value or -1 on failure.
 * @error				Invalid client index, client not in game or failed to find resource entity.
 * @deprecated          Use GetPlayerResourceEntity and GetEntProp instead.
 */
#pragma deprecated Use GetPlayerResourceEntity and GetEntProp instead
stock int TF2_GetPlayerResourceData(int client, TFResourceType type)
{
	if (!IsClientConnected(client))
	{
		return -1;
	}

	int offset = FindSendPropInfo("CTFPlayerResource", TFResourceNames[type]);

	if (offset < 1)
	{
		return -1;
	}

	int entity = TF2_GetResourceEntity();

	if (entity == -1)
	{
		return -1;
	}

	return GetEntData(entity, offset + (client*4));
}

/**
 * Sets client data in the resource entity
 *
 * Note: The game overwrites these values every frame, so changing them will have very little effect.
 *
 * @param client        Player's index.
 * @param type          ResourceType constant
 * @param value         Value to set.
 * @return              Value or -1 on failure.
 * @error               Invalid client index, client not in game or failed to find resource entity.
 * @deprecated          Use GetPlayerResourceEntity and SetEntProp instead.
 */
#pragma deprecated Use GetPlayerResourceEntity and SetEntProp instead
stock bool TF2_SetPlayerResourceData(int client, TFResourceType type, any value)
{
	if (!IsClientConnected(client))
	{
		return false;
	}

	int offset = FindSendPropInfo("CTFPlayerResource", TFResourceNames[type]);

	if (offset < 1)
	{
		return false;
	}

	int entity = TF2_GetResourceEntity();

	if (entity == -1)
	{
		return false;
	}

	SetEntData(entity, offset + (client*4), value);

	return true;
}

/**
 * Removes all weapons from a client's weapon slot
 *
 * @param client        Player's index.
 * @param slot          Slot index (0-5)
 * @error               Invalid client, invalid slot or lack of mod support
 */
stock void TF2_RemoveWeaponSlot(int client, int slot)
{
	int weaponIndex;
	while ((weaponIndex = GetPlayerWeaponSlot(client, slot)) != -1)
	{
		// bug #6206
		// papering over a valve bug where a weapon's extra wearables aren't properly removed from the weapon's owner
		int extraWearable = GetEntPropEnt(weaponIndex, Prop_Send, "m_hExtraWearable");
		if (extraWearable != -1)
		{
			TF2_RemoveWearable(client, extraWearable);
		}

		extraWearable = GetEntPropEnt(weaponIndex, Prop_Send, "m_hExtraWearableViewModel");
		if (extraWearable != -1)
		{
			TF2_RemoveWearable(client, extraWearable);
		}

		RemovePlayerItem(client, weaponIndex);
		AcceptEntityInput(weaponIndex, "Kill");
	}
}

/**
 * Removes all weapons from a client
 *
 * @param client        Player's index.
 */
stock void TF2_RemoveAllWeapons(int client)
{
	for (int i = 0; i <= 5; i++)
	{
		TF2_RemoveWeaponSlot(client, i);
	}
}

/**
 * Gets a player's condition bits
 *
 * @param client        Player's index.
 * @return              Player's condition bits
 * @deprecated          Use TF2_IsPlayerInCondition instead.
 */
#pragma deprecated Use TF2_IsPlayerInCondition instead.
stock int TF2_GetPlayerConditionFlags(int client)
{
	return GetEntProp(client, Prop_Send, "m_nPlayerCond")|GetEntProp(client, Prop_Send, "_condition_bits");
}

/**
 * Check whether or not a condition is set on a player
 *
 * @param client        Player's index.
 * @param cond          TFCond constant
 * @return              True if set, false otherwise
 */
stock bool TF2_IsPlayerInCondition(int client, TFCond cond)
{
	// Conditions are stored across multiple netprops now, one for each 32-bit segment.
	int iCond = view_as<int>(cond);
	switch (iCond / 32)
	{
		case 0:
		{
			int bit = 1 << iCond;
			if ((GetEntProp(client, Prop_Send, "m_nPlayerCond") & bit) == bit)
			{
				return true;
			}

			if ((GetEntProp(client, Prop_Send, "_condition_bits") & bit) == bit)
			{
				return true;
			}
		}
		case 1:
		{
			int bit = (1 << (iCond - 32));
			if ((GetEntProp(client, Prop_Send, "m_nPlayerCondEx") & bit) == bit)
			{
				return true;
			}
		}
		case 2:
		{
			int bit = (1 << (iCond - 64));
			if ((GetEntProp(client, Prop_Send, "m_nPlayerCondEx2") & bit) == bit)
			{
				return true;
			}
		}
		case 3:
		{
			int bit = (1 << (iCond - 96));
			if ((GetEntProp(client, Prop_Send, "m_nPlayerCondEx3") & bit) == bit)
			{
				return true;
			}
		}
		case 4:
		{
			int bit = (1 << (iCond - 128));
			if ((GetEntProp(client, Prop_Send, "m_nPlayerCondEx4") & bit) == bit)
			{
				return true;
			}
		}
		default:
		{
			ThrowError("Invalid TFCond value %d", iCond);
		}
	}

	return false;
}

/**
 * Gets an entity's object type.
 *
 * @param entity        Entity index.
 * @return              Current TFObjectType of entity.
 * @error               Invalid entity index.
 */
stock TFObjectType TF2_GetObjectType(int entity)
{
	int offset = GetEntSendPropOffs(entity, "m_iObjectType");

	if (offset <= 0)
	{
		ThrowError("Entity index %d is not an object", entity);
	}

	return view_as<TFObjectType>(GetEntData(entity, offset));
}

/**
 * Gets an entity's object mode.
 *
 * @param entity        Entity index.
 * @return              Current TFObjectMode of entity.
 * @error               Invalid entity index.
 */
stock TFObjectMode TF2_GetObjectMode(int entity)
{
	int offset = GetEntSendPropOffs(entity, "m_iObjectMode");

	if (offset <= 0)
	{
		ThrowError("Entity index %d is not an object", entity);
	}

	return view_as<TFObjectMode>(GetEntData(entity, offset));
}
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _entity_prop_stocks_included
 #endinput
#endif
#define _entity_prop_stocks_included

enum MoveType
{
	MOVETYPE_NONE = 0,          /**< never moves */
	MOVETYPE_ISOMETRIC,         /**< For players */
	MOVETYPE_WALK,              /**< Player only - moving on the ground */
	MOVETYPE_STEP,              /**< gravity, special edge handling -- monsters use this */
	MOVETYPE_FLY,               /**< No gravity, but still collides with stuff */
	MOVETYPE_FLYGRAVITY,        /**< flies through the air + is affected by gravity */
	MOVETYPE_VPHYSICS,          /**< uses VPHYSICS for simulation */
	MOVETYPE_PUSH,              /**< no clip to world, push and crush */
	MOVETYPE_NOCLIP,            /**< No gravity, no collisions, still do velocity/avelocity */
	MOVETYPE_LADDER,            /**< Used by players only when going onto a ladder */
	MOVETYPE_OBSERVER,          /**< Observer movement, depends on player's observer mode */
	MOVETYPE_CUSTOM             /**< Allows the entity to describe its own physics */
};

enum RenderMode
{
	RENDER_NORMAL,              /**< src */
	RENDER_TRANSCOLOR,          /**< c*a+dest*(1-a) */
	RENDER_TRANSTEXTURE,        /**< src*a+dest*(1-a) */
	RENDER_GLOW,                /**< src*a+dest -- No Z buffer checks -- Fixed size in screen space */
	RENDER_TRANSALPHA,          /**< src*srca+dest*(1-srca) */
	RENDER_TRANSADD,            /**< src*a+dest */
	RENDER_ENVIRONMENTAL,       /**< not drawn, used for environmental effects */
	RENDER_TRANSADDFRAMEBLEND,  /**< use a fractional frame value to blend between animation frames */
	RENDER_TRANSALPHAADD,       /**< src + dest*(1-a) */
	RENDER_WORLDGLOW,           /**< Same as kRenderGlow but not fixed size in screen space */
	RENDER_NONE                 /**< Don't render. */
};

enum RenderFx
{
	RENDERFX_NONE = 0,
	RENDERFX_PULSE_SLOW,
	RENDERFX_PULSE_FAST,
	RENDERFX_PULSE_SLOW_WIDE,
	RENDERFX_PULSE_FAST_WIDE,
	RENDERFX_FADE_SLOW,
	RENDERFX_FADE_FAST,
	RENDERFX_SOLID_SLOW,
	RENDERFX_SOLID_FAST,
	RENDERFX_STROBE_SLOW,
	RENDERFX_STROBE_FAST,
	RENDERFX_STROBE_FASTER,
	RENDERFX_FLICKER_SLOW,
	RENDERFX_FLICKER_FAST,
	RENDERFX_NO_DISSIPATION,
	RENDERFX_DISTORT,           /**< Distort/scale/translate flicker */
	RENDERFX_HOLOGRAM,          /**< kRenderFxDistort + distance fade */
	RENDERFX_EXPLODE,           /**< Scale up really big! */
	RENDERFX_GLOWSHELL,         /**< Glowing Shell */
	RENDERFX_CLAMP_MIN_SCALE,   /**< Keep this sprite from getting very small (SPRITES only!) */
	RENDERFX_ENV_RAIN,          /**< for environmental rendermode, make rain */
	RENDERFX_ENV_SNOW,          /**<  "        "            "    , make snow */
	RENDERFX_SPOTLIGHT,         /**< TEST CODE for experimental spotlight */
	RENDERFX_RAGDOLL,           /**< HACKHACK: TEST CODE for signalling death of a ragdoll character */
	RENDERFX_PULSE_FAST_WIDER,
	RENDERFX_MAX
};

// These defines are for client button presses.
#define IN_ATTACK                (1 << 0)
#define IN_JUMP                  (1 << 1)
#define IN_DUCK                  (1 << 2)
#define IN_FORWARD               (1 << 3)
#define IN_BACK                  (1 << 4)
#define IN_USE                   (1 << 5)
#define IN_CANCEL                (1 << 6)
#define IN_LEFT                  (1 << 7)
#define IN_RIGHT                 (1 << 8)
#define IN_MOVELEFT              (1 << 9)
#define IN_MOVERIGHT             (1 << 10)
#define IN_ATTACK2               (1 << 11)
#define IN_RUN                   (1 << 12)
#define IN_RELOAD                (1 << 13)
#define IN_ALT1                  (1 << 14)
#define IN_ALT2                  (1 << 15)
#define IN_SCORE                 (1 << 16)   /**< Used by client.dll for when scoreboard is held down */
#define IN_SPEED                 (1 << 17)   /**< Player is holding the speed key */
#define IN_WALK                  (1 << 18)   /**< Player holding walk key */
#define IN_ZOOM                  (1 << 19)   /**< Zoom key for HUD zoom */
#define IN_WEAPON1               (1 << 20)   /**< weapon defines these bits */
#define IN_WEAPON2               (1 << 21)   /**< weapon defines these bits */
#define IN_BULLRUSH              (1 << 22)
#define IN_GRENADE1              (1 << 23)   /**< grenade 1 */
#define IN_GRENADE2              (1 << 24)   /**< grenade 2 */
#define IN_ATTACK3               (1 << 25)

// Note: these are only for use with GetEntityFlags and SetEntityFlags
//       and may not match the game's actual, internal m_fFlags values.
// PLAYER SPECIFIC FLAGS FIRST BECAUSE WE USE ONLY A FEW BITS OF NETWORK PRECISION
#define FL_ONGROUND              (1 << 0)   /**< At rest / on the ground */
#define FL_DUCKING               (1 << 1)   /**< Player flag -- Player is fully crouched */
#define FL_WATERJUMP             (1 << 2)   /**< player jumping out of water */
#define FL_ONTRAIN               (1 << 3)   /**< Player is _controlling_ a train, so movement commands should be ignored on client during prediction. */
#define FL_INRAIN                (1 << 4)   /**< Indicates the entity is standing in rain */
#define FL_FROZEN                (1 << 5)   /**< Player is frozen for 3rd person camera */
#define FL_ATCONTROLS            (1 << 6)   /**< Player can't move, but keeps key inputs for controlling another entity */
#define FL_CLIENT                (1 << 7)   /**< Is a player */
#define FL_FAKECLIENT            (1 << 8)   /**< Fake client, simulated server side; don't send network messages to them */
// NOTE if you move things up, make sure to change this value
#define PLAYER_FLAG_BITS          9
// NON-PLAYER SPECIFIC (i.e., not used by GameMovement or the client .dll ) -- Can still be applied to players, though
#define FL_INWATER               (1 << 9)   /**< In water */
#define FL_FLY                   (1 << 10)  /**< Changes the SV_Movestep() behavior to not need to be on ground */
#define FL_SWIM                  (1 << 11)  /**< Changes the SV_Movestep() behavior to not need to be on ground (but stay in water) */
#define FL_CONVEYOR              (1 << 12)
#define FL_NPC                   (1 << 13)
#define FL_GODMODE               (1 << 14)
#define FL_NOTARGET              (1 << 15)
#define FL_AIMTARGET             (1 << 16)  /**< set if the crosshair needs to aim onto the entity */
#define FL_PARTIALGROUND         (1 << 17)  /**< not all corners are valid */
#define FL_STATICPROP            (1 << 18)  /**< Eetsa static prop!  */
#define FL_GRAPHED               (1 << 19)  /**< worldgraph has this ent listed as something that blocks a connection */
#define FL_GRENADE               (1 << 20)
#define FL_STEPMOVEMENT          (1 << 21)  /**< Changes the SV_Movestep() behavior to not do any processing */
#define FL_DONTTOUCH             (1 << 22)  /**< Doesn't generate touch functions, generates Untouch() for anything it was touching when this flag was set */
#define FL_BASEVELOCITY          (1 << 23)  /**< Base velocity has been applied this frame (used to convert base velocity into momentum) */
#define FL_WORLDBRUSH            (1 << 24)  /**< Not moveable/removeable brush entity (really part of the world, but represented as an entity for transparency or something) */
#define FL_OBJECT                (1 << 25)  /**< Terrible name. This is an object that NPCs should see. Missiles, for example. */
#define FL_KILLME                (1 << 26)  /**< This entity is marked for death -- will be freed by game DLL */
#define FL_ONFIRE                (1 << 27)  /**< You know... */
#define FL_DISSOLVING            (1 << 28)  /**< We're dissolving! */
#define FL_TRANSRAGDOLL          (1 << 29)  /**< In the process of turning into a client side ragdoll. */
#define FL_UNBLOCKABLE_BY_PLAYER (1 << 30)  /**< pusher that can't be blocked by the player */
#define FL_FREEZING              (1 << 31)  /**< We're becoming frozen! */
#define FL_EP2V_UNKNOWN1         (1 << 31)  /**< Unknown */
// END entity flag #defines

/**
 * Get an entity's flags.
 *
 * @note The game's actual flags are internally translated by SM
 *       to match the entity flags defined above as the actual values
 *       can differ per engine.
 *
 * @param entity        Entity index.
 * @return              Entity's flags, see entity flag defines above.
 * @error               Invalid entity index, or lack of mod compliance.
 */
native int GetEntityFlags(int entity);

/**
 * Sets an entity's flags.
 *
 * @note The entity flags as defined above are internally translated by SM
 *       to match the current game's expected value for the flags as
 *       the actual values can differ per engine.
 *
 * @param entity        Entity index.
 * @param flags         Entity flags, see entity flag defines above.
 * @error               Invalid entity index, or lack of mod compliance.
 */
native void SetEntityFlags(int entity, int flags);


/**
 * Gets an entity's movetype.
 *
 * @param entity        Entity index.
 * @return              Movetype, see enum above.
 * @error               Invalid entity index, or lack of mod compliance.
 */
stock MoveType GetEntityMoveType(int entity)
{
	static bool gotconfig = false;
	static char datamap[32];

	if (!gotconfig)
	{
		GameData gc = new GameData("core.games");
		bool exists = gc.GetKeyValue("m_MoveType", datamap, sizeof(datamap));
		delete gc;

		if (!exists)
		{
			strcopy(datamap, sizeof(datamap), "m_MoveType");
		}

		gotconfig = true;
	}

	return view_as<MoveType>(GetEntProp(entity, Prop_Data, datamap));
}

/**
 * Sets an entity's movetype.
 *
 * @param entity        Entity index.
 * @param mt            Movetype, see enum above.
 * @error               Invalid entity index, or lack of mod compliance.
 */
stock void SetEntityMoveType(int entity, MoveType mt)
{
	static bool gotconfig = false;
	static char datamap[32];

	if (!gotconfig)
	{
		GameData gc = new GameData("core.games");
		bool exists = gc.GetKeyValue("m_MoveType", datamap, sizeof(datamap));
		delete gc;

		if (!exists)
		{
			strcopy(datamap, sizeof(datamap), "m_MoveType");
		}

		gotconfig = true;
	}

	SetEntProp(entity, Prop_Data, datamap, mt);
}

/**
 * Gets an entity's render mode.
 *
 * @param entity        Entity index.
 * @return              RenderMode value.
 * @error               Invalid entity index, or lack of mod compliance.
 */
stock RenderMode GetEntityRenderMode(int entity)
{
	static bool gotconfig = false;
	static char prop[32];

	if (!gotconfig)
	{
		GameData gc = new GameData("core.games");
		bool exists = gc.GetKeyValue("m_nRenderMode", prop, sizeof(prop));
		delete gc;

		if (!exists)
		{
			strcopy(prop, sizeof(prop), "m_nRenderMode");
		}

		gotconfig = true;
	}

	return view_as<RenderMode>(GetEntProp(entity, Prop_Send, prop, 1));
}

/**
 * Sets an entity's render mode.
 *
 * @param entity        Entity index.
 * @param mode          RenderMode value.
 * @error               Invalid entity index, or lack of mod compliance.
 */
stock void SetEntityRenderMode(int entity, RenderMode mode)
{
	static bool gotconfig = false;
	static char prop[32];

	if (!gotconfig)
	{
		GameData gc = new GameData("core.games");
		bool exists = gc.GetKeyValue("m_nRenderMode", prop, sizeof(prop));
		delete gc;

		if (!exists)
		{
			strcopy(prop, sizeof(prop), "m_nRenderMode");
		}

		gotconfig = true;
	}

	SetEntProp(entity, Prop_Send, prop, mode, 1);
}

/**
 * Gets an entity's render Fx.
 *
 * @param entity        Entity index.
 * @return              RenderFx value.
 * @error               Invalid entity index, or lack of mod compliance.
 */
stock RenderFx GetEntityRenderFx(int entity)
{
	static bool gotconfig = false;
	static char prop[32];

	if (!gotconfig)
	{
		GameData gc = new GameData("core.games");
		bool exists = gc.GetKeyValue("m_nRenderFX", prop, sizeof(prop));
		delete gc;

		if (!exists)
		{
			strcopy(prop, sizeof(prop), "m_nRenderFX");
		}

		gotconfig = true;
	}

	return view_as<RenderFx>(GetEntProp(entity, Prop_Send, prop, 1));
}

/**
 * Sets an entity's render Fx.
 *
 * @param entity        Entity index.
 * @param fx            RenderFx value.
 * @error               Invalid entity index, or lack of mod compliance.
 */
stock void SetEntityRenderFx(int entity, RenderFx fx)
{
	static bool gotconfig = false;
	static char prop[32];

	if (!gotconfig)
	{
		GameData gc = new GameData("core.games");
		bool exists = gc.GetKeyValue("m_nRenderFX", prop, sizeof(prop));
		delete gc;

		if (!exists)
		{
			strcopy(prop, sizeof(prop), "m_nRenderFX");
		}

		gotconfig = true;
	}

	SetEntProp(entity, Prop_Send, prop, fx, 1);
}

/**
 * Gets an entity's color.
 *
 * @param entity        Entity index.
 * @param r             Amount of red (0-255)
 * @param g             Amount of green (0-255)
 * @param b             Amount of blue (0-255)
 * @param a             Amount of alpha (0-255)
 * @error               Invalid entity index, or lack of mod compliance.
 */
stock void GetEntityRenderColor(int entity, int &r, int &g, int &b, int &a)
{
	static bool gotconfig = false;
	static char prop[32];

	if (!gotconfig)
	{
		GameData gc = new GameData("core.games");
		bool exists = gc.GetKeyValue("m_clrRender", prop, sizeof(prop));
		delete gc;

		if (!exists)
		{
			strcopy(prop, sizeof(prop), "m_clrRender");
		}

		gotconfig = true;
	}

	int offset = GetEntSendPropOffs(entity, prop);

	if (offset <= 0)
	{
		ThrowError("GetEntityRenderColor not supported by this mod");
	}

	r = GetEntData(entity, offset, 1);
	g = GetEntData(entity, offset + 1, 1);
	b = GetEntData(entity, offset + 2, 1);
	a = GetEntData(entity, offset + 3, 1);
}

/**
 * Sets an entity's color.
 *
 * @param entity        Entity index
 * @param r             Amount of red (0-255)
 * @param g             Amount of green (0-255)
 * @param b             Amount of blue (0-255)
 * @param a             Amount of alpha (0-255)
 * @error               Invalid entity index, or lack of mod compliance.
 */
stock void SetEntityRenderColor(int entity, int r=255, int g=255, int b=255, int a=255)
{
	static bool gotconfig = false;
	static char prop[32];

	if (!gotconfig)
	{
		GameData gc = new GameData("core.games");
		bool exists = gc.GetKeyValue("m_clrRender", prop, sizeof(prop));
		delete gc;

		if (!exists)
		{
			strcopy(prop, sizeof(prop), "m_clrRender");
		}

		gotconfig = true;
	}

	int offset = GetEntSendPropOffs(entity, prop);

	if (offset <= 0)
	{
		ThrowError("SetEntityRenderColor not supported by this mod");
	}

	SetEntData(entity, offset, r, 1, true);
	SetEntData(entity, offset + 1, g, 1, true);
	SetEntData(entity, offset + 2, b, 1, true);
	SetEntData(entity, offset + 3, a, 1, true);
}

/**
 * Gets an entity's gravity.
 *
 * @param entity 	Entity index.
 * @return              Entity's m_flGravity value.
 * @error               Invalid entity index, or lack of mod compliance.
 */
stock float GetEntityGravity(int entity)
{
	static bool gotconfig = false;
	static char datamap[32];

	if (!gotconfig)
	{
		GameData gc = new GameData("core.games");
		bool exists = gc.GetKeyValue("m_flGravity", datamap, sizeof(datamap));
		delete gc;

		if (!exists)
		{
			strcopy(datamap, sizeof(datamap), "m_flGravity");
		}

		gotconfig = true;
	}

	return GetEntPropFloat(entity, Prop_Data, datamap);
}

/**
 * Sets an entity's gravity.
 *
 * @param entity        Entity index.
 * @param amount        Gravity to set (default = 1.0, half = 0.5, double = 2.0).
 * @error               Invalid entity index, or lack of mod compliance.
 */
stock void SetEntityGravity(int entity, float amount)
{
	static bool gotconfig = false;
	static char datamap[32];

	if (!gotconfig)
	{
		GameData gc = new GameData("core.games");
		bool exists = gc.GetKeyValue("m_flGravity", datamap, sizeof(datamap));
		delete gc;

		if (!exists)
		{
			strcopy(datamap, sizeof(datamap), "m_flGravity");
		}

		gotconfig = true;
	}

	SetEntPropFloat(entity, Prop_Data, datamap, amount);
}

/**
 * Sets an entity's health
 *
 * @param entity        Entity index.
 * @param amount        Health amount.
 * @error               Invalid entity index, or lack of mod compliance.
 */
stock void SetEntityHealth(int entity, int amount)
{
	static bool gotconfig = false;
	static char prop[32];

	if (!gotconfig)
	{
		GameData gc = new GameData("core.games");
		bool exists = gc.GetKeyValue("m_iHealth", prop, sizeof(prop));
		delete gc;

		if (!exists)
		{
			strcopy(prop, sizeof(prop), "m_iHealth");
		}

		gotconfig = true;
	}

	char cls[64];
	PropFieldType type;
	int offset;

	if (!GetEntityNetClass(entity, cls, sizeof(cls)))
	{
		ThrowError("SetEntityHealth not supported by this mod: Could not get serverclass name");
		return;
	}

	offset = FindSendPropInfo(cls, prop, type);

	if (offset <= 0)
	{
		ThrowError("SetEntityHealth not supported by this mod");
		return;
	}

	/* Dark Messiah uses a float for the health instead an integer */
	if (type == PropField_Float)
	{
		SetEntDataFloat(entity, offset, float(amount));
	}
	else
	{
		SetEntProp(entity, Prop_Send, prop, amount);
	}
}

/**
 * Get's a users current pressed buttons
 *
 * @param client        Client index
 * @return              Bitsum of buttons
 * @error               Invalid client index, client not in game,
 *                      or lack of mod compliance.
 */
stock int GetClientButtons(int client)
{
	static bool gotconfig = false;
	static char datamap[32];

	if (!gotconfig)
	{
		GameData gc = new GameData("core.games");
		bool exists = gc.GetKeyValue("m_nButtons", datamap, sizeof(datamap));
		delete gc;

		if (!exists)
		{
			strcopy(datamap, sizeof(datamap), "m_nButtons");
		}

		gotconfig = true;
	}

	return GetEntProp(client, Prop_Data, datamap);
}
/**
 * vim: set ts=4 sw=4 tw=99 noet :
 * =============================================================================
 * SourceMod (C)2004-2014 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _menus_included
 #endinput
#endif
#define _menus_included

/**
 * Low-level drawing style of the menu.
 */
enum MenuStyle
{
	MenuStyle_Default = 0,      /**< The "default" menu style for the mod */
	MenuStyle_Valve = 1,        /**< The Valve provided menu style (Used on HL2DM) */
	MenuStyle_Radio = 2         /**< The simpler menu style commonly used on CS:S */
};

/**
 * Different actions for the menu "pump" callback
 */
enum MenuAction
{
	MenuAction_Start = (1<<0),      /**< A menu has been started (nothing passed) */
	MenuAction_Display = (1<<1),    /**< A menu is about to be displayed (param1=client, param2=MenuPanel Handle) */
	MenuAction_Select = (1<<2),     /**< An item was selected (param1=client, param2=item) */
	MenuAction_Cancel = (1<<3),     /**< The menu was cancelled (param1=client, param2=reason) */
	MenuAction_End = (1<<4),        /**< A menu display has fully ended.
                                         param1 is the MenuEnd reason, and if it's MenuEnd_Cancelled, then
                                         param2 is the MenuCancel reason from MenuAction_Cancel. */
	MenuAction_VoteEnd = (1<<5),    /**< (VOTE ONLY): A vote sequence has succeeded (param1=chosen item)
                                         This is not called if SetVoteResultCallback has been used on the menu. */
	MenuAction_VoteStart = (1<<6),  /**< (VOTE ONLY): A vote sequence has started (nothing passed) */
	MenuAction_VoteCancel = (1<<7), /**< (VOTE ONLY): A vote sequence has been cancelled (param1=reason) */
	MenuAction_DrawItem = (1<<8),   /**< An item is being drawn; return the new style (param1=client, param2=item) */
	MenuAction_DisplayItem = (1<<9) /**< Item text is being drawn to the display (param1=client, param2=item)
                                         To change the text, use RedrawMenuItem().
                                         If you do so, return its return value.  Otherwise, return 0. */
};

/** Default menu actions */
#define MENU_ACTIONS_DEFAULT    MenuAction_Select|MenuAction_Cancel|MenuAction_End
/** All menu actions */
#define MENU_ACTIONS_ALL        view_as<MenuAction>(0xFFFFFFFF)

#define MENU_NO_PAGINATION      0           /**< Menu should not be paginated (10 items max) */
#define MENU_TIME_FOREVER       0           /**< Menu should be displayed as long as possible */

#define ITEMDRAW_DEFAULT            (0)     /**< Item should be drawn normally */
#define ITEMDRAW_DISABLED           (1<<0)  /**< Item is drawn but not selectable */
#define ITEMDRAW_RAWLINE            (1<<1)  /**< Item should be a raw line, without a slot */
#define ITEMDRAW_NOTEXT             (1<<2)  /**< No text should be drawn */
#define ITEMDRAW_SPACER             (1<<3)  /**< Item should be drawn as a spacer, if possible */
#define ITEMDRAW_IGNORE     ((1<<1)|(1<<2)) /**< Item should be completely ignored (rawline + notext) */
#define ITEMDRAW_CONTROL            (1<<4)  /**< Item is control text (back/next/exit) */

#define MENUFLAG_BUTTON_EXIT        (1<<0)  /**< Menu has an "exit" button (default if paginated) */
#define MENUFLAG_BUTTON_EXITBACK    (1<<1)  /**< Menu has an "exit back" button */
#define MENUFLAG_NO_SOUND           (1<<2)  /**< Menu will not have any select sounds */
#define MENUFLAG_BUTTON_NOVOTE      (1<<3)  /**< Menu has a "No Vote" button at slot 1 */

#define VOTEINFO_CLIENT_INDEX       0       /**< Client index */
#define VOTEINFO_CLIENT_ITEM        1       /**< Item the client selected, or -1 for none */
#define VOTEINFO_ITEM_INDEX         0       /**< Item index */
#define VOTEINFO_ITEM_VOTES         1       /**< Number of votes for the item */

#define VOTEFLAG_NO_REVOTES         (1<<0)  /**< Players cannot change their votes */

/**
 * Reasons a menu can be cancelled (MenuAction_Cancel).
 */
enum
{
	MenuCancel_Disconnected = -1,   /**< Client dropped from the server */
	MenuCancel_Interrupted = -2,    /**< Client was interrupted with another menu */
	MenuCancel_Exit = -3,           /**< Client exited via "exit" */
	MenuCancel_NoDisplay = -4,      /**< Menu could not be displayed to the client */
	MenuCancel_Timeout = -5,        /**< Menu timed out */
	MenuCancel_ExitBack = -6        /**< Client selected "exit back" on a paginated menu */
};

/**
 * Reasons a vote can be cancelled (MenuAction_VoteCancel).
 */
enum
{
	VoteCancel_Generic = -1,        /**< Vote was generically cancelled. */
	VoteCancel_NoVotes = -2         /**< Vote did not receive any votes. */
};

/**
 * Reasons a menu ended (MenuAction_End).
 */
enum
{
	MenuEnd_Selected = 0,           /**< Menu item was selected */
	MenuEnd_VotingDone = -1,        /**< Voting finished */
	MenuEnd_VotingCancelled = -2,   /**< Voting was cancelled */
	MenuEnd_Cancelled = -3,         /**< Menu was cancelled (reason in param2) */
	MenuEnd_Exit = -4,              /**< Menu was cleanly exited via "exit" */
	MenuEnd_ExitBack = -5           /**< Menu was cleanly exited via "back" */
};

/**
 * Describes a menu's source
 */
enum MenuSource
{
	MenuSource_None = 0,            /**< No menu is being displayed */
	MenuSource_External = 1,        /**< External menu */
	MenuSource_Normal = 2,          /**< A basic menu is being displayed */
	MenuSource_RawPanel = 3         /**< A display is active, but it is not tied to a menu */
};

/**
 * Called when a menu action is completed.
 *
 * @param menu              The menu being acted upon.
 * @param action            The action of the menu.
 * @param param1            First action parameter (usually the client).
 * @param param2            Second action parameter (usually the item).
 */
typedef MenuHandler = function int (Menu menu, MenuAction action, int param1, int param2);

// Panels are used for drawing raw menus without any extra helper functions.
// Handles must be closed via delete or CloseHandle().
methodmap Panel < Handle
{
	// Constructor for a new Panel.
	//
	// @param hStyle        MenuStyle Handle, or null to use the default style.
	public native Panel(Handle hStyle = null);

	// Sets the panel's title.
	//
	// @param text          Text to set as the title.
	// @param onlyIfEmpty   If true, the title will only be set if no title is set.
	public native void SetTitle(const char[] text, bool onlyIfEmpty=false);

	// Draws an item on a panel.  If the item takes up a slot, the position
	// is returned.
	//
	// @param text          Display text to use.  If not a raw line,
	//                      the style may automatically add color markup.
	//                      No numbering or newlines are needed.
	// @param style         ITEMDRAW style flags.
	// @return              A slot position, or 0 if item was a rawline or could not be drawn.
	public native int DrawItem(const char[] text, int style=ITEMDRAW_DEFAULT);

	// Draws a raw line of text on a panel, without any markup other than a
	// newline.
	//
	// @param text          Display text to use.
	// @return              True on success, false if raw lines are not supported.
	public native bool DrawText(const char[] text);

	// Returns whether or not the given drawing flags are supported by
	// the menu style.
	//
	// @param style         ITEMDRAW style flags.
	// @return              True if item is drawable, false otherwise.
	public native bool CanDrawFlags(int style);

	// Sets the selectable key map of a panel.  This is not supported by
	// all styles (only by Radio, as of this writing).
	//
	// @param keys          An integer where each bit N allows key
	//                      N+1 to be selected.  If no keys are selectable,
	//                      then key 0 (bit 9) is automatically set.
	// @return              True if supported, false otherwise.
	public native bool SetKeys(int keys);

	// Sends a panel to a client.  Unlike full menus, the handler
	// function will only receive the following actions, both of
	// which will have null for a menu, and the client as param1.
	//
	// MenuAction_Select (param2 will be the key pressed)
	// MenuAction_Cancel (param2 will be the reason)
	//
	// Also, if the menu fails to display, no callbacks will be called.
	//
	// @param client        A client to draw to.
	// @param handler       The MenuHandler function to catch actions with.
	// @param time          Time to hold the menu for.
	// @return              True on success, false on failure.
	public native bool Send(int client, MenuHandler handler, int time);

	// Returns the amount of text the menu can still hold.  If this is
	// limit is reached or overflowed, the text is silently truncated.
	//
	// Radio menus: Currently 511 characters (512 bytes).
	// Valve menus: Currently -1 (no meaning).
	property int TextRemaining {
		public native get();
	}

	// Returns or sets the current key position, starting at 1. This cannot be
	// used to traverse backwards.
	property int CurrentKey {
		public native get();
		public native set(int key);
	}

	// Returns the panel's style. Style handles are global and cannot be closed.
	property Handle Style {
		public native get();
	}
};

// A menu is a helper object for managing in-game menus.
methodmap Menu < Handle
{
	// Creates a new, empty menu using the default style.
	//
	// @param handler       Function which will receive menu actions.
	// @param actions       Optionally set which actions to receive.  Select,
	//                      Cancel, and End will always be received regardless
	//                      of whether they are set or not.  They are also
	//                      the only default actions.
	public native Menu(MenuHandler handler, MenuAction actions=MENU_ACTIONS_DEFAULT);

	// Displays a menu to a client.
	//
	// @param client        Client index.
	// @param time          Maximum time to leave menu on the screen.
	// @return              True on success, false on failure.
	// @error               Client not in game.
	public native bool Display(int client, int time);

	// Displays a menu to a client, starting from the given item.
	//
	// @param client        Client index.
	// @param first_item    First item to begin drawing from.
	// @param time          Maximum time to leave menu on the screen.
	// @return              True on success, false on failure.
	// @error               Client not in game.
	///
	public native bool DisplayAt(int client, int first_item, int time);

	// Appends a new item to the end of a menu.
	//
	// @param info          Item information string.
	// @param display       Default item display string.
	// @param style         Drawing style flags.  Anything other than DEFAULT or
	//                      DISABLED will be completely ignored when paginating.
	// @return              True on success, false on failure.
	// @error               Item limit reached.
	public native bool AddItem(const char[] info, const char[] display, int style=ITEMDRAW_DEFAULT);

	// Inserts an item into the menu before a certain position; the new item will
	// be at the given position and all next items pushed forward.
	//
	// @param position      Position, starting from 0.
	// @param info          Item information string.
	// @param display       Default item display string.
	// @param style         Drawing style flags.  Anything other than DEFAULT or
	//                      DISABLED will be completely ignored when paginating.
	// @return              True on success, false on failure.
	// @error               Invalid menu position.
	public native bool InsertItem(int position, const char[] info,
	                              const char[] display, int style=ITEMDRAW_DEFAULT);

	// Removes an item from the menu.
	//
	// @param position      Position, starting from 0.
	// @return              True on success, false on failure.
	// @error               Invalid menu position.
	public native bool RemoveItem(int position);

	// Removes all items from a menu.
	public native void RemoveAllItems();

	// Retrieves information about a menu item.
	//
	// @param position      Position, starting from 0.
	// @param infoBuf       Info buffer.
	// @param infoBufLen    Maximum length of the info buffer.
	// @param style         By-reference variable to store drawing flags.
	// @param dispBuf       Display buffer.
	// @param dispBufLen    Maximum length of the display buffer.
	// @return              True on success, false if position is invalid.
	public native bool GetItem(int position, char[] infoBuf, int infoBufLen,
							   int &style=0, char[] dispBuf="", int dispBufLen=0);

	// Sets the menu's default title/instruction message.
	//
	// @param fmt           Message string format
	// @param ...           Message string arguments.
	public native void SetTitle(const char[] fmt, any ...);

	// Returns the text of a menu's title.
	//
	// @param buffer        Buffer to store title.
	// @param maxlength     Maximum length of the buffer.
	// @return              Number of bytes written.
	public native void GetTitle(char[] buffer, int maxlength);

	// Creates a raw MenuPanel based off the menu's style.
	// The Handle must be freed with CloseHandle().
	//
	// @return              A new MenuPanel Handle.
	public native Panel ToPanel();

	// Cancels a menu from displaying on all clients.  While the
	// cancellation is in progress, this menu cannot be re-displayed
	// to any clients.
	//
	// The menu may still exist on the client's screen after this command.
	// This simply verifies that the menu is not being used anywhere.
	//
	// If any vote is in progress on a menu, it will be cancelled.
	public native void Cancel();

	// Broadcasts a menu to a list of clients.  The most selected item will be
	// returned through MenuAction_End.  On a tie, a random item will be returned
	// from a list of the tied items.
	//
	// Note that MenuAction_VoteEnd and MenuAction_VoteStart are both
	// default callbacks and do not need to be enabled.
	//
	// @param clients       Array of clients to broadcast to.
	// @param numClients    Number of clients in the array.
	// @param time          Maximum time to leave menu on the screen.
	// @param flags         Optional voting flags.
	// @return              True on success, false if this menu already has a
	//                      vote session in progress.
	// @error               A vote is already in progress.
	public native bool DisplayVote(int[] clients, int numClients, int time, int flags=0);

	// Sends a vote menu to all clients.  See VoteMenu() for more information.
	//
	// @param time          Maximum time to leave menu on the screen.
	// @param flags         Optional voting flags.
	// @return              True on success, false if this menu already has a
	//                      vote session in progress.
	public bool DisplayVoteToAll(int time, int flags=0) {
		int total = 0;
		int[] players = new int[MaxClients];
		for (int i = 1; i <= MaxClients; i++) {
			if (!IsClientInGame(i) || IsFakeClient(i))
			{
				continue;
			}
			players[total++] = i;
		}
		return this.DisplayVote(players, total, time, flags);
	}

	// Get or set the menu's pagination.
	//
	// If pagination is MENU_NO_PAGINATION, and the exit button flag is set,
	// then the exit button flag is removed. It can be re-applied if desired.
	property int Pagination {
		public native get();
		public native set(int value);
	}

	// Get or set the menu's option flags.
	//
	// If a certain bit is not supported, it will be stripped before being set.
	property int OptionFlags {
		public native get();
		public native set(int value);
	}

	// Returns whether or not the menu has an exit button. By default, menus
	// have an exit button.
	property bool ExitButton {
		public native get();
		public native set(bool value);
	}

	// Controls whether or not the menu has an "exit back" button. By default,
	// menus do not have an exit back button.
	//
	// Exit Back buttons appear as "Back" on page 1 of paginated menus and have
	// functionality defined by the user in MenuEnd_ExitBack.
	property bool ExitBackButton {
		public native get();
		public native set(bool value);
	}

	// Sets whether or not the menu has a "no vote" button in slot 1.
	// By default, menus do not have a no vote button.
	property bool NoVoteButton {
		public native set(bool value);
	}

	// Sets an advanced vote handling callback. If this callback is set,
	// MenuAction_VoteEnd will not be called.
	property VoteHandler VoteResultCallback {
		public native set(VoteHandler handler);
	}

	// Returns the number of items in a menu.
	property int ItemCount {
		public native get();
	}

	// Returns the menu style. The Handle is global and cannot be closed.
	property Handle Style {
		public native get();
	}

	// Returns the first item on the page of a currently selected menu.
	//
	// This is only valid inside a MenuAction_Select callback.
	property int Selection {
		public native get();
	}
}

/**
 * Creates a new, empty menu using the default style.
 *
 * @param handler       Function which will receive menu actions.
 * @param actions       Optionally set which actions to receive.  Select,
 *                      Cancel, and End will always be received regardless
 *                      of whether they are set or not.  They are also
 *                      the only default actions.
 * @return              A new menu Handle.
 */
native Menu CreateMenu(MenuHandler handler, MenuAction actions=MENU_ACTIONS_DEFAULT);

/**
 * Displays a menu to a client.
 *
 * @param menu          Menu Handle.
 * @param client        Client index.
 * @param time          Maximum time to leave menu on the screen.
 * @return              True on success, false on failure.
 * @error               Invalid Handle or client not in game.
 */
native bool DisplayMenu(Handle menu, int client, int time);

/**
 * Displays a menu to a client, starting from the given item.
 *
 * @param menu          Menu Handle.
 * @param client        Client index.
 * @param first_item    First item to begin drawing from.
 * @param time          Maximum time to leave menu on the screen.
 * @return              True on success, false on failure.
 * @error               Invalid Handle or client not in game.
 */
native bool DisplayMenuAtItem(Handle menu, int client, int first_item, int time);

/**
 * Appends a new item to the end of a menu.
 *
 * @param menu          Menu Handle.
 * @param info          Item information string.
 * @param display       Default item display string.
 * @param style         Drawing style flags.  Anything other than DEFAULT or
 *                      DISABLED will be completely ignored when paginating.
 * @return              True on success, false on failure.
 * @error               Invalid Handle or item limit reached.
 */
native bool AddMenuItem(Handle menu,
						const char[] info,
						const char[] display,
						int style=ITEMDRAW_DEFAULT);

/**
 * Inserts an item into the menu before a certain position; the new item will
 * be at the given position and all next items pushed forward.
 *
 * @param menu          Menu Handle.
 * @param position      Position, starting from 0.
 * @param info          Item information string.
 * @param display       Default item display string.
 * @param style         Drawing style flags.  Anything other than DEFAULT or
 *                      DISABLED will be completely ignored when paginating.
 * @return              True on success, false on failure.
 * @error               Invalid Handle or menu position.
 */
native bool InsertMenuItem(Handle menu,
						position,
						const char[] info,
						const char[] display,
						int style=ITEMDRAW_DEFAULT);

/**
 * Removes an item from the menu.
 *
 * @param menu          Menu Handle.
 * @param position      Position, starting from 0.
 * @return              True on success, false on failure.
 * @error               Invalid Handle or menu position.
 */
native bool RemoveMenuItem(Handle menu, int position);

/**
 * Removes all items from a menu.
 *
 * @param menu          Menu Handle.
 * @error               Invalid Handle or menu position.
 */
native void RemoveAllMenuItems(Handle menu);

/**
 * Retrieves information about a menu item.
 *
 * @param menu          Menu Handle.
 * @param position      Position, starting from 0.
 * @param infoBuf       Info buffer.
 * @param infoBufLen    Maximum length of the info buffer.
 * @param style         By-reference variable to store drawing flags.
 * @param dispBuf       Display buffer.
 * @param dispBufLen    Maximum length of the display buffer.
 * @return              True on success, false if position is invalid.
 * @error               Invalid Handle.
 */
native bool GetMenuItem(Handle menu,
						int position,
						char[] infoBuf,
						int infoBufLen,
						int &style=0,
						char[] dispBuf="",
						int dispBufLen=0);

/**
 * Returns the first item on the page of a currently selected menu.
 *
 * This is only valid inside a MenuAction_Select callback.
 *
 * @return              First item number on the page the client was viewing
 *                      before selecting the item in the callback.  This can
 *                      be used to re-display the menu from the original
 *                      position.
 * @error               Not called from inside a MenuAction_Select callback.
 */
native int GetMenuSelectionPosition();

/**
 * Returns the number of items in a menu.
 *
 * @param menu          Menu Handle.
 * @return              Number of items in the menu.
 * @error               Invalid Handle.
 */
native int GetMenuItemCount(Handle menu);

/**
 * Sets whether the menu should be paginated or not.
 *
 * If itemsPerPage is MENU_NO_PAGINATION, and the exit button flag is set,
 * then the exit button flag is removed.  It can be re-applied if desired.
 *
 * @param menu          Handle to the menu.
 * @param itemsPerPage  Number of items per page, or MENU_NO_PAGINATION.
 * @return              True on success, false if pagination is too high or
 *                      low.
 * @error               Invalid Handle.
 */
native bool SetMenuPagination(Handle menu, int itemsPerPage);

/**
 * Returns a menu's pagination setting.
 *
 * @param menu          Handle to the menu.
 * @return              Pagination setting.
 * @error               Invalid Handle.
 */
native int GetMenuPagination(Handle menu);

/**
 * Returns a menu's MenuStyle Handle.  The Handle
 * is global and cannot be freed.
 *
 * @param menu          Handle to the menu.
 * @return              Handle to the menu's draw style.
 * @error               Invalid Handle.
 */
native Handle GetMenuStyle(Handle menu);

/**
 * Sets the menu's default title/instruction message.
 *
 * @param menu          Menu Handle.
 * @param fmt           Message string format
 * @param ...           Message string arguments.
 * @error               Invalid Handle.
 */
native void SetMenuTitle(Handle menu, const char[] fmt, any ...);

/**
 * Returns the text of a menu's title.
 *
 * @param menu          Menu Handle.
 * @param buffer        Buffer to store title.
 * @param maxlength     Maximum length of the buffer.
 * @return              Number of bytes written.
 * @error               Invalid Handle/
 */
native int GetMenuTitle(Handle menu, char[] buffer, int maxlength);

/**
 * Creates a raw MenuPanel based off the menu's style.
 * The Handle must be freed with CloseHandle().
 *
 * @param menu          Menu Handle.
 * @return              A new MenuPanel Handle.
 * @error               Invalid Handle.
 */
native Panel CreatePanelFromMenu(Handle menu);

/**
 * Returns whether or not the menu has an exit button.
 * By default, menus have an exit button.
 *
 * @param menu          Menu Handle.
 * @return              True if the menu has an exit button; false otherwise.
 * @error               Invalid Handle.
 */
native bool GetMenuExitButton(Handle menu);

/**
 * Sets whether or not the menu has an exit button.  By default, paginated menus
 * have an exit button.
 *
 * If a menu's pagination is changed to MENU_NO_PAGINATION, and the pagination
 * was previously a different value, then the Exit button status is changed to
 * false.  It must be explicitly re-enabled afterwards.
 *
 * If a non-paginated menu has an exit button, then at most 9 items will be
 * displayed.
 *
 * @param menu          Menu Handle.
 * @param button        True to enable the button, false to remove it.
 * @return              True if allowed; false on failure.
 * @error               Invalid Handle.
 */
native bool SetMenuExitButton(Handle menu, bool button);

/**
 * Returns whether or not the menu has an "exit back" button.  By default,
 * menus do not have an exit back button.
 *
 * Exit Back buttons appear as "Back" on page 1 of paginated menus and have
 * functionality defined by the user in MenuEnd_ExitBack.
 *
 * @param menu          Menu Handle.
 * @return              True if the menu has an exit back button; false otherwise.
 * @error               Invalid Handle.
 */
native bool GetMenuExitBackButton(Handle menu);

/**
 * Sets whether or not the menu has an "exit back" button. By default, menus
 * do not have an exit back button.
 *
 * Exit Back buttons appear as "Back" on page 1 of paginated menus and have
 * functionality defined by the user in MenuEnd_ExitBack.
 *
 * @param menu          Menu Handle.
 * @param button        True to enable the button, false to remove it.
 * @error               Invalid Handle.
 */
native void SetMenuExitBackButton(Handle menu, bool button);

/**
 * Sets whether or not the menu has a "no vote" button in slot 1.
 * By default, menus do not have a no vote button.
 *
 * @param menu          Menu Handle.
 * @param button        True to enable the button, false to remove it.
 * @return              True if allowed; false on failure.
 * @error               Invalid Handle.
 */
native bool SetMenuNoVoteButton(Handle menu, bool button);

/**
 * Cancels a menu from displaying on all clients.  While the
 * cancellation is in progress, this menu cannot be re-displayed
 * to any clients.
 *
 * The menu may still exist on the client's screen after this command.
 * This simply verifies that the menu is not being used anywhere.
 *
 * If any vote is in progress on a menu, it will be cancelled.
 *
 * @param menu          Menu Handle.
 * @error               Invalid Handle.
 */
native void CancelMenu(Handle menu);

/**
 * Retrieves a menu's option flags.
 *
 * @param menu          Menu Handle.
 * @return              A bitstring of MENUFLAG bits.
 * @error               Invalid Handle.
 */
native int GetMenuOptionFlags(Handle menu);

/**
 * Sets a menu's option flags.
 *
 * If a certain bit is not supported, it will be stripped before being set.
 * See SetMenuExitButton() for information on Exit buttons.
 * See SetMenuExitBackButton() for information on Exit Back buttons.
 *
 * @param menu          Menu Handle.
 * @param flags         A new bitstring of MENUFLAG bits.
 * @error               Invalid Handle.
 */
native void SetMenuOptionFlags(Handle menu, int flags);

/**
 * Returns whether a vote is in progress.
 *
 * @param menu          Deprecated; no longer used.
 * @return              True if a vote is in progress, false otherwise.
 */
native bool IsVoteInProgress(Handle menu=INVALID_HANDLE);

/**
 * Cancels the vote in progress.
 *
 * @error               If no vote is in progress.
 */
native void CancelVote();

/**
 * Broadcasts a menu to a list of clients.  The most selected item will be
 * returned through MenuAction_End.  On a tie, a random item will be returned
 * from a list of the tied items.
 *
 * Note that MenuAction_VoteEnd and MenuAction_VoteStart are both
 * default callbacks and do not need to be enabled.
 *
 * @param menu          Menu Handle.
 * @param clients       Array of clients to broadcast to.
 * @param numClients    Number of clients in the array.
 * @param time          Maximum time to leave menu on the screen.
 * @param flags         Optional voting flags.
 * @return              True on success, false if this menu already has a vote session
 *                      in progress.
 * @error               Invalid Handle, or a vote is already in progress.
 */
native bool VoteMenu(Handle menu, int[] clients, int numClients, int time, int flags=0);

/**
 * Sends a vote menu to all clients.  See VoteMenu() for more information.
 *
 * @param menu          Menu Handle.
 * @param time          Maximum time to leave menu on the screen.
 * @param flags         Optional voting flags.
 * @return              True on success, false if this menu already has a vote session
 *                      in progress.
 * @error               Invalid Handle.
 */
stock bool VoteMenuToAll(Handle menu, int time, int flags=0)
{
	int total;
	int[] players = new int[MaxClients];

	for (int i=1; i<=MaxClients; i++)
	{
		if (!IsClientInGame(i) || IsFakeClient(i))
		{
			continue;
		}
		players[total++] = i;
	}

	return VoteMenu(menu, players, total, time, flags);
}

/**
 * Callback for when a vote has ended and results are available.
 *
 * @param menu          The menu being voted on.
 * @param num_votes     Number of votes tallied in total.
 * @param num_clients   Number of clients who could vote.
 * @param client_info   Array of clients.  Use VOTEINFO_CLIENT_ defines.
 * @param num_items     Number of unique items that were selected.
 * @param item_info     Array of items, sorted by count.  Use VOTEINFO_ITEM
 *                      defines.
 */
typeset VoteHandler
{
	// old style
	function void(
		Menu menu,
		int num_votes,
		int num_clients,
		const int client_info[][2],
		int num_items,
		const int item_info[][2]
	);

	// new style
	function void(
		Menu menu,
		int num_votes,
		int num_clients,
		const int[][] client_info,
		int num_items,
		const int[][] item_info
	);
};

/**
 * Sets an advanced vote handling callback.  If this callback is set,
 * MenuAction_VoteEnd will not be called.
 *
 * @param menu          Menu Handle.
 * @param callback      Callback function.
 * @error               Invalid Handle or callback.
 */
native void SetVoteResultCallback(Handle menu, VoteHandler callback);

/**
 * Returns the number of seconds you should "wait" before displaying
 * a publicly invocable menu.  This number is the time remaining until
 * (last_vote + sm_vote_delay).
 *
 * @return              Number of seconds to wait, or 0 for none.
 */
native int CheckVoteDelay();

/**
 * Returns whether a client is in the pool of clients allowed
 * to participate in the current vote.  This is determined by
 * the client list passed to VoteMenu().
 *
 * @param client        Client index.
 * @return              True if client is allowed to vote, false otherwise.
 * @error               If no vote is in progress or client index is invalid.
 */
native bool IsClientInVotePool(int client);

/**
 * Redraws the current vote menu to a client in the voting pool.
 *
 * @param client        Client index.
 * @param revotes       True to allow revotes, false otherwise.
 * @return              True on success, false if the client is in the vote pool
 *                      but cannot vote again.
 * @error               No vote in progress, int client is not in the voting pool,
 *                      or client index is invalid.
 */
native bool RedrawClientVoteMenu(int client, bool revotes=true);

/**
 * Returns a style's global Handle.
 *
 * @param style         Menu Style.
 * @return              A Handle, or INVALID_HANDLE if not found or unusable.
 */
native Handle GetMenuStyleHandle(MenuStyle style);

/**
 * Creates a MenuPanel from a MenuStyle.  Panels are used for drawing raw
 * menus without any extra helper functions.  The Handle must be closed
 * with CloseHandle().
 *
 * @param hStyle        MenuStyle Handle, or INVALID_HANDLE to use the default style.
 * @return              A new MenuPanel Handle.
 * @error               Invalid Handle other than INVALID_HANDLE.
 */
native Panel CreatePanel(Handle hStyle=INVALID_HANDLE);

/**
 * Creates a Menu from a MenuStyle.  The Handle must be closed with
 * CloseHandle().
 *
 * @param hStyle        MenuStyle Handle, or INVALID_HANDLE to use the default style.
 * @param handler       Function which will receive menu actions.
 * @param actions       Optionally set which actions to receive.  Select,
 *                      Cancel, and End will always be received regardless
 *                      of whether they are set or not.  They are also
 *                      the only default actions.
 * @return              A new menu Handle.
 * @error               Invalid Handle other than INVALID_HANDLE.
 */
native Menu CreateMenuEx(Handle hStyle=INVALID_HANDLE, MenuHandler handler, MenuAction actions=MENU_ACTIONS_DEFAULT);

/**
 * Returns whether a client is viewing a menu.
 *
 * @param client        Client index.
 * @param hStyle        MenuStyle Handle, or INVALID_HANDLE to use the default style.
 * @return              A MenuSource value.
 * @error               Invalid Handle other than null.
 */
native MenuSource GetClientMenu(int client, Handle hStyle=null);

/**
 * Cancels a menu on a client.  This will only affect non-external menus.
 *
 * @param client        Client index.
 * @param autoIgnore    If true, no menus can be re-drawn on the client during
 *                      the cancellation process.
 * @param hStyle        MenuStyle Handle, or INVALID_HANDLE to use the default style.
 * @return              True if a menu was cancelled, false otherwise.
 */
native bool CancelClientMenu(int client, bool autoIgnore=false, Handle hStyle=INVALID_HANDLE);

/**
 * Returns a style's maximum items per page.
 *
 * @param hStyle        MenuStyle Handle, or INVALID_HANDLE to use the default style.
 * @return              Maximum items per page.
 * @error               Invalid Handle other than INVALID_HANDLE.
 */
native int GetMaxPageItems(Handle hStyle=INVALID_HANDLE);

/**
 * Returns a MenuPanel's parent style.
 *
 * @param panel         A MenuPanel Handle.
 * @return              The MenuStyle Handle that created the panel.
 * @error               Invalid Handle.
 */
native Handle GetPanelStyle(Handle panel);

/**
 * Sets the panel's title.
 *
 * @param panel         A MenuPanel Handle.
 * @param text          Text to set as the title.
 * @param onlyIfEmpty   If true, the title will only be set if no title is set.
 * @error               Invalid Handle.
 */
native void SetPanelTitle(Handle panel, const char[] text, bool onlyIfEmpty=false);

/**
 * Draws an item on a panel.  If the item takes up a slot, the position
 * is returned.
 *
 * @param panel         A MenuPanel Handle.
 * @param text          Display text to use.  If not a raw line,
 *                      the style may automatically add color markup.
 *                      No numbering or newlines are needed.
 * @param style         ITEMDRAW style flags.
 * @return              A slot position, or 0 if item was a rawline or could not be drawn.
 * @error               Invalid Handle.
 */
native int DrawPanelItem(Handle panel, const char[] text, int style=ITEMDRAW_DEFAULT);

/**
 * Draws a raw line of text on a panel, without any markup other than a newline.
 *
 * @param panel         A MenuPanel Handle, or INVALID_HANDLE if inside a
 *                      MenuAction_DisplayItem callback.
 * @param text          Display text to use.
 * @return              True on success, false if raw lines are not supported.
 * @error               Invalid Handle.
 */
native bool DrawPanelText(Handle panel, const char[] text);

/**
 * Returns whether or not the given drawing flags are supported by
 * the menu style.
 *
 * @param panel         A MenuPanel Handle.
 * @param style         ITEMDRAW style flags.
 * @return              True if item is drawable, false otherwise.
 * @error               Invalid Handle.
 */
native bool CanPanelDrawFlags(Handle panel, int style);

/**
 * Sets the selectable key map of a panel.  This is not supported by
 * all styles (only by Radio, as of this writing).
 *
 * @param panel         A MenuPanel Handle.
 * @param keys          An integer where each bit N allows key
 *                      N+1 to be selected.  If no keys are selectable,
 *                      then key 0 (bit 9) is automatically set.
 * @return              True if supported, false otherwise.
 */
native bool SetPanelKeys(Handle panel, int keys);

/**
 * Sends a panel to a client.  Unlike full menus, the handler
 * function will only receive the following actions, both of
 * which will have INVALID_HANDLE for a menu, and the client
 * as param1.
 *
 * MenuAction_Select (param2 will be the key pressed)
 * MenuAction_Cancel (param2 will be the reason)
 *
 * Also, if the menu fails to display, no callbacks will be called.
 *
 * @param panel         A MenuPanel Handle.
 * @param client        A client to draw to.
 * @param handler       The MenuHandler function to catch actions with.
 * @param time          Time to hold the menu for.
 * @return              True on success, false on failure.
 * @error               Invalid Handle.
 */
native bool SendPanelToClient(Handle panel, int client, MenuHandler handler, int time);

/**
 * @brief Returns the amount of text the menu can still hold.  If this is
 * limit is reached or overflowed, the text is silently truncated.
 *
 * Radio menus: Currently 511 characters (512 bytes).
 * Valve menus: Currently -1 (no meaning).
 *
 * @param panel         A MenuPanel Handle.
 * @return              Number of characters that the menu can still hold,
 *                      or -1 if there is no known limit.
 * @error               Invalid Handle.
 */
native int GetPanelTextRemaining(Handle panel);

/**
 * @brief Returns the current key position.
 *
 * @param panel         A MenuPanel Handle.
 * @return              Current key position starting at 1.
 * @error               Invalid Handle.
 */
native int GetPanelCurrentKey(Handle panel);

/**
 * @brief Sets the next key position.  This cannot be used
 * to traverse backwards.
 *
 * @param panel         A MenuPanel Handle.
 * @param key           Key that is greater or equal to
 *                      GetPanelCurrentKey().
 * @return              True on success, false otherwise.
 * @error               Invalid Handle.
 */
native bool SetPanelCurrentKey(Handle panel, int key);

/**
 * @brief Redraws menu text from inside a MenuAction_DisplayItem callback.
 *
 * @param text          Menu text to draw.
 * @return              Item position; must be returned via the callback.
 */
native int RedrawMenuItem(const char[] text);

/**
 * This function is provided for legacy code only.  Some older plugins may use
 * network messages instead of the panel API.  This function wraps the panel
 * API for eased portability into the SourceMod menu system.
 *
 * This function is only usable with the Radio Menu style.  You do not need to
 * split up your menu into multiple packets; SourceMod will break the string
 * up internally.
 *
 * @param client        Client index.
 * @param str           Full menu string as would be passed over the network.
 * @param time          Time to hold the menu for.
 * @param keys          Selectable key bitstring.
 * @param handler       Optional handler function, with the same rules as
 *                      SendPanelToClient().
 * @return              True on success, false on failure.
 * @error               Invalid client index, or radio menus not supported.
 */
native bool InternalShowMenu(int client, const char[] str, int time, int keys=-1, MenuHandler handler=INVALID_FUNCTION);

/**
 * Retrieves voting information from MenuAction_VoteEnd.
 *
 * @param param2        Second parameter of MenuAction_VoteEnd.
 * @param winningVotes  Number of votes received by the winning option.
 * @param totalVotes    Number of total votes received.
 */
stock void GetMenuVoteInfo(int param2, int &winningVotes, int &totalVotes)
{
	winningVotes = param2 & 0xFFFF;
	totalVotes = param2 >> 16;
}

/**
 * Quick stock to determine whether voting is allowed.  This doesn't let you
 * fine-tune a reason for not voting, so it's not recommended for lazily
 * telling clients that voting isn't allowed.
 *
 * @return              True if voting is allowed, false if voting is in progress
 *                      or the cooldown is active.
 */
stock bool IsNewVoteAllowed()
{
	if (IsVoteInProgress() || CheckVoteDelay() != 0)
	{
		return false;
	}

	return true;
}
/**
 * vim: set ts=4 sw=4 tw=99 noet :
 * =============================================================================
 * SourceMod (C)2004-2014 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */
 
#if defined _adt_trie_included
 #endinput
#endif
#define _adt_trie_included

/* Object-oriented wrapper for maps. */
methodmap StringMap < Handle
{
	// Creates a hash map. A hash map is a container that can map strings (called
	// "keys") to arbitrary values (cells, arrays, or strings). Keys in a hash map
	// are unique. That is, there is at most one entry in the map for a given key.
	//
	// Insertion, deletion, and lookup in a hash map are all considered to be fast
	// operations, amortized to O(1), or constant time.
	//
	// The word "Trie" in this API is historical. As of SourceMod 1.6, tries have
	// been internally replaced with hash tables, which have O(1) insertion time
	// instead of O(n).
	//
	// The StringMap must be freed via delete or CloseHandle().
	public native StringMap();

	// Sets a value in a hash map, either inserting a new entry or replacing an old one.
	//
	// @param key        Key string.
	// @param value      Value to store at this key.
	// @param replace    If false, operation will fail if the key is already set.
	// @return           True on success, false on failure.
	public native bool SetValue(const char[] key, any value, bool replace=true);

	// Sets an array value in a Map, either inserting a new entry or replacing an old one.
	//
	// @param key        Key string.
	// @param array      Array to store.
	// @param num_items  Number of items in the array.
	// @param replace    If false, operation will fail if the key is already set.
	// @return           True on success, false on failure.
	public native bool SetArray(const char[] key, const any[] array, int num_items, bool replace=true);

	// Sets a string value in a Map, either inserting a new entry or replacing an old one.
	//
	// @param key        Key string.
	// @param value      String to store.
	// @param replace    If false, operation will fail if the key is already set.
	// @return           True on success, false on failure.
	public native bool SetString(const char[] key, const char[] value, bool replace=true);

	// Retrieves a value in a Map.
	//
	// @param key        Key string.
	// @param value      Variable to store value.
	// @return           True on success.  False if the key is not set, or the key is set 
	//                   as an array or string (not a value).
	public native bool GetValue(const char[] key, any &value);

	// Retrieves an array in a Map.
	//
	// @param map        Map Handle.
	// @param key        Key string.
	// @param array      Buffer to store array.
	// @param max_size   Maximum size of array buffer.
	// @param size       Optional parameter to store the number of elements written to the buffer.
	// @return           True on success.  False if the key is not set, or the key is set 
	//                   as a value or string (not an array).
	public native bool GetArray(const char[] key, any[] array, int max_size, int &size=0);

	// Retrieves a string in a Map.
	//
	// @param key        Key string.
	// @param value      Buffer to store value.
	// @param max_size   Maximum size of string buffer.
	// @param size       Optional parameter to store the number of bytes written to the buffer.
	// @return           True on success.  False if the key is not set, or the key is set 
	//                   as a value or array (not a string).
	public native bool GetString(const char[] key, char[] value, int max_size, int &size=0);

	// Removes a key entry from a Map.
	//
	// @param key        Key string.
	// @return           True on success, false if the value was never set.
	public native bool Remove(const char[] key);

	// Clears all entries from a Map.
	public native void Clear();

	// Create a snapshot of the map's keys. See StringMapSnapshot.
	public native StringMapSnapshot Snapshot();

	// Retrieves the number of elements in a map.
	property int Size {
		public native get();
	}
};

/**
 * A StringMapSnapshot is created via StringMap.Snapshot(). It captures the
 * keys on a map so they can be read. Snapshots must be freed with delete or
 * CloseHandle().
 */
methodmap StringMapSnapshot < Handle
{
	// Returns the number of keys in the map snapshot.
	property int Length {
		public native get();
	}

	// Returns the buffer size required to store a given key. That is, it
	// returns the length of the key plus one.
	// 
	// @param index     Key index (starting from 0).
	// @return          Buffer size required to store the key string.
	// @error           Index out of range.
	public native int KeyBufferSize(int index);

	// Retrieves the key string of a given key in a map snapshot.
	// 
	// @param index      Key index (starting from 0).
	// @param buffer     String buffer.
	// @param maxlength  Maximum buffer length.
	// @return           Number of bytes written to the buffer.
	// @error            Index out of range.
	public native int GetKey(int index, char[] buffer, int maxlength);
};

/**
 * Creates a hash map. A hash map is a container that can map strings (called
 * "keys") to arbitrary values (cells, arrays, or strings). Keys in a hash map
 * are unique. That is, there is at most one entry in the map for a given key.
 *
 * Insertion, deletion, and lookup in a hash map are all considered to be fast
 * operations, amortized to O(1), or constant time.
 *
 * The word "Trie" in this API is historical. As of SourceMod 1.6, tries have
 * been internally replaced with hash tables, which have O(1) insertion time
 * instead of O(n).
 *
 * @return              New Map Handle, which must be freed via CloseHandle().
 */
native StringMap CreateTrie();

/**
 * Sets a value in a hash map, either inserting a new entry or replacing an old one.
 *
 * @param map           Map Handle.
 * @param key           Key string.
 * @param value         Value to store at this key.
 * @param replace       If false, operation will fail if the key is already set.
 * @return              True on success, false on failure.
 * @error               Invalid Handle.
 */
native bool SetTrieValue(Handle map, const char[] key, any value, bool replace=true);

/**
 * Sets an array value in a Map, either inserting a new entry or replacing an old one.
 *
 * @param map           Map Handle.
 * @param key           Key string.
 * @param array         Array to store.
 * @param num_items     Number of items in the array.
 * @param replace       If false, operation will fail if the key is already set.
 * @return              True on success, false on failure.
 * @error               Invalid Handle.
 */
native bool SetTrieArray(Handle map, const char[] key, const any[] array, int num_items, bool replace=true);

/**
 * Sets a string value in a Map, either inserting a new entry or replacing an old one.
 *
 * @param map           Map Handle.
 * @param key           Key string.
 * @param value         String to store.
 * @param replace       If false, operation will fail if the key is already set.
 * @return              True on success, false on failure.
 * @error               Invalid Handle.
 */
native bool SetTrieString(Handle map, const char[] key, const char[] value, bool replace=true);

/**
 * Retrieves a value in a Map.
 *
 * @param map           Map Handle.
 * @param key           Key string.
 * @param value         Variable to store value.
 * @return              True on success.  False if the key is not set, or the key is set 
 *                      as an array or string (not a value).
 * @error               Invalid Handle.
 */
native bool GetTrieValue(Handle map, const char[] key, any &value);

/**
 * Retrieves an array in a Map.
 *
 * @param map           Map Handle.
 * @param key           Key string.
 * @param array         Buffer to store array.
 * @param max_size      Maximum size of array buffer.
 * @param size          Optional parameter to store the number of elements written to the buffer.
 * @return              True on success.  False if the key is not set, or the key is set 
 *                      as a value or string (not an array).
 * @error               Invalid Handle.
 */
native bool GetTrieArray(Handle map, const char[] key, any[] array, int max_size, int &size=0);

/**
 * Retrieves a string in a Map.
 *
 * @param map           Map Handle.
 * @param key           Key string.
 * @param value         Buffer to store value.
 * @param max_size      Maximum size of string buffer.
 * @param size          Optional parameter to store the number of bytes written to the buffer.
 * @return              True on success.  False if the key is not set, or the key is set 
 *                      as a value or array (not a string).
 * @error               Invalid Handle.
 */
native bool GetTrieString(Handle map, const char[] key, char[] value, int max_size, int &size=0);

/**
 * Removes a key entry from a Map.
 *
 * @param map           Map Handle.
 * @param key           Key string.
 * @return              True on success, false if the value was never set.
 * @error               Invalid Handle.
 */
native bool RemoveFromTrie(Handle map, const char[] key);

/**
 * Clears all entries from a Map.
 *
 * @param map           Map Handle.
 * @error               Invalid Handle.
 */
native void ClearTrie(Handle map);

/**
 * Retrieves the number of elements in a map.
 *
 * @param map           Map Handle.
 * @return              Number of elements in the trie.
 * @error               Invalid Handle.
 */
native int GetTrieSize(Handle map);

/**
 * Creates a snapshot of all keys in the map. If the map is changed after this
 * call, the changes are not reflected in the snapshot. Keys are not sorted.
 *
 * @param map           Map Handle.
 * @return              New Map Snapshot Handle, which must be closed via CloseHandle().
 * @error               Invalid Handle.
 */
native Handle CreateTrieSnapshot(Handle map);

/**
 * Returns the number of keys in a map snapshot. Note that this may be
 * different from the size of the map, since the map can change after the
 * snapshot of its keys was taken.
 *
 * @param snapshot      Map snapshot.
 * @return              Number of keys.
 * @error               Invalid Handle.
 */
native int TrieSnapshotLength(Handle snapshot);

/**
 * Returns the buffer size required to store a given key. That is, it returns
 * the length of the key plus one.
 *
 * @param snapshot      Map snapshot.
 * @param index         Key index (starting from 0).
 * @return              Buffer size required to store the key string.
 * @error               Invalid Handle or index out of range.
 */
native int TrieSnapshotKeyBufferSize(Handle snapshot, int index);

/**
 * Retrieves the key string of a given key in a map snapshot.
 *
 * @param snapshot      Map snapshot.
 * @param index         Key index (starting from 0).
 * @param buffer        String buffer.
 * @param maxlength     Maximum buffer length.
 * @return              Number of bytes written to the buffer.
 * @error               Invalid Handle or index out of range.
 */
native int GetTrieSnapshotKey(Handle snapshot, int index, char[] buffer, int maxlength);
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _console_included
 #endinput
#endif
#define _console_included

#define INVALID_FCVAR_FLAGS (-1)

/**
 * Console variable query helper values.
 */
enum QueryCookie
{
	QUERYCOOKIE_FAILED = 0
};

/**
 * Reply sources for commands.
 */
enum ReplySource
{
	SM_REPLY_TO_CONSOLE = 0,
	SM_REPLY_TO_CHAT = 1
};

/**
 * @section Flags for console commands and console variables.  The descriptions 
 * for each constant come directly from the Source SDK.
 */

#pragma deprecated No logic using this flag ever existed in a released game. It only ever appeared in the first hl2sdk.
#define FCVAR_PLUGIN           0       // Actual value is same as FCVAR_SS_ADDED in Left 4 Dead and later.
#pragma deprecated Did you mean FCVAR_DEVELOPMENTONLY? (No logic using this flag ever existed in a released game. It only ever appeared in the first hl2sdk.)
#define FCVAR_LAUNCHER         (1<<1)  // Same value as FCVAR_DEVELOPMENTONLY, which is what most usages of this were intending to use.


#define FCVAR_NONE                      0      // The default, no flags at all
#define FCVAR_UNREGISTERED             (1<<0)  // If this is set, don't add to linked list, etc.
#define FCVAR_DEVELOPMENTONLY          (1<<1)  // Hidden in released products. Flag is removed automatically if ALLOW_DEVELOPMENT_CVARS is defined. (OB+)
#define FCVAR_GAMEDLL                  (1<<2)  // Defined by the game DLL.
#define FCVAR_CLIENTDLL                (1<<3)  // Defined by the client DLL.
#define FCVAR_MATERIAL_SYSTEM          (1<<4)  // Defined by the material system. (EP1-only)
#define FCVAR_HIDDEN                   (1<<4)  // Hidden. Doesn't appear in find or autocomplete. Like DEVELOPMENTONLY, but can't be compiled out.1 (OB+)
#define FCVAR_PROTECTED                (1<<5)  // It's a server cvar, but we don't send the data since it's a password, etc.
                                       // Sends 1 if it's not bland/zero, 0 otherwise as value.
#define FCVAR_SPONLY                   (1<<6)  // This cvar cannot be changed by clients connected to a multiplayer server.
#define FCVAR_ARCHIVE                  (1<<7)  // Set to cause it to be saved to vars.rc
#define FCVAR_NOTIFY                   (1<<8)  // Notifies players when changed.
#define FCVAR_USERINFO                 (1<<9)  // Changes the client's info string.
#define FCVAR_PRINTABLEONLY            (1<<10) // This cvar's string cannot contain unprintable characters (e.g., used for player name, etc.)
#define FCVAR_UNLOGGED                 (1<<11) // If this is a FCVAR_SERVER, don't log changes to the log file / console if we are creating a log
#define FCVAR_NEVER_AS_STRING          (1<<12) // Never try to print that cvar.
#define FCVAR_REPLICATED               (1<<13) // Server setting enforced on clients.
#define FCVAR_CHEAT                    (1<<14) // Only useable in singleplayer / debug / multiplayer & sv_cheats
#define FCVAR_SS                       (1<<15) // causes varnameN where N  2 through max splitscreen slots for mod to be autogenerated (L4D+)
#define FCVAR_DEMO                     (1<<16) // Record this cvar when starting a demo file.
#define FCVAR_DONTRECORD               (1<<17) // Don't record these command in demo files.
#define FCVAR_SS_ADDED                 (1<<18) // This is one of the "added" FCVAR_SS variables for the splitscreen players (L4D+)
#define FCVAR_RELEASE                  (1<<19) // Cvars tagged with this are the only cvars available to customers (L4D+)
#define FCVAR_RELOAD_MATERIALS         (1<<20) // If this cvar changes, it forces a material reload (OB+)
#define FCVAR_RELOAD_TEXTURES          (1<<21) // If this cvar changes, if forces a texture reload (OB+)
#define FCVAR_NOT_CONNECTED            (1<<22) // Cvar cannot be changed by a client that is connected to a server.
#define FCVAR_MATERIAL_SYSTEM_THREAD   (1<<23) // Indicates this cvar is read from the material system thread (OB+)
#define FCVAR_ARCHIVE_XBOX             (1<<24) // Cvar written to config.cfg on the Xbox.
#define FCVAR_ARCHIVE_GAMECONSOLE      (1<<24) // Cvar written to config.cfg on the Xbox.
#define FCVAR_ACCESSIBLE_FROM_THREADS  (1<<25) // used as a debugging tool necessary to check material system thread convars (OB+)
#define FCVAR_SERVER_CAN_EXECUTE       (1<<28) // the server is allowed to execute this command on clients via
                                                   // ClientCommand/NET_StringCmd/CBaseClientState::ProcessStringCmd. (OB+)
#define FCVAR_SERVER_CANNOT_QUERY      (1<<29) // If this is set, then the server is not allowed to query this cvar's value (via
                                                   // IServerPluginHelpers::StartQueryCvarValue).
#define FCVAR_CLIENTCMD_CAN_EXECUTE    (1<<30) // IVEngineClient::ClientCmd is allowed to execute this command. 
                                                   // Note: IVEngineClient::ClientCmd_Unrestricted can run any client command.

/**
 * @endsection
 */

/**
 * Executes a server command as if it were on the server console (or RCON)
 *
 * @param format        Formatting rules.
 * @param ...           Variable number of format parameters.
 */
native void ServerCommand(const char[] format, any ...);

/**
 * Executes a server command as if it were on the server console (or RCON) 
 * and stores the printed text into buffer.
 *
 * Warning: This calls ServerExecute internally and may have issues if
 * certain commands are in the buffer, only use when you really need
 * the response.
 * Also, on L4D2 this will not print the command output to the server console.
 *
 * @param buffer        String to store command result into.
 * @param maxlen        Length of buffer.
 * @param format        Formatting rules.
 * @param ...           Variable number of format parameters.
 */
native void ServerCommandEx(char[] buffer, int maxlen, const char[] format, any ...);

/**
 * Inserts a server command at the beginning of the server command buffer.
 *
 * @param format        Formatting rules.
 * @param ...           Variable number of format parameters.
 */
native void InsertServerCommand(const char[] format, any ...);

/**
 * Executes every command in the server's command buffer, rather than once per frame.
 */
native void ServerExecute();

/**
 * Executes a client command.  Note that this will not work on clients unless
 * they have cl_restrict_server_commands set to 0.
 *
 * @param client        Index of the client.
 * @param fmt           Format of the client command.
 * @param ...           Format parameters
 * @error               Invalid client index, or client not connected.
 */
native void ClientCommand(int client, const char[] fmt, any ...);

/**
 * Executes a client command on the server without being networked.
 *
 * FakeClientCommand() overwrites the command tokenization buffer.  This can 
 * cause undesired effects because future calls to GetCmdArg* will return 
 * data from the FakeClientCommand(), not the parent command.  If you are in 
 * a hook where this matters (for example, a "say" hook), you should use 
 * FakeClientCommandEx() instead.
 *
 * @param client        Index of the client.
 * @param fmt           Format of the client command.
 * @param ...           Format parameters
 * @error               Invalid client index, or client not connected.
 */
native void FakeClientCommand(int client, const char[] fmt, any ...);

/**
 * Executes a client command on the server without being networked.  The 
 * execution of the client command is delayed by one frame to prevent any 
 * re-entrancy issues that might surface with FakeClientCommand().
 *
 * @param client        Index of the client.
 * @param fmt           Format of the client command.
 * @param ...           Format parameters
 * @error               Invalid client index, or client not connected.
 */
native void FakeClientCommandEx(int client, const char[] fmt, any ...);

/**
 * Executes a KeyValues client command on the server without being networked.
 *
 * @param client        Index of the client.
 * @param kv            KeyValues data to be sent.
 * @error               Invalid client index, client not connected,
 *                      or unsupported on current game.
 */
native void FakeClientCommandKeyValues(int client, KeyValues kv);

/**
 * Sends a message to the server console.
 *
 * @param format        Formatting rules.
 * @param ...           Variable number of format parameters.
 */
native void PrintToServer(const char[] format, any ...);

/**
 * Sends a message to a client's console.
 *
 * @param client        Client index.
 * @param format        Formatting rules.
 * @param ...           Variable number of format parameters.
 * @error               If the client is not connected an error will be thrown.
 */
native void PrintToConsole(int client, const char[] format, any ...);


/**
 * Sends a message to every client's console.
 *
 * @param format        Formatting rules.
 * @param ...           Variable number of format parameters.
 */
stock void PrintToConsoleAll(const char[] format, any ...)
{
	char buffer[254];
	
	for (int i = 1; i <= MaxClients; i++)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, sizeof(buffer), format, 2);
			PrintToConsole(i, "%s", buffer);
		}
	}
}

/**
 * Replies to a message in a command.
 *
 * A client index of 0 will use PrintToServer().
 * If the command was from the console, PrintToConsole() is used.
 * If the command was from chat, PrintToChat() is used.
 *
 * @param client        Client index, or 0 for server.
 * @param format        Formatting rules.
 * @param ...           Variable number of format parameters.
 * @error               If the client is not connected or invalid.
 */
native void ReplyToCommand(int client, const char[] format, any ...);

/**
 * Returns the current reply source of a command.
 *
 * @return              ReplySource value.
 */
native ReplySource GetCmdReplySource();

/**
 * Sets the current reply source of a command.
 *
 * Only use this if you know what you are doing.  You should save the old value
 * and restore it once you are done.
 *
 * @param source        New ReplySource value.
 * @return              Old ReplySource value.
 */
native ReplySource SetCmdReplySource(ReplySource source);

/**
 * Returns whether the current say hook is a chat trigger.
 *
 * This function is only meaningful inside say or say_team hooks.
 *
 * @return              True if a chat trigger, false otherwise.
 */
native bool IsChatTrigger();

/**
 * Displays usage of an admin command to users depending on the 
 * setting of the sm_show_activity cvar.  All users receive a message 
 * in their chat text, except for the originating client, who receives 
 * the message based on the current ReplySource.
 *
 * @param client        Client index doing the action, or 0 for server.
 * @param tag           Tag to prepend to the message.
 * @param format        Formatting rules.
 * @param ...           Variable number of format parameters.
 * @error
 */
native void ShowActivity2(int client, const char[] tag, const char[] format, any ...);

/**
 * Displays usage of an admin command to users depending on the 
 * setting of the sm_show_activity cvar.  
 *
 * This version does not display a message to the originating client 
 * if used from chat triggers or menus.  If manual replies are used 
 * for these cases, then this function will suffice.  Otherwise, 
 * ShowActivity2() is slightly more useful.
 *
 * @param client        Client index doing the action, or 0 for server.
 * @param format        Formatting rules.
 * @param ...           Variable number of format parameters.
 * @error
 */
native void ShowActivity(int client, const char[] format, any ...);

/**
 * Same as ShowActivity(), except the tag parameter is used instead of
 * "[SM] " (note that you must supply any spacing).
 *
 * @param client        Client index doing the action, or 0 for server.
 * @param tag           Tag to display with.
 * @param format        Formatting rules.
 * @param ...           Variable number of format parameters.
 * @error
 */
native void ShowActivityEx(int client, const char[] tag, const char[] format, any ...);

/**
 * Given an originating client and a target client, returns the string 
 * that describes the originating client according to the sm_show_activity cvar.
 *
 * For example, "ADMIN", "PLAYER", or a player's name could be placed in this buffer.
 *
 * @param client        Originating client; may be 0 for server console.
 * @param target        Targeted client.
 * @param namebuf       Name buffer.
 * @param maxlength     Maximum size of the name buffer.
 * @return              True if activity should be shown.  False otherwise.  In either 
 *                      case, the name buffer is filled.  The return value can be used 
 *                      to broadcast a "safe" name to all players regardless of the 
 *                      sm_show_activity filters.
 * @error               Invalid client index or client not connected.
 */
native bool FormatActivitySource(int client, int target, const char[] namebuf, int maxlength);

/**
 * Called when a server-only command is invoked.  
 *
 * @param args          Number of arguments that were in the argument string.
 * @return              An Action value.  Not handling the command
 *                      means that Source will report it as "not found."
 */
typedef SrvCmd = function Action (int args);

/**
 * Creates a server-only console command, or hooks an already existing one.  
 *
 * Server commands are case sensitive.
 *
 * @param cmd           Name of the command to hook or create.
 * @param callback      A function to use as a callback for when the command is invoked.
 * @param description   Optional description to use for command creation.
 * @param flags         Optional flags to use for command creation.
 * @error               Command name is the same as an existing convar.
 */
native void RegServerCmd(const char[] cmd, SrvCmd callback, const char[] description="", int flags=0);

/**
 * Called when a generic console command is invoked.
 *
 * @param client        Index of the client, or 0 from the server.
 * @param args          Number of arguments that were in the argument string.
 * @return              An Action value.  Not handling the command
 *                      means that Source will report it as "not found."
 */
typedef ConCmd = function Action (int client, int args);

/**
 * Creates a console command, or hooks an already existing one.
 *
 * Console commands are case sensitive.  However, if the command already exists in the game, 
 * a client may enter the command in any case.  SourceMod corrects for this automatically, 
 * and you should only hook the "real" version of the command.
 *
 * @param cmd           Name of the command to hook or create.
 * @param callback      A function to use as a callback for when the command is invoked.
 * @param description   Optional description to use for command creation.
 * @param flags         Optional flags to use for command creation.
 * @error               Command name is the same as an existing convar.
 */
native void RegConsoleCmd(const char[] cmd, ConCmd callback, const char[] description="", int flags=0);

/**
 * Creates a console command as an administrative command.  If the command does not exist,
 * it is created.  When this command is invoked, the access rights of the player are 
 * automatically checked before allowing it to continue.
 *
 * Admin commands are case sensitive from both the client and server.
 *
 * @param cmd           String containing command to register.
 * @param callback      A function to use as a callback for when the command is invoked.
 * @param adminflags    Administrative flags (bitstring) to use for permissions.
 * @param description   Optional description to use for help.
 * @param group         String containing the command group to use.  If empty,
 *                      the plugin's filename will be used instead.
 * @param flags         Optional console flags.
 * @error               Command name is the same as an existing convar.
 */
native void RegAdminCmd(const char[] cmd,
					ConCmd callback,
					int adminflags,
					const char[] description="",
					const char[] group="",
					int flags=0);
					
/**
 * Returns the number of arguments from the current console or server command.
 * @note Unlike the HL2 engine call, this does not include the command itself.
 *
 * @return              Number of arguments to the current command.
 */
native int GetCmdArgs();

/**
 * Retrieves a command argument given its index, from the current console or 
 * server command.
 * @note Argument indexes start at 1; 0 retrieves the command name.
 *
 * @param argnum        Argument number to retrieve.
 * @param buffer        Buffer to use for storing the string.
 * @param maxlength     Maximum length of the buffer.
 * @return              Length of string written to buffer.
 */
native int GetCmdArg(int argnum, char[] buffer, int maxlength);

/**
 * Retrieves the entire command argument string in one lump from the current 
 * console or server command.
 *
 * @param buffer        Buffer to use for storing the string.
 * @param maxlength     Maximum length of the buffer.
 * @return              Length of string written to buffer.
 */
native int GetCmdArgString(char[] buffer, int maxlength);

methodmap CommandIterator < Handle {
	// Creates a new CommandIterator. Must be freed with delete or
	// CloseHandle().
	//
	// The CommandIterator can be used to iterate commands created by
	// SourceMod plugins and allows inspection of properties associated
	// with the command.
	// 
	// @return              New CommandIterator Handle.
	public native CommandIterator();

	// Determines if there is a next command. If one is found, the
	// iterator is advanced to it.
	//
	// @return              true if found and iterator is advanced.
	public native bool Next();

	// Retrieves the command's description.
	//
	// @param buffer        Buffer to copy to.
	// @param maxlen        Maximum size of the buffer.
	// @error               Invalid iterator position.
	public native void GetDescription(char[] buffer, int maxlen);

	// Retrieves the command's name.
	//
	// @param buffer        Buffer to copy to.
	// @param maxlen        Maximum size of the buffer.
	// @error               Invalid iterator position.
	public native void GetName(char[] buffer, int maxlen);

	// Retrieves the plugin handle of the command's creator
	//
	// @error               Invalid iterator position.
	property Handle Plugin {
		public native get();
	}

	// Retrieves the command's default flags
	//
	// @error                Invalid iterator position.
	property int Flags {
		public native get();
	}
}

/**
 * Gets a command iterator.  Must be freed with CloseHandle().
 *
 * @return              A new command iterator.
 */
native Handle GetCommandIterator();

/**
 * Reads a command iterator, then advances to the next command if any.
 * Only SourceMod specific commands are returned.
 *
 * @param iter          Command iterator Handle.
 * @param name          Name buffer.
 * @param nameLen       Name buffer size.
 * @param eflags        Effective default flags of a command.
 * @param desc          Command description buffer.
 * @param descLen       Command description buffer size.
 * @return              True on success, false if there are no more commands.
 */
native bool ReadCommandIterator(Handle iter, 
								char[] name, 
								int nameLen, 
								int &eflags=0, 
								char[] desc="", 
								int descLen=0);

/**
 * Returns whether a client has access to a given command string.  The string 
 * can be any override string, as overrides can be independent of 
 * commands.  This feature essentially allows you to create custom 
 * flags using the override system.
 *
 * @param client        Client index.
 * @param command       Command name.  If the command is not found, the default 
 *                      flags are used.
 * @param flags         Flag string to use as a default, if the command or override 
 *                      is not found.
 * @param override_only If true, SourceMod will not attempt to find a matching 
 *                      command, and it will only use the default flags specified.
 *                      Otherwise, SourceMod will ignore the default flags if 
 *                      there is a matching admin command.
 * @return              True if the client has access, false otherwise.
 */
native bool CheckCommandAccess(int client, 
							   const char[] command,
							   int flags,
							   bool override_only=false);

/**
 * Returns whether an admin has access to a given command string.  The string 
 * can be any override string, as overrides can be independent of 
 * commands.  This feature essentially allows you to create custom flags
 * using the override system.
 *
 * @param id            AdminId of the admin.
 * @param command       Command name.  If the command is not found, the default 
 *                      flags are used.
 * @param flags         Flag string to use as a default, if the command or override 
 *                      is not found.
 * @param override_only If true, SourceMod will not attempt to find a matching 
 *                      command, and it will only use the default flags specified.
 *                      Otherwise, SourceMod will ignore the default flags if 
 *                      there is a matching admin command.
 * @return              True if the admin has access, false otherwise.
 */
native bool CheckAccess(AdminId id, 
							   const char[] command,
							   int flags,
							   bool override_only=false);

/**
 * Returns the bitstring of flags of a command.
 *
 * @param name          Name of the command.
 * @return              A bitstring containing the FCVAR_* flags that are enabled 
 *                      or INVALID_FCVAR_FLAGS if command not found.
 */
native int GetCommandFlags(const char[] name);

/**
 * Sets the bitstring of flags of a command.
 *
 * @param name          Name of the command.
 * @param flags         A bitstring containing the FCVAR_* flags to enable.
 * @return              True on success, otherwise false.
 */
native bool SetCommandFlags(const char[] name, int flags);

/**
 * Starts a ConCommandBase search, traversing the list of ConVars and 
 * ConCommands.  If a Handle is returned, the next entry must be read 
 * via FindNextConCommand().  The order of the list is undefined.
 *
 * @param buffer        Buffer to store entry name.
 * @param max_size      Maximum size of the buffer.
 * @param isCommand     Variable to store whether the entry is a command. 
 *                      If it is not a command, it is a ConVar.
 * @param flags         Variable to store entry flags.
 * @param description   Buffer to store the description, empty if no description present.
 * @param descrmax_size Maximum size of the description buffer.
 * @return              On success, a ConCmdIter Handle is returned, which 
                        can be read via FindNextConCommand(), and must be 
                        closed via CloseHandle().  Additionally, the output 
                        parameters will be filled with information of the 
                        first ConCommandBase entry.
                        On failure, INVALID_HANDLE is returned, and the 
                        contents of outputs is undefined.
 */
native Handle FindFirstConCommand(char[] buffer, int max_size, bool &isCommand, int &flags=0, char[] description="", int descrmax_size=0);

/**
 * Reads the next entry in a ConCommandBase iterator.
 *
 * @param search        ConCmdIter Handle to search.
 * @param buffer        Buffer to store entry name.
 * @param max_size      Maximum size of the buffer.
 * @param isCommand     Variable to store whether the entry is a command.
                        If it is not a command, it is a ConVar.
 * @param flags         Variable to store entry flags.
 * @param description   Buffer to store the description, empty if no description present.
 * @param descrmax_size Maximum size of the description buffer.
 * @return              On success, the outputs are filled, the iterator is 
                        advanced to the next entry, and true is returned.  
                        If no more entries exist, false is returned, and the 
                        contents of outputs is undefined.
 */
native bool FindNextConCommand(Handle search, char[] buffer, int max_size, bool &isCommand, int &flags=0, char[] description="", int descrmax_size=0);

/**
 * Adds an informational string to the server's public "tags".
 * This string should be a short, unique identifier.
 *
 * Note: Tags are automatically removed when a plugin unloads.
 * Note: Currently, this function does nothing because of bugs in the Valve master.
 *
 * @param tag           Tag string to append.
 */
native void AddServerTag(const char[] tag);

/**
 * Removes a tag previously added by the calling plugin.
 *
 * @param tag           Tag string to remove.
 */
native void RemoveServerTag(const char[] tag);

/**
 * Callback for command listeners. This is invoked whenever any command
 * reaches the server, from the server console itself or a player.
 *
 * Clients may be in the process of connecting when they are executing commands
 * IsClientConnected(client) is not guaranteed to return true.  Other functions
 * such as GetClientIP() may not work at this point either.
 *
 * Returning Plugin_Handled or Plugin_Stop will prevent the original,
 * baseline code from running.
 *
 * -- TEXT BELOW IS IMPLEMENTATION, AND NOT GUARANTEED --
 * Even if returning Plugin_Handled or Plugin_Stop, some callbacks will still
 * trigger. These are:
 *  * C++ command dispatch hooks from Metamod:Source plugins
 *  * Reg*Cmd() hooks that did not create new commands.
 *
 * @param client        Client, or 0 for server.
 *                      Client may not be connected or in game.
 * @param command       Command name, lower case. To get name as typed, use
 *                      GetCmdArg() and specify argument 0.
 * @param argc          Argument count.
 * @return              Action to take (see extended notes above).
 */
typedef CommandListener = function Action (int client, const char[] command, int argc);

#define FEATURECAP_COMMANDLISTENER  "command listener"

/**
 * Adds a callback that will fire when a command is sent to the server.
 *
 * Registering commands is designed to create a new command as part of the UI,
 * whereas this is a lightweight hook on a command string, existing or not.
 * Using Reg*Cmd to intercept is in poor practice, as it physically creates a
 * new command and can slow down dispatch in general.
 *
 * To see if this feature is available, use FeatureType_Capability and 
 * FEATURECAP_COMMANDLISTENER.
 *
 * @param callback      Callback.
 * @param command       Command, or if not specified, a global listener.
 *                      The command is case insensitive.
 * @return              True if this feature is available on the current game,
 *                      false otherwise.
 */
native bool AddCommandListener(CommandListener callback, const char[] command="");

/**
 * Removes a previously added command listener, in reverse order of being added.
 *
 * @param callback      Callback.
 * @param command       Command, or if not specified, a global listener.
 *                      The command is case insensitive.
 * @error               Callback has no active listeners.
 */
native void RemoveCommandListener(CommandListener callback, const char[] command="");

/**
 * Returns true if the supplied command exists.
 *
 * @param command       Command to find.
 * @return              True if command is found, false otherwise.
 */
stock bool CommandExists(const char[] command)
{
	return (GetCommandFlags(command) != INVALID_FCVAR_FLAGS);
}
/**
 * Global listener for the chat commands.
 *
 * @param client        Client index.
 * @param command       Command name.
 * @param sArgs         Chat argument string.
 * 
 * @return              An Action value. Returning Plugin_Handled bypasses the game function call.
 *                      Returning Plugin_Stop bypasses the post hook as well as the game function.
 */
forward Action OnClientSayCommand(int client, const char[] command, const char[] sArgs);

/**
 * Global post listener for the chat commands.
 *
 * @param client        Client index.
 * @param command       Command name.
 * @param sArgs         Chat argument string.
 */
forward void OnClientSayCommand_Post(int client, const char[] command, const char[] sArgs);
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */
 
#if defined _adminmenu_included
 #endinput
#endif
#define _adminmenu_included

/* Decide whether topmenus should be required */
#if !defined REQUIRE_PLUGIN
 #if defined REQUIRE_EXTENSIONS
  #define TEMP_REQUIRE_EXTENSIONS
  #undef REQUIRE_EXTENSIONS
 #endif
#endif

#include <topmenus>

/* Restore old REQUIRE_EXTENSIONS value if necessary */
#if defined TEMP_REQUIRE_EXTENSIONS
 #define REQUIRE_EXTENSIONS
 #undef TEMP_REQUIRE_EXTENSIONS
#endif

/** Category for player commands. */
#define ADMINMENU_PLAYERCOMMANDS        "PlayerCommands"
/** Category for server commands. */
#define ADMINMENU_SERVERCOMMANDS        "ServerCommands"
/** Category for voting commands. */
#define ADMINMENU_VOTINGCOMMANDS        "VotingCommands"

/**
 * Called when the admin menu is created and 3rd party plugins can grab 
 * the Handle or add categories.
 * 
 * @param topmenu       Handle to the admin menu's TopMenu.
 */
forward void OnAdminMenuCreated(Handle topmenu);

/**
 * Called when the admin menu is ready to have items added.
 * 
 * @param topmenu       Handle to the admin menu's TopMenu.
 */
forward void OnAdminMenuReady(Handle topmenu);

/**
 * Retrieves the Handle to the admin top menu.
 *
 * @return              Handle to the admin menu's TopMenu,
 *                      or INVALID_HANDLE if not created yet.
 */
native TopMenu GetAdminTopMenu();

/**
 * Adds targets to an admin menu.
 *
 * Each client is displayed as: name (userid)
 * Each item contains the userid as a string for its info.
 *
 * @param menu          Menu Handle.
 * @param source_client Source client, or 0 to ignore immunity.
 * @param in_game_only  True to only select in-game players.
 * @param alive_only    True to only select alive players.
 * @return              Number of clients added.
 */
native int AddTargetsToMenu(Handle menu, 
							int source_client, 
							bool in_game_only=true, 
							bool alive_only=false);

/**
 * Adds targets to an admin menu.
 *
 * Each client is displayed as: name (userid)
 * Each item contains the userid as a string for its info.
 *
 * @param menu          Menu Handle.
 * @param source_client Source client, or 0 to ignore immunity.
 * @param flags         COMMAND_FILTER flags from commandfilters.inc.
 * @return              Number of clients added.
 */
native int AddTargetsToMenu2(Handle menu, int source_client, int flags);

/**
 * Re-displays the admin menu to a client after selecting an item.
 * Auto-aborts if the Handle is invalid.
 *
 * @param topmenu       TopMenu Handle.
 * @param client        Client index.
 * @return              True on success, false on failure.
 */
stock bool RedisplayAdminMenu(Handle topmenu, int client)
{
	if (topmenu == INVALID_HANDLE)
	{
		return false;
	}

	return DisplayTopMenu(topmenu, client, TopMenuPosition_LastCategory);
}

/* DO NOT EDIT BELOW THIS LINE */

public SharedPlugin __pl_adminmenu = 
{
	name = "adminmenu",
	file = "adminmenu.smx",
#if defined REQUIRE_PLUGIN
	required = 1,
#else
	required = 0,
#endif
};

#if !defined REQUIRE_PLUGIN
public void __pl_adminmenu_SetNTVOptional()
{
	MarkNativeAsOptional("GetAdminTopMenu");
	MarkNativeAsOptional("AddTargetsToMenu");
	MarkNativeAsOptional("AddTargetsToMenu2");
}
#endif
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _functions_included
 #endinput
#endif
#define _functions_included

#define SP_PARAMFLAG_BYREF  (1<<0)  /**< Internal use only. */

/**
 * Describes the various ways to pass parameters to functions or forwards.
 */
enum ParamType
{
	Param_Any           = 0,                            /**< Any data type can be pushed */
	Param_Cell          = (1<<1),                       /**< Only basic cells can be pushed */
	Param_Float         = (2<<1),                       /**< Only floats can be pushed */
	Param_String        = (3<<1)|SP_PARAMFLAG_BYREF,    /**< Only strings can be pushed */
	Param_Array         = (4<<1)|SP_PARAMFLAG_BYREF,    /**< Only arrays can be pushed */
	Param_VarArgs       = (5<<1),                       /**< Same as "..." in plugins, anything can be pushed, but it will always be byref */
	Param_CellByRef     = (1<<1)|SP_PARAMFLAG_BYREF,    /**< Only a cell by reference can be pushed */
	Param_FloatByRef    = (2<<1)|SP_PARAMFLAG_BYREF     /**< Only a float by reference can be pushed */
};

/**
 * Defines how a forward iterates through plugin functions.
 */
enum ExecType
{
	ET_Ignore   = 0,    /**< Ignore all return values, return 0 */
	ET_Single   = 1,    /**< Only return the last exec, ignore all others */
	ET_Event    = 2,    /**< Acts as an event with the Actions defined in core.inc, no mid-Stops allowed, returns highest */
	ET_Hook     = 3     /**< Acts as a hook with the Actions defined in core.inc, mid-Stops allowed, returns highest */
};

/**
 * @section Flags that are used with Call_PushArrayEx() and Call_PushStringEx()
 */

#define SM_PARAM_COPYBACK       (1<<0)      /**< Copy an array/reference back after call */

#define SM_PARAM_STRING_UTF8    (1<<0)      /**< String should be UTF-8 handled */
#define SM_PARAM_STRING_COPY    (1<<1)      /**< String should be copied into the plugin */
#define SM_PARAM_STRING_BINARY  (1<<2)      /**< Treat the string as a binary string */

/**
 * @endsection
 */

/**
 * @section Error codes
 */
#define SP_ERROR_NONE                   0   /**< No error occurred */
#define SP_ERROR_FILE_FORMAT            1   /**< File format unrecognized */
#define SP_ERROR_DECOMPRESSOR           2   /**< A decompressor was not found */
#define SP_ERROR_HEAPLOW                3   /**< Not enough space left on the heap */
#define SP_ERROR_PARAM                  4   /**< Invalid parameter or parameter type */
#define SP_ERROR_INVALID_ADDRESS        5   /**< A memory address was not valid */
#define SP_ERROR_NOT_FOUND              6   /**< The object in question was not found */
#define SP_ERROR_INDEX                  7   /**< Invalid index parameter */
#define SP_ERROR_STACKLOW               8   /**< Not enough space left on the stack */
#define SP_ERROR_NOTDEBUGGING           9   /**< Debug mode was not on or debug section not found */
#define SP_ERROR_INVALID_INSTRUCTION    10  /**< Invalid instruction was encountered */
#define SP_ERROR_MEMACCESS              11  /**< Invalid memory access */
#define SP_ERROR_STACKMIN               12  /**< Stack went beyond its minimum value */
#define SP_ERROR_HEAPMIN                13  /**< Heap went beyond its minimum value */
#define SP_ERROR_DIVIDE_BY_ZERO         14  /**< Division by zero */
#define SP_ERROR_ARRAY_BOUNDS           15  /**< Array index is out of bounds */
#define SP_ERROR_INSTRUCTION_PARAM      16  /**< Instruction had an invalid parameter */
#define SP_ERROR_STACKLEAK              17  /**< A native leaked an item on the stack */
#define SP_ERROR_HEAPLEAK               18  /**< A native leaked an item on the heap */
#define SP_ERROR_ARRAY_TOO_BIG          19  /**< A dynamic array is too big */
#define SP_ERROR_TRACKER_BOUNDS         20  /**< Tracker stack is out of bounds */
#define SP_ERROR_INVALID_NATIVE         21  /**< Native was pending or invalid */
#define SP_ERROR_PARAMS_MAX             22  /**< Maximum number of parameters reached */
#define SP_ERROR_NATIVE                 23  /**< Error originates from a native */
#define SP_ERROR_NOT_RUNNABLE           24  /**< Function or plugin is not runnable */
#define SP_ERROR_ABORTED                25  /**< Function call was aborted */

/**
 * @endsection
 */

methodmap GlobalForward < Handle {
	// Creates a global forward.
	//
	// @note The name used to create the forward is used as its public function in all target plugins.
	// @note This is ideal for global, static forwards that are never changed.
	// @note Global forwards cannot be cloned.
	// @note Use CloseHandle() to destroy these.
	//
	// @param name              Name of public function to use in forward.
	// @param type              Execution type to be used.
	// @param ...               Variable number of parameter types (up to 32).
	// @return                  Handle to new global forward.
	// @error                   More than 32 paramater types passed.
	public native GlobalForward(const char[] name, ExecType type, ParamType ...);

	// Returns the number of functions in a global or private forward's call list.
	property int FunctionCount {
		public native get();
	}
};

methodmap PrivateForward < GlobalForward {
	// Creates a private forward.
	//
	// @note No functions are automatically added. Use AddToForward() to do this.
	// @note Private forwards can be cloned.
	// @note Use CloseHandle() to destroy these.
	//
	// @param type          Execution type to be used.
	// @param ...           Variable number of parameter types (up to 32).
	// @return              Handle to new private forward.
	// @error               More than 32 paramater types passed.
	public native PrivateForward(ExecType type, ParamType ...);

	// Adds a function to a private forward's call list.
	//
	// @note Cannot be used during an incomplete call.
	//
	// @param plugin        Handle of the plugin that contains the function.
	//                      Pass INVALID_HANDLE to specify the calling plugin.
	// @param func          Function to add to forward.
	// @return              True on success, false otherwise.
	// @error               Invalid or corrupt private forward handle, invalid or corrupt plugin handle, or invalid function.
	public native bool AddFunction(Handle plugin, Function func);

	// Removes a function from a private forward's call list.
	//
	// @note Only removes one instance.
	// @note Functions will be removed automatically if their parent plugin is unloaded.
	//
	// @param plugin        Handle of the plugin that contains the function.
	//                      Pass INVALID_HANDLE to specify the calling plugin.
	// @param func          Function to remove from forward.
	// @return              True on success, false otherwise.
	// @error               Invalid or corrupt private forward handle, invalid or corrupt plugin handle, or invalid function.
	public native bool RemoveFunction(Handle plugin, Function func);

	// Removes all instances of a plugin from a private forward's call list.
	//
	// @note Functions will be removed automatically if their parent plugin is unloaded.
	//
	// @param plugin        Handle of the plugin to remove instances of.
	//                      Pass INVALID_HANDLE to specify the calling plugin.
	// @return              Number of functions removed from forward.
	// @error               Invalid or corrupt private forward handle or invalid or corrupt plugin handle.
	public native int RemoveAllFunctions(Handle plugin);
};

/**
 * Gets a function id from a function name.
 *
 * @param plugin        Handle of the plugin that contains the function.
 *                      Pass INVALID_HANDLE to search in the calling plugin.
 * @param name          Name of the function.
 * @return              Function id or INVALID_FUNCTION if not found.
 * @error               Invalid or corrupt plugin handle.
 */
native Function GetFunctionByName(Handle plugin, const char[] name);

/**
 * Creates a global forward.
 *
 * @note The name used to create the forward is used as its public function in all target plugins.
 * @note This is ideal for global, static forwards that are never changed.
 * @note Global forwards cannot be cloned.
 * @note Use CloseHandle() to destroy these.
 *
 * @param name          Name of public function to use in forward.
 * @param type          Execution type to be used.
 * @param ...           Variable number of parameter types (up to 32).
 * @return              Handle to new global forward.
 * @error               More than 32 paramater types passed.
 */
native GlobalForward CreateGlobalForward(const char[] name, ExecType type, ParamType ...);

/**
 * Creates a private forward.
 *
 * @note No functions are automatically added. Use AddToForward() to do this.
 * @note Private forwards can be cloned.
 * @note Use CloseHandle() to destroy these.
 *
 * @param type          Execution type to be used.
 * @param ...           Variable number of parameter types (up to 32).
 * @return              Handle to new private forward.
 * @error               More than 32 paramater types passed.
 */
native PrivateForward CreateForward(ExecType type, ParamType ...);

/**
 * Returns the number of functions in a global or private forward's call list.
 *
 * @param fwd           Handle to global or private forward.
 * @return              Number of functions in forward.
 * @error               Invalid or corrupt forward handle.
 */
native int GetForwardFunctionCount(Handle fwd);

/**
 * Adds a function to a private forward's call list.
 *
 * @note Cannot be used during an incomplete call.
 *
 * @param fwd           Handle to private forward.
 * @param plugin        Handle of the plugin that contains the function.
 *                      Pass INVALID_HANDLE to specify the calling plugin.
 * @param func          Function to add to forward.
 * @return              True on success, false otherwise.
 * @error               Invalid or corrupt private forward handle, invalid or corrupt plugin handle, or invalid function.
 */
native bool AddToForward(Handle fwd, Handle plugin, Function func);

/**
 * Removes a function from a private forward's call list.
 *
 * @note Only removes one instance.
 * @note Functions will be removed automatically if their parent plugin is unloaded.
 *
 * @param fwd           Handle to private forward.
 * @param plugin        Handle of the plugin that contains the function.
 *                      Pass INVALID_HANDLE to specify the calling plugin.
 * @param func          Function to remove from forward.
 * @return              True on success, false otherwise.
 * @error               Invalid or corrupt private forward handle, invalid or corrupt plugin handle, or invalid function.
 */
native bool RemoveFromForward(Handle fwd, Handle plugin, Function func);

/**
 * Removes all instances of a plugin from a private forward's call list.
 *
 * @note Functions will be removed automatically if their parent plugin is unloaded.
 *
 * @param fwd           Handle to private forward.
 * @param plugin        Handle of the plugin to remove instances of.
 *                      Pass INVALID_HANDLE to specify the calling plugin.
 * @return              Number of functions removed from forward.
 * @error               Invalid or corrupt private forward handle or invalid or corrupt plugin handle.
 */
native int RemoveAllFromForward(Handle fwd, Handle plugin);

/**
 * Starts a call to functions in a forward's call list.
 *
 * @note Cannot be used during an incomplete call.
 *
 * @param fwd           Handle to global or private forward.
 * @error               Invalid or corrupt forward handle or called before another call has completed.
 */
native void Call_StartForward(Handle fwd);

/**
 * Starts a call to a function.
 *
 * @note Cannot be used during an incomplete call.
 *
 * @param plugin        Handle of the plugin that contains the function.
 *                      Pass INVALID_HANDLE to specify the calling plugin.
 * @param func          Function to call.
 * @error               Invalid or corrupt plugin handle, invalid function, or called before another call has completed.
 */
native void Call_StartFunction(Handle plugin, Function func);

/**
 * Pushes a cell onto the current call.
 *
 * @note Cannot be used before a call has been started.
 *
 * @param value         Cell value to push.
 * @error               Called before a call has been started.
 */
native void Call_PushCell(any value);

/**
 * Pushes a cell by reference onto the current call.
 *
 * @note Cannot be used before a call has been started.
 *
 * @param value         Cell reference to push.
 * @error               Called before a call has been started.
 */
native void Call_PushCellRef(any &value);

/**
 * Pushes a float onto the current call.
 *
 * @note Cannot be used before a call has been started.
 *
 * @param value         Floating point value to push.
 * @error               Called before a call has been started.
 */
native void Call_PushFloat(float value);

/**
 * Pushes a float by reference onto the current call.
 *
 * @note Cannot be used before a call has been started.
 *
 * @param value         Floating point reference to push.
 * @error               Called before a call has been started.
 */
native void Call_PushFloatRef(float &value);

/**
 * Pushes an array onto the current call.
 *
 * @note Changes to array are not copied back to caller. Use PushArrayEx() to do this.
 * @note Cannot be used before a call has been started.
 *
 * @param value         Array to push.
 * @param size          Size of array.
 * @error               Called before a call has been started.
 */
native void Call_PushArray(const any[] value, int size);

/**
 * Pushes an array onto the current call.
 *
 * @note Cannot be used before a call has been started.
 *
 * @param value         Array to push.
 * @param size          Size of array.
 * @param cpflags       Whether or not changes should be copied back to the input array.
 *                      See SP_PARAM_* constants for details.
 * @error               Called before a call has been started.
 */
native void Call_PushArrayEx(any[] value, int size, int cpflags);

/**
 * Pushes the NULL_VECTOR onto the current call.
 * @see IsNullVector
 *
 * @note Cannot be used before a call has been started.
 *
 * @error               Called before a call has been started.
 */
native void Call_PushNullVector();

/**
 * Pushes a string onto the current call.
 *
 * @note Changes to string are not copied back to caller. Use PushStringEx() to do this.
 * @note Cannot be used before a call has been started.
 *
 * @param value         String to push.
 * @error               Called before a call has been started.
 */
native void Call_PushString(const char[] value);

/**
 * Pushes a string onto the current call.
 *
 * @note Cannot be used before a call has been started.
 *
 * @param value         String to push.
 * @param length        Length of string buffer.
 * @param szflags       Flags determining how string should be handled.
 *                      See SM_PARAM_STRING_* constants for details.
 *                      The default (0) is to push ASCII.
 * @param cpflags       Whether or not changes should be copied back to the input array.
 *                      See SM_PARAM_* constants for details.
 * @error               Called before a call has been started.
 */
native void Call_PushStringEx(char[] value, int length, int szflags, int cpflags);

/**
 * Pushes the NULL_STRING onto the current call.
 * @see IsNullString
 *
 * @note Cannot be used before a call has been started.
 *
 * @error               Called before a call has been started.
 */
native void Call_PushNullString();

/**
 * Completes a call to a function or forward's call list.
 *
 * @note Cannot be used before a call has been started.
 *
 * @param result        Return value of function or forward's call list.
 * @return              SP_ERROR_NONE on success, any other integer on failure.
 * @error               Called before a call has been started.
 */
native int Call_Finish(any &result=0);

/**
 * Cancels a call to a function or forward's call list.
 *
 * @note Cannot be used before a call has been started.
 *
 * @error               Called before a call has been started.
 */
native void Call_Cancel();

typeset NativeCall
{
	/**
	 * Defines a native function.
	 *
	 * It is not necessary to validate the parameter count
	 *
	 * @param plugin        Handle of the calling plugin.
	 * @param numParams     Number of parameters passed to the native.
	 * @return              Value for the native call to return.
	 */
	function int (Handle plugin, int numParams);

	/**
	 * Defines a native function.
	 *
	 * It is not necessary to validate the parameter count
	 *
	 * @param plugin         Handle of the calling plugin.
	 * @param numParams      Number of parameters passed to the native.
	 * @return               Value for the native call to return.
	 */
	function any (Handle plugin, int numParams);
}

/**
 * Creates a dynamic native.  This should only be called in AskPluginLoad(), or
 * else you risk not having your native shared with other plugins.
 *
 * @param name          Name of the dynamic native; must be unique among
 *                      all other registered dynamic natives.
 * @param func          Function to use as the dynamic native.
 */
native void CreateNative(const char[] name, NativeCall func);

/**
 * Throws an error in the calling plugin of a native, instead of your own plugin.
 *
 * @param error         Error code to use.
 * @param fmt           Error message format.
 * @param ...           Format arguments.
 */
native int ThrowNativeError(int error, const char[] fmt, any ...);

/**
 * Retrieves the string length from a native parameter string.  This is useful for
 * fetching the entire string using dynamic arrays.
 *
 * @note If this function succeeds, Get/SetNativeString will also succeed.
 *
 * @param param         Parameter number, starting from 1.
 * @param length        Stores the length of the string.
 * @return              SP_ERROR_NONE on success, any other integer on failure.
 * @error               Invalid parameter number or calling from a non-native function.
 */
native int GetNativeStringLength(int param, int &length);

/**
 * Retrieves a string from a native parameter.
 *
 * @note Output conditions are undefined on failure.
 *
 * @param param         Parameter number, starting from 1.
 * @param buffer        Buffer to store the string in.
 * @param maxlength     Maximum length of the buffer.
 * @param bytes         Optionally store the number of bytes written.
 * @return              SP_ERROR_NONE on success, any other integer on failure.
 * @error               Invalid parameter number or calling from a non-native function.
 */
native int GetNativeString(int param, char[] buffer, int maxlength, int &bytes=0);

/**
 * Sets a string in a native parameter.
 *
 * @note Output conditions are undefined on failure.
 *
 * @param param         Parameter number, starting from 1.
 * @param source        Source string to use.
 * @param maxlength     Maximum number of bytes to write.
 * @param utf8          If false, string will not be written
 *                      with UTF8 safety.
 * @param bytes         Optionally store the number of bytes written.
 * @return              SP_ERROR_NONE on success, any other integer on failure.
 * @error               Invalid parameter number or calling from a non-native function.
 */
native int SetNativeString(int param, const char[] source, int maxlength, bool utf8=true, int &bytes=0);

/**
 * Gets a cell from a native parameter.
 *
 * @param param         Parameter number, starting from 1.
 * @return              Cell value at the parameter number.
 * @error               Invalid parameter number or calling from a non-native function.
 */
native any GetNativeCell(int param);

/**
 * Gets a function pointer from a native parameter.
 *
 * @param param             Parameter number, starting from 1.
 * @return                  Function pointer at the given parameter number.
 * @error                   Invalid parameter number, or calling from a non-native function.
 */
native Function GetNativeFunction(int param);

/**
 * Gets a cell from a native parameter, by reference.
 *
 * @param param         Parameter number, starting from 1.
 * @return              Cell value at the parameter number.
 * @error               Invalid parameter number or calling from a non-native function.
 */
native any GetNativeCellRef(int param);

/**
 * Sets a cell from a native parameter, by reference.
 *
 * @param param         Parameter number, starting from 1.
 * @param value         Cell value at the parameter number to set by reference.
 * @error               Invalid parameter number or calling from a non-native function.
 */
native void SetNativeCellRef(int param, any value);

/**
 * Gets an array from a native parameter (always by reference).
 *
 * @param param         Parameter number, starting from 1.
 * @param local         Local array to copy into.
 * @param size          Maximum size of local array.
 * @return              SP_ERROR_NONE on success, anything else on failure.
 * @error               Invalid parameter number or calling from a non-native function.
 */
native int GetNativeArray(int param, any[] local, int size);

/**
 * Copies a local array into a native parameter array (always by reference).
 *
 * @param param         Parameter number, starting from 1.
 * @param local         Local array to copy from.
 * @param size          Size of the local array to copy.
 * @return              SP_ERROR_NONE on success, anything else on failure.
 * @error               Invalid parameter number or calling from a non-native function.
 */
native int SetNativeArray(int param, const any[] local, int size);

/**
 * Check if the native parameter is the NULL_VECTOR.
 *
 * @param param         Parameter number, starting from 1.
 * @return              True if NULL_VECTOR, false otherwise.
 */
native bool IsNativeParamNullVector(int param);

/**
 * Check if the native parameter is the NULL_STRING.
 *
 * @param param         Parameter number, starting from 1.
 * @return              True if NULL_STRING, false otherwise.
 */
native bool IsNativeParamNullString(int param);

/**
 * Formats a string using parameters from a native.
 *
 * @note All parameter indexes start at 1.
 * @note If the input and output buffers overlap, the contents
 *       of the output buffer at the end is undefined.
 *
 * @param out_param     Output parameter number to write to.  If 0, out_string is used.
 * @param fmt_param     Format parameter number.  If 0, fmt_string is used.
 * @param vararg_param  First variable parameter number.
 * @param out_len       Output string buffer maximum length (always required).
 * @param written       Optionally stores the number of bytes written.
 * @param out_string    Output string buffer to use if out_param is not used.
 * @param fmt_string    Format string to use if fmt_param is not used.
 * @return              SP_ERROR_NONE on success, anything else on failure.
 */
native int FormatNativeString(int out_param,
						  int fmt_param,
						  int vararg_param,
						  int out_len,
						  int &written=0,
						  char[] out_string="",
						  const char[] fmt_string="");

/**
 * Defines a RequestFrame Callback.
 *
 * @param data          Data passed to the RequestFrame native.
 */
typeset RequestFrameCallback {
	function void ();
	function void (any data);
}

/**
 * Creates a single use Next Frame hook.
 *
 * @param Function      Function to call on the next frame.
 * @param data          Value to be passed on the invocation of the Function.
 */
native void RequestFrame(RequestFrameCallback Function, any data=0);
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _version_included
 #endinput
#endif
#define _version_included

#tryinclude <version_auto>

#if !defined _auto_version_included
 #define SOURCEMOD_V_TAG         "manual"
 #define SOURCEMOD_V_REV         0
 #define SOURCEMOD_V_CSET        "0"
 #define SOURCEMOD_V_MAJOR       1               /**< SourceMod Major version */
 #define SOURCEMOD_V_MINOR       10              /**< SourceMod Minor version */
 #define SOURCEMOD_V_RELEASE     0               /**< SourceMod Release version */

 #define SOURCEMOD_VERSION       "1.10.0-manual" /**< SourceMod version string (major.minor.release-tag) */
#endif
/**
 * vim: set ts=4 sw=4 tw=99 noet :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _datapack_included
 #endinput
#endif
#define _datapack_included


/**
 * Opaque handle to a datapack position.
 */
enum DataPackPos: {};

// A DataPack allows serializing multiple variables into a single stream.
methodmap DataPack < Handle
{
	// Creates a new data pack.
	public native DataPack();

	// Packs a normal cell into a data pack.
	//
	// @param cell          Cell to add.
	// @param insert        Determines whether mid-pack writes will insert instead of overwrite.
	public native void WriteCell(any cell, bool insert = false);

	// Packs a float into a data pack.
	//
	// @param val           Float to add.
	// @param insert        Determines whether mid-pack writes will insert instead of overwrite.
	public native void WriteFloat(float val, bool insert = false);

	// Packs a string into a data pack.
	//
	// @param str           String to add.
	// @param insert        Determines whether mid-pack writes will insert instead of overwrite.
	public native void WriteString(const char[] str, bool insert = false);

	// Packs a function pointer into a data pack.
	//
	// @param fktptr        Function pointer to add.
	// @param insert        Determines whether mid-pack writes will insert instead of overwrite.
	public native void WriteFunction(Function fktptr, bool insert = false);

	// Reads a cell from a data pack.
	//
	// @return		A cell at this position
	public native any ReadCell();

	// Reads a float from a data pack.
	//
	// @return		Float at this position
	public native float ReadFloat();

	// Reads a string from a data pack.
	//
	// @param buffer        Destination string buffer.
	// @param maxlen        Maximum length of output string buffer.
	public native void ReadString(char[] buffer, int maxlen);

	// Reads a function pointer from a data pack.
	//
	// @return              Function pointer.
	public native Function ReadFunction();

	// Resets the position in a data pack.
	//
	// @param clear         If true, clears the contained data.
	public native void Reset(bool clear=false);

	// Returns whether or not a specified number of bytes from the data pack
	//  position to the end can be read.
	//
	// @param unused        Unused variable. Exists for backwards compatability.
	public native bool IsReadable(int unused = 0);
	
	// The read or write position in a data pack.
	property DataPackPos Position {
		public native get();
		public native set(DataPackPos pos);
	}
};

/**
 * Creates a new data pack.
 *
 * @return              A Handle to the data pack.  Must be closed with CloseHandle().
 */
native DataPack CreateDataPack();

/**
 * Packs a normal cell into a data pack.
 *
 * @param pack          Handle to the data pack.
 * @param cell          Cell to add.
 * @error               Invalid handle.
 */
native void WritePackCell(Handle pack, any cell);

/**
 * Packs a float into a data pack.
 *
 * @param pack          Handle to the data pack.
 * @param val           Float to add.
 * @error               Invalid handle.
 */
native void WritePackFloat(Handle pack, float val);

/**
 * Packs a string into a data pack.
 *
 * @param pack          Handle to the data pack.
 * @param str           String to add.
 * @error               Invalid handle.
 */
native void WritePackString(Handle pack, const char[] str);

/**
 * Packs a function pointer into a data pack.
 *
 * @param pack          Handle to the data pack.
 * @param fktptr        Function pointer to add.
 * @error               Invalid handle.
 */
native void WritePackFunction(Handle pack, Function fktptr);

/**
 * Reads a cell from a data pack.
 *
 * @param pack          Handle to the data pack.
 * @return              Cell value.
 * @error               Invalid handle, or bounds error.
 */
native any ReadPackCell(Handle pack);

/**
 * Reads a float from a data pack.
 *
 * @param pack          Handle to the data pack.
 * @return              Float value.
 * @error               Invalid handle, or bounds error.
 */
native float ReadPackFloat(Handle pack);

/**
 * Reads a string from a data pack.
 *
 * @param pack          Handle to the data pack.
 * @param buffer        Destination string buffer.
 * @param maxlen        Maximum length of output string buffer.
 * @error               Invalid handle, or bounds error.
 */
native void ReadPackString(Handle pack, char[] buffer, int maxlen);

/**
 * Reads a function pointer from a data pack.
 *
 * @param pack          Handle to the data pack.
 * @return              Function pointer.
 * @error               Invalid handle, or bounds error.
 */
native Function ReadPackFunction(Handle pack);

/**
 * Resets the position in a data pack.
 *
 * @param pack          Handle to the data pack.
 * @param clear         If true, clears the contained data.
 * @error               Invalid handle.
 */
native void ResetPack(Handle pack, bool clear=false);

/**
 * Returns the read or write position in a data pack.
 *
 * @param pack          Handle to the data pack.
 * @return              Position in the data pack, only usable with calls to SetPackPosition.
 * @error               Invalid handle.
 */
native DataPackPos GetPackPosition(Handle pack);

/**
 * Sets the read/write position in a data pack.
 *
 * @param pack          Handle to the data pack.
 * @param position      New position to set. Must have been previously retrieved from a call to GetPackPosition.
 * @error               Invalid handle, or position is beyond the pack bounds.
 */
native void SetPackPosition(Handle pack, DataPackPos position);

/**
 * Returns whether or not a specified number of bytes from the data pack
 * position to the end can be read.
 *
 * @param pack          Handle to the data pack.
 * @param bytes         Number of bytes to simulate reading.
 * @return              True if can be read, false otherwise.
 * @error               Invalid handle.
 */
native bool IsPackReadable(Handle pack, int bytes);
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _geoip_included
 #endinput
#endif
#define _geoip_included

#include <core>

/**
 * @section IP addresses can contain ports, the ports will be stripped out.
 */

/**
 * Gets the two character country code from an IP address. (US, CA, etc)
 *
 * @param ip            Ip to determine the country code.
 * @param ccode         Destination string buffer to store the code.
 * @return              True on success, false if no country found.
 */
native bool GeoipCode2(const char[] ip, char ccode[3]);

/**
 * Gets the three character country code from an IP address. (USA, CAN, etc)
 *
 * @param ip            Ip to determine the country code.
 * @param ccode         Destination string buffer to store the code.
 * @return              True on success, false if no country found.
 */
native bool GeoipCode3(const char[] ip, char ccode[4]);

/**
 * Gets the full country name. (max length of output string is 45)
 *
 * @param ip            Ip to determine the country code.
 * @param name          Destination string buffer to store the country name.
 * @param maxlength     Maximum length of output string buffer.
 * @return              True on success, false if no country found.
 */
native bool GeoipCountry(const char[] ip, char[] name, int maxlength);

/**
 * @endsection
 */

/**
 * Do not edit below this line!
 */
public Extension __ext_geoip = 
{
	name = "GeoIP",
	file = "geoip.ext",
#if defined AUTOLOAD_EXTENSIONS
	autoload = 1,
#else
	autoload = 0,
#endif
#if defined REQUIRE_EXTENSIONS
	required = 1,
#else
	required = 0,
#endif
};

#if !defined REQUIRE_EXTENSIONS
public void __ext_geoip_SetNTVOptional()
{
	MarkNativeAsOptional("GeoipCode2");
	MarkNativeAsOptional("GeoipCode3");
	MarkNativeAsOptional("GeoipCountry");
}
#endif
/**
 * vim: set ts=4 sw=4 tw=99 noet :
 * =============================================================================
 * SourceMod (C)2004-2014 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */
 
#if defined _events_included
 #endinput
#endif
#define _events_included

/**
 * Event hook modes determining how hooking should be handled
 */
enum EventHookMode
{
	EventHookMode_Pre,                  //< Hook callback fired before event is fired */
	EventHookMode_Post,                 //< Hook callback fired after event is fired */
	EventHookMode_PostNoCopy            //< Hook callback fired after event is fired, but event data won't be copied */
};

/**
 * Hook function types for events.
 */
typeset EventHook
{
	// Called when a game event is fired.
	//
	// @param event         Handle to event. This could be INVALID_HANDLE if every plugin hooking 
	//                      this event has set the hook mode EventHookMode_PostNoCopy.
	// @param name          String containing the name of the event.
	// @param dontBroadcast True if event was not broadcast to clients, false otherwise.
	//                      May not correspond to the real value. Use the property BroadcastDisabled.
	// @return              Ignored for post hooks. Plugin_Handled will block event if hooked as pre.
	///
	function Action (Event event, const char[] name, bool dontBroadcast);
	
	//
	// Called when a game event is fired.
	//
	// @param event         Handle to event. This could be INVALID_HANDLE if every plugin hooking 
	//                      this event has set the hook mode EventHookMode_PostNoCopy.
	// @param name          String containing the name of the event.
	// @param dontBroadcast True if event was not broadcast to clients, false otherwise.
	///
	function void (Event event, const char[] name, bool dontBroadcast);
};

methodmap Event < Handle
{
	// Fires a game event.
	//
	// This function closes the event Handle after completing.
	//
	// @param dontBroadcast Optional boolean that determines if event should be broadcast to clients.
	public native void Fire(bool dontBroadcast=false);
	
	// Fires a game event to only the specified client.
	//
	// Unlike Fire, this function DOES NOT close the event Handle.
	//
	// @param client        Index of client to receive the event..
	public native void FireToClient(int client);

	// Cancels a previously created game event that has not been fired. This
	// is necessary to avoid leaking memory when an event isn't fired.
	public native void Cancel();

	// Returns the boolean value of a game event's key.
	//
	// @param key          Name of event key.
	// @param defValue     Optional default value to use if the key is not found.
	// @return             The boolean value of the specified event key.
	public native bool GetBool(const char[] key, bool defValue=false);

	// Sets the boolean value of a game event's key.
	//
	// @param key          Name of event key.
	// @param value        New boolean value.
	public native void SetBool(const char[] key, bool value);

	// Returns the integer value of a game event's key.
	//
	// @param key          Name of event key.
	// @param defValue     Optional default value to use if the key is not found.
	// @return             The integer value of the specified event key.
	public native int GetInt(const char[] key, int defValue=0);

	// Sets the integer value of a game event's key.
	//
	// Integer value refers to anything that can be reduced to an integer.
	// The various size specifiers, such as "byte" and "short" are still 
	// integers, and only refer to how much data will actually be sent 
	// over the network (if applicable).
	//
	// @param key          Name of event key.
	// @param value        New integer value.
	public native void SetInt(const char[] key, int value);

	// Returns the floating point value of a game event's key.
	//
	// @param key          Name of event key.
	// @param defValue     Optional default value to use if the key is not found.
	// @return             The floating point value of the specified event key.
	public native float GetFloat(const char[] key, float defValue=0.0);

	// Sets the floating point value of a game event's key.
	//
	// @param key          Name of event key.
	// @param value        New floating point value.
	public native void SetFloat(const char[] key, float value);

	// Retrieves the string value of a game event's key.
	//
	// @param key          Name of event key.
	// @param value        Buffer to store the value of the specified event key.
	// @param maxlength    Maximum length of string buffer.
	// @param defValue     Optional default value to use if the key is not found.
	public native void GetString(const char[] key, char[] value, int maxlength, const char[] defvalue="");

	// Sets the string value of a game event's key.
	//
	// @param key          Name of event key.
	// @param value        New string value.
	public native void SetString(const char[] key, const char[] value);

	// Retrieves the name of a game event.
	//
	// @param name         Buffer to store the name of the event.
	// @param maxlength    Maximum length of string buffer.
	public native void GetName(char[] name, int maxlength);

	// Sets whether an event's broadcasting will be disabled or not.
	//
	// This has no effect on events Handles that are not from HookEvent
	// or HookEventEx callbacks.
	property bool BroadcastDisabled {
		public native set(bool dontBroadcast);
		public native get();
	}
}

/**
 * Creates a hook for when a game event is fired.
 *
 * @param name          Name of event.
 * @param callback      An EventHook function pointer.
 * @param mode          Optional EventHookMode determining the type of hook.
 * @error               Invalid event name or invalid callback function.
 */
native void HookEvent(const char[] name, EventHook callback, EventHookMode mode=EventHookMode_Post);

/**
 * Creates a hook for when a game event is fired.
 *
 * @param name          Name of event.
 * @param callback      An EventHook function pointer.
 * @param mode          Optional EventHookMode determining the type of hook.
 * @return              True if event exists and was hooked successfully, false otherwise.
 * @error               Invalid callback function.
 */
native bool HookEventEx(const char[] name, EventHook callback, EventHookMode mode=EventHookMode_Post);

/**
 * Removes a hook for when a game event is fired.
 *
 * @param name          Name of event.
 * @param callback      An EventHook function pointer.
 * @param mode          Optional EventHookMode determining the type of hook.
 * @error               Invalid callback function or no active hook for specified event.
 */
native void UnhookEvent(const char[] name, EventHook callback, EventHookMode mode=EventHookMode_Post);

/**
 * Creates a game event to be fired later.
 *
 * The Handle should not be closed via CloseHandle().  It must be closed via 
 * event.Fire() or event.Cancel().
 *
 * @param name          Name of event.
 * @param force         If set to true, this forces the event to be created even if it's not being hooked.
 *                      Note that this will not force it if the event doesn't exist at all.
 * @return              Handle to event. INVALID_HANDLE is returned if the event doesn't exist or isn't 
 *                      being hooked (unless force is true).
 */
native Event CreateEvent(const char[] name, bool force=false);

/**
 * Fires a game event.
 *
 * This function closes the event Handle after completing.
 *
 * @param event         Handle to the event.
 * @param dontBroadcast Optional boolean that determines if event should be broadcast to clients.
 * @error               Invalid or corrupt Handle.
 */
native void FireEvent(Handle event, bool dontBroadcast=false);

/**
 * Cancels a previously created game event that has not been fired.
 *
 * @param event         Handled to the event.
 * @error               Invalid or corrupt Handle.
 */
native void CancelCreatedEvent(Handle event);

/**
 * Returns the boolean value of a game event's key.
 *
 * @param event         Handle to the event.
 * @param key           Name of event key.
 * @param defValue      Optional default value to use if the key is not found.
 * @return              The boolean value of the specified event key.
 * @error               Invalid or corrupt Handle.
 */
native bool GetEventBool(Handle event, const char[] key, bool defValue=false);

/**
 * Sets the boolean value of a game event's key.
 *
 * @param event         Handle to the event.
 * @param key           Name of event key.
 * @param value         New boolean value.
 * @error               Invalid or corrupt Handle.
 */
native void SetEventBool(Handle event, const char[] key, bool value);

/**
 * Returns the integer value of a game event's key.
 *
 * @param event         Handle to the event.
 * @param key           Name of event key.
 * @param defValue      Optional default value to use if the key is not found.
 * @return              The integer value of the specified event key.
 * @error               Invalid or corrupt Handle.
 */
native int GetEventInt(Handle event, const char[] key, int defValue=0);

/**
 * Sets the integer value of a game event's key.
 *
 * Integer value refers to anything that can be reduced to an integer.
 * The various size specifiers, such as "byte" and "short" are still 
 * integers, and only refer to how much data will actually be sent 
 * over the network (if applicable).
 *
 * @param event         Handle to the event.
 * @param key           Name of event key.
 * @param value         New integer value.
 * @error               Invalid or corrupt Handle.
 */
native void SetEventInt(Handle event, const char[] key, int value);

/**
 * Returns the floating point value of a game event's key.
 *
 * @param event         Handle to the event.
 * @param key           Name of event key.
 * @param defValue      Optional default value to use if the key is not found.
 * @return              The floating point value of the specified event key.
 * @error               Invalid or corrupt Handle.
 */
native float GetEventFloat(Handle event, const char[] key, float defValue=0.0);

/**
 * Sets the floating point value of a game event's key.
 *
 * @param event         Handle to the event.
 * @param key           Name of event key.
 * @param value         New floating point value.
 * @error               Invalid or corrupt Handle.
 */
native void SetEventFloat(Handle event, const char[] key, float value);

/**
 * Retrieves the string value of a game event's key.
 *
 * @param event         Handle to the event.
 * @param key           Name of event key.
 * @param value         Buffer to store the value of the specified event key.
 * @param maxlength     Maximum length of string buffer.
 * @param defValue      Optional default value to use if the key is not found.
 * @error               Invalid or corrupt Handle.
 */
native void GetEventString(Handle event, const char[] key, char[] value, int maxlength, const char[] defvalue="");

/**
 * Sets the string value of a game event's key.
 *
 * @param event         Handle to the event.
 * @param key           Name of event key.
 * @param value         New string value.
 * @error               Invalid or corrupt Handle.
 */
native void SetEventString(Handle event, const char[] key, const char[] value);

/**
 * Retrieves the name of a game event.
 *
 * @param event         Handle to the event.
 * @param name          Buffer to store the name of the event.
 * @param maxlength     Maximum length of string buffer.
 * @error               Invalid or corrupt Handle.     
 */
native void GetEventName(Handle event, char[] name, int maxlength);

/**
 * Sets whether an event's broadcasting will be disabled or not.
 *
 * This has no effect on events Handles that are not from HookEvent
 * or HookEventEx callbacks.
 *
 * @param event         Handle to an event from an event hook.
 * @param dontBroadcast True to disable broadcasting, false otherwise.
 * @error               Invalid Handle.
 */
native void SetEventBroadcast(Handle event, bool dontBroadcast);
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */


#if defined _sorting_included
 #endinput
#endif
#define _sorting_included

/**
 * Contains sorting orders.
 */
enum SortOrder
{
	Sort_Ascending = 0,     /**< Ascending order */
	Sort_Descending = 1,    /**< Descending order */
	Sort_Random = 2         /**< Random order */
};

/**
 * Data types for ADT Array Sorts
 */
enum SortType
{
	Sort_Integer = 0,
	Sort_Float,
	Sort_String
};

/**
 * Sorts an array of integers.
 *
 * @param array         Array of integers to sort in-place.
 * @param array_size    Size of the array.
 * @param order         Sorting order to use.
 */
native void SortIntegers(int[] array, int array_size, SortOrder order = Sort_Ascending);

/**
 * Sorts an array of float point numbers.
 *
 * @param array         Array of floating point numbers to sort in-place.
 * @param array_size    Size of the array.
 * @param order         Sorting order to use.
 */
native void SortFloats(float[] array, int array_size, SortOrder order = Sort_Ascending);

/**
 * Sorts an array of strings.
 *
 * @param array         Array of strings to sort in-place.
 * @param array_size    Size of the array.
 * @param order         Sorting order to use.
 */
native void SortStrings(char[][] array, int array_size, SortOrder order = Sort_Ascending);

/**
 * Sort comparison function for 1D array elements.
 * @note You may need to use explicit tags in order to use data properly.
 *
 * @param elem1         First element to compare.
 * @param elem2         Second element to compare.
 * @param array         Array that is being sorted (order is undefined).
 * @param hndl          Handle optionally passed in while sorting.
 * @return              -1 if first should go before second
 *                      0 if first is equal to second
 *                      1 if first should go after second
 */
typedef SortFunc1D = function int (int elem1, int elem2, const int[] array, Handle hndl);

/**
 * Sorts a custom 1D array.  You must pass in a comparison function.
 *
 * @param array         Array to sort.
 * @param array_size    Size of the array to sort.
 * @param sortfunc      Sort function.
 * @param hndl          Optional Handle to pass through the comparison calls.
 */
native void SortCustom1D(int[] array, int array_size, SortFunc1D sortfunc, Handle hndl=INVALID_HANDLE);

/**
 * Sort comparison function for 2D array elements (sub-arrays).
 * @note You may need to use explicit tags in order to use data properly.
 *
 * @param elem1         First array to compare.
 * @param elem2         Second array to compare.
 * @param array         Array that is being sorted (order is undefined).
 * @param hndl          Handle optionally passed in while sorting.
 * @return              -1 if first should go before second
 *                      0 if first is equal to second
 *                      1 if first should go after second
 */
typeset SortFunc2D
{
	function int (int[] elem1, int[] elem2, const int[][] array, Handle hndl);
	function int (char[] elem1, char[] elem2, const char[][] array, Handle hndl);
};

/**
 * Sorts a custom 2D array.  You must pass in a comparison function.
 *
 * @param array         Array to sort.
 * @param array_size    Size of the major array to sort (first index, outermost).
 * @param sortfunc      Sort comparison function to use.
 * @param hndl          Optional Handle to pass through the comparison calls.
 */
native void SortCustom2D(any[][] array, int array_size, SortFunc2D sortfunc, Handle hndl=INVALID_HANDLE);

/**
 * Sort an ADT Array. Specify the type as Integer, Float, or String.
 *
 * @param array         Array Handle to sort
 * @param order         Sort order to use, same as other sorts.
 * @param type          Data type stored in the ADT Array
 */
native void SortADTArray(Handle array, SortOrder order, SortType type);

/**
 * Sort comparison function for ADT Array elements. Function provides you with
 * indexes currently being sorted, use ADT Array functions to retrieve the
 * index values and compare.
 *
 * @param index1        First index to compare.
 * @param index2        Second index to compare.
 * @param array         Array that is being sorted (order is undefined).
 * @param hndl          Handle optionally passed in while sorting.
 * @return              -1 if first should go before second
 *                      0 if first is equal to second
 *                      1 if first should go after second
 */
typedef SortFuncADTArray = function int (int index1, int index2, Handle array, Handle hndl);

/**
 * Custom sorts an ADT Array. You must pass in a comparison function.
 *
 * @param array         Array Handle to sort
 * @param sortfunc      Sort comparison function to use
 * @param hndl          Optional Handle to pass through the comparison calls.
 */
native void SortADTArrayCustom(Handle array, SortFuncADTArray sortfunc, Handle hndl=INVALID_HANDLE);
/**
 * vim: set ts=4 sw=4 tw=99 noet :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _regex_included
 #endinput
#endif
#define _regex_included

/**
 * @section     Flags for compiling regex expressions.  These come directly from the
 * pcre library and can be used in MatchRegex and CompileRegex.
 */
#define PCRE_CASELESS           0x00000001 /* Ignore Case */
#define PCRE_MULTILINE          0x00000002 /* Multilines (affects ^ and $ so that they match the start/end of a line rather than matching the start/end of the string). */
#define PCRE_DOTALL             0x00000004 /* Single line (affects . so that it matches any character, even new line characters). */
#define PCRE_EXTENDED           0x00000008 /* Pattern extension (ignore whitespace and # comments). */
#define PCRE_ANCHORED           0x00000010 /* Force pattern anchoring. */
#define PCRE_DOLLAR_ENDONLY     0x00000020 /* $ not to match newline at end. */
#define PCRE_UNGREEDY           0x00000200 /* Invert greediness of quantifiers */
#define PCRE_NOTEMPTY           0x00000400 /* An empty string is not a valid match. */
#define PCRE_UTF8               0x00000800 /* Use UTF-8 Chars */
#define PCRE_NO_UTF8_CHECK      0x00002000 /* Do not check the pattern for UTF-8 validity (only relevant if PCRE_UTF8 is set) */
#define PCRE_UCP                0x20000000 /* Use Unicode properties for \ed, \ew, etc. */


/**
 * Regex expression error codes.
 */
enum RegexError
{
	REGEX_ERROR_NONE = 0,               /* No error */

	REGEX_ERROR_ASSERT = 1,             /* internal error ? */
	REGEX_ERROR_BADBR,                  /* invalid repeat counts in {} */
	REGEX_ERROR_BADPAT,                 /* pattern error */
	REGEX_ERROR_BADRPT,                 /* ? * + invalid */
	REGEX_ERROR_EBRACE,                 /* unbalanced {} */
	REGEX_ERROR_EBRACK,                 /* unbalanced [] */
	REGEX_ERROR_ECOLLATE,               /* collation error - not relevant */
	REGEX_ERROR_ECTYPE,                 /* bad class */
	REGEX_ERROR_EESCAPE,                /* bad escape sequence */
	REGEX_ERROR_EMPTY,                  /* empty expression */
	REGEX_ERROR_EPAREN,                 /* unbalanced () */
	REGEX_ERROR_ERANGE,                 /* bad range inside [] */
	REGEX_ERROR_ESIZE,                  /* expression too big */
	REGEX_ERROR_ESPACE,                 /* failed to get memory */
	REGEX_ERROR_ESUBREG,                /* bad back reference */
	REGEX_ERROR_INVARG,                 /* bad argument */

	REGEX_ERROR_NOMATCH = -1,           /* No match was found */
	REGEX_ERROR_NULL = -2,
	REGEX_ERROR_BADOPTION = -3,
	REGEX_ERROR_BADMAGIC = -4,
	REGEX_ERROR_UNKNOWN_OPCODE = -5,
	REGEX_ERROR_NOMEMORY = -6,
	REGEX_ERROR_NOSUBSTRING = -7,
	REGEX_ERROR_MATCHLIMIT = -8,
	REGEX_ERROR_CALLOUT = -9,           /* Never used by PCRE itself */
	REGEX_ERROR_BADUTF8 = -10,
	REGEX_ERROR_BADUTF8_OFFSET = -11,
	REGEX_ERROR_PARTIAL = -12,
	REGEX_ERROR_BADPARTIAL = -13,
	REGEX_ERROR_INTERNAL = -14,
	REGEX_ERROR_BADCOUNT = -15,
	REGEX_ERROR_DFA_UITEM = -16,
	REGEX_ERROR_DFA_UCOND = -17,
	REGEX_ERROR_DFA_UMLIMIT = -18,
	REGEX_ERROR_DFA_WSSIZE = -19,
	REGEX_ERROR_DFA_RECURSE = -20,
	REGEX_ERROR_RECURSIONLIMIT = -21,
	REGEX_ERROR_NULLWSLIMIT = -22,      /* No longer actually used */
	REGEX_ERROR_BADNEWLINE = -23,
	REGEX_ERROR_BADOFFSET = -24,
	REGEX_ERROR_SHORTUTF8 = -25,
	REGEX_ERROR_RECURSELOOP = -26,
	REGEX_ERROR_JIT_STACKLIMIT = -27,
	REGEX_ERROR_BADMODE = -28,
	REGEX_ERROR_BADENDIANNESS = -29,
	REGEX_ERROR_DFA_BADRESTART = -30,
	REGEX_ERROR_JIT_BADOPTION = -31,
	REGEX_ERROR_BADLENGTH = -32
};

// Regular expression objects are used to match or decompose strings based on
// patterns.
methodmap Regex < Handle
{
	// Compile a regular expression.
	//
	// @param pattern       The regular expression pattern.
	// @param flags         General flags for the regular expression.
	// @param error         Error message encountered, if applicable.
	// @param maxLen        Maximum string length of the error buffer.
	// @param errcode       Regex type error code encountered, if applicable.
	public native Regex(const char[] pattern, int flags = 0, char[] error="", int maxLen = 0, RegexError &errcode = REGEX_ERROR_NONE);

	// Matches a string against a pre-compiled regular expression pattern.
	//
	// @param str           The string to check.
	// @param ret           Error code, if applicable.
	// @param offset        Offset in the string to start searching from. MatchOffset returns the offset of the match.
	// @return              Number of captures found or -1 on failure.
	//
	// @note Use the regex handle passed to this function to extract
	//       matches with GetSubString().
	public native int Match(const char[] str, RegexError &ret = REGEX_ERROR_NONE, int offset = 0);

	// Gets all matches from a string against a pre-compiled regular expression pattern.
	//
	// @param str           The string to check.
	// @param ret           Error code, if applicable.
	// @return              Number of matches found or -1 on failure.
	//
	// @note Use GetSubString() and loop from 0 -> totalmatches - 1.
	public native int MatchAll(const char[] str, RegexError &ret = REGEX_ERROR_NONE);

	// Returns a matched substring from a regex handle.
	//
	// Substring ids start at 0 and end at captures-1, where captures is the
	// number returned by Regex.Match or Regex.CaptureCount.
	//
	// @param str_id        The index of the expression to get - starts at 0, and ends at captures - 1.
	// @param buffer        The buffer to set to the matching substring.
	// @param maxlen        The maximum string length of the buffer.
	// @param match         Match to get the captures for - starts at 0, and ends at MatchCount() -1
	// @return              True if a substring was found, False on fail/error
	//
	// @note str_id = 0 is the full captured string, anything else is the capture group index.
	//       if Regex.Match is used match can only be 0
	public native bool GetSubString(int str_id, char[] buffer, int maxlen, int match = 0);

	// Returns number of matches
	//
	// When using Match this is always 1 or 0 (unless an error occured)
	// @return              Total number of matches found.
	public native int MatchCount();

	// Returns number of captures for a match
	//
	// @param match         Match to get the number of captures for. Match starts at 0, and ends at MatchCount() -1
	// @return              Number of captures in the match.
	//
	// @note Use GetSubString() and loop from 1 -> captures -1 for str_id to get all captures
	public native int CaptureCount(int match = 0);

	// Returns the string offset of a match.
	//
	// @param match         Match to get the offset of. Match starts at 0, and ends at MatchCount() -1
	// @return              Offset of the match in the string.
	public native int MatchOffset(int match = 0);
};

/**
 * Precompile a regular expression.  Use this if you intend on using the
 * same expression multiple times.  Pass the regex handle returned here to
 * MatchRegex to check for matches.
 *
 * @param pattern       The regular expression pattern.
 * @param flags         General flags for the regular expression.
 * @param error         Error message encountered, if applicable.
 * @param maxLen        Maximum string length of the error buffer.
 * @param errcode       Regex type error code encountered, if applicable.
 * @return              Valid regex handle on success, INVALID_HANDLE on failure.
 */
native Regex CompileRegex(const char[] pattern, int flags = 0, char[] error="", int maxLen = 0, RegexError &errcode = REGEX_ERROR_NONE);

/**
 * Matches a string against a pre-compiled regular expression pattern.
 *
 * @param regex         Regex Handle from CompileRegex()
 * @param str           The string to check.
 * @param ret           Error code, if applicable.
 * @return              Number of captures found or -1 on failure.
 *
 * @note Use the regex handle passed to this function to extract
 *       matches with GetRegexSubString().
 */
native int MatchRegex(Handle regex, const char[] str, RegexError &ret = REGEX_ERROR_NONE);

/**
 * Returns a matched substring from a regex handle.
 * Substring ids start at 0 and end at captures-1, where captures is the number returned
 * by MatchRegex.
 *
 * @param regex         The regex handle to extract data from.
 * @param str_id        The index of the expression to get - starts at 0, and ends at captures - 1.
 * @param buffer        The buffer to set to the matching substring.
 * @param maxlen        The maximum string length of the buffer.
 * @return              True if a substring was found, False on fail/error
 *
 * @note str_id = 0 is the full captured string, anything else is the capture group index.
 *
 */
native bool GetRegexSubString(Handle regex, int str_id, char[] buffer, int maxlen);

/**
 * Matches a string against a regular expression pattern.
 *
 * @note If you intend on using the same regular expression pattern
 *       multiple times, consider using CompileRegex and MatchRegex
 *       instead of making this function reparse the expression each time.
 *
 * @param str           The string to check.
 * @param pattern       The regular expression pattern.
 * @param flags         General flags for the regular expression.
 * @param error         Error message, if applicable.
 * @param maxLen        Maximum length of the error buffer.
 * @return              Number of substrings found or -1 on failure.
 */
stock int SimpleRegexMatch(const char[] str, const char[] pattern, int flags = 0, char[] error="", int maxLen = 0)
{
	Regex regex = new Regex(pattern, flags, error, maxLen);
	if (!regex)
	{
		return -1;
	}

	int substrings = regex.Match(str);
	delete regex;

	return substrings;
}

/**
 * @endsection
 */

/**
 * Do not edit below this line!
 */
public Extension __ext_regex =
{
	name = "Regex Extension",
	file = "regex.ext",
#if defined AUTOLOAD_EXTENSIONS
	autoload = 1,
#else
	autoload = 0,
#endif
#if defined REQUIRE_EXTENSIONS
	required = 1,
#else
	required = 0,
#endif
};

#if !defined REQUIRE_EXTENSIONS
public void __ext_regex_SetNTVOptional()
{
	MarkNativeAsOptional("CompileRegex");
	MarkNativeAsOptional("MatchRegex");
	MarkNativeAsOptional("GetRegexSubString");
	MarkNativeAsOptional("Regex.Regex");
	MarkNativeAsOptional("Regex.Match");
	MarkNativeAsOptional("Regex.MatchAll");
	MarkNativeAsOptional("Regex.GetSubString");
	MarkNativeAsOptional("Regex.MatchCount");
	MarkNativeAsOptional("Regex.CaptureCount");
	MarkNativeAsOptional("Regex.MatchOffset");
}
#endif
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _sm_logging_included
 #endinput
#endif
#define _sm_logging_included

/**
 * Logs a plugin message to the SourceMod logs.  The log message will be
 * prefixed by the plugin's logtag (filename).
 *
 * @param format        String format.
 * @param ...           Format arguments.
 */
native void LogMessage(const char[] format, any ...);

/**
 * Logs a message to any file.  The log message will be in the normal
 * SourceMod format, with the plugin logtag prepended.
 *
 * @param file          File to write the log message in.
 * @param format        String format.
 * @param ...           Format arguments.
 * @error               File could not be opened/written.
 */
native void LogToFile(const char[] file, const char[] format, any ...);

/**
 * Same as LogToFile(), except no plugin logtag is prepended.
 *
 * @param file          File to write the log message in.
 * @param format        String format.
 * @param ...           Format arguments.
 * @error               File could not be opened/written.
 */
native void LogToFileEx(const char[] file, const char[] format, any ...);

/**
 * Logs an action from a command or event whereby interception and routing may
 * be important.  This is intended to be a logging version of ShowActivity().
 *
 * @param client        Client performing the action, 0 for server, or -1 if not
 *                      applicable.
 * @param target        Client being targetted, or -1 if not applicable.
 * @param message       Message format.
 * @param ...           Message formatting parameters.
 */
native void LogAction(int client, int target, const char[] message, any ...);

/**
 * Logs a plugin error message to the SourceMod logs.
 *
 * @param format        String format.
 * @param ...           Format arguments.
 */
native void LogError(const char[] format, any ...);

/**
 * Called when an action is going to be logged.
 *
 * @param source        Handle to the object logging the action, or INVALID_HANDLE
 *                      if Core is logging the action.
 * @param ident         Type of object logging the action (plugin, ext, or core).
 * @param client        Client the action is from; 0 for server, -1 if not applicable.
 * @param target        Client the action is targetting, or -1 if not applicable.
 * @param message       Message that is being logged.
 * @return              Plugin_Continue will perform the default logging behavior.
 *                      Plugin_Handled will stop Core from logging the message.
 *                      Plugin_Stop is the same as Handled, but prevents any other
 *                      plugins from handling the message.
 */
forward Action OnLogAction(Handle source,
						   Identity ident,
						   int client,
						   int target,
						   const char[] message);

/**
 * Called when a game log message is received.
 *
 * Any Log*() functions called within this callback will not recursively
 * pass through.  That is, they will log directly, bypassing this callback.
 *
 * Note that this does not capture log messages from the engine.  It only
 * captures log messages being sent from the game/mod itself.
 *
 * @param message       Message contents.
 * @return              Plugin_Handled or Plugin_Stop will prevent the message
 *                      from being written to the log file.
 */
typedef GameLogHook = function Action (const char[] message);

/**
 * Adds a game log hook.
 *
 * @param hook          Hook function.
 */
native void AddGameLogHook(GameLogHook hook);

/**
 * Removes a game log hook.
 *
 * @param hook          Hook function.
 */
native void RemoveGameLogHook(GameLogHook hook);
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2011 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */
 
#if defined _clientprefs_included
 #endinput
#endif
#define _clientprefs_included

/**
 * Cookie access types for client viewing
 */
enum CookieAccess
{
	CookieAccess_Public,            /**< Visible and Changeable by users */
	CookieAccess_Protected,         /**< Read only to users */
	CookieAccess_Private            /**< Completely hidden cookie */
};

/**
 * Cookie Prefab menu types
 */
enum CookieMenu
{
	CookieMenu_YesNo,           /**< Yes/No menu with "yes"/"no" results saved into the cookie */
	CookieMenu_YesNo_Int,       /**< Yes/No menu with 1/0 saved into the cookie */
	CookieMenu_OnOff,           /**< On/Off menu with "on"/"off" results saved into the cookie */
	CookieMenu_OnOff_Int        /**< On/Off menu with 1/0 saved into the cookie */
};

enum CookieMenuAction
{
	/**
	 * An option is being drawn for a menu.
	 *
	 * INPUT : Client index and data if available.
	 * OUTPUT: Buffer for rendering, maxlength of buffer.
	 */
	CookieMenuAction_DisplayOption = 0,
	
	/**
	 * A menu option has been selected.
	 *
	 * INPUT : Client index and any data if available.
	 */
	CookieMenuAction_SelectOption = 1
};

/**
 * Cookie Menu Callback prototype
 *
 * @param client        Client index.
 * @param action        CookieMenuAction being performed.
 * @param info          Info data passed.
 * @param buffer        Outbut buffer.
 * @param maxlen        Max length of the output buffer.
 */
typedef CookieMenuHandler = function void (
  int client,
  CookieMenuAction action,
  any info,
  char[] buffer,
  int maxlen
);

/**
 * Note:
 * 
 * A successful return value/result on any client prefs native only guarantees that the local cache has been updated.
 * Database connection problems can still prevent the data from being permanently saved. Connection problems will be logged as
 * errors by the clientprefs extension.
 */

methodmap Cookie < Handle {
	// Creates a new Client preference cookie.
	//
	// Handles returned can be closed via CloseHandle() when
	// no longer needed.
	//
	// @param name          Name of the new preference cookie.
	// @param description   Optional description of the preference cookie.
	// @param access        What CookieAccess level to assign to this cookie.
	// @return              A handle to the newly created cookie. If the cookie already
	//                      exists, a handle to it will still be returned.
	// @error               Cookie name is blank.
	public native Cookie(const char[] name, const char[] description, CookieAccess access);

	// Searches for a Client preference cookie.
	//
	// Handles returned by Cookie.Find can be closed via CloseHandle() when
	// no longer needed.
	//
	// @param name          Name of cookie to find.
	// @return              A handle to the cookie if it is found. INVALID_HANDLE otherwise.
	public static native Cookie Find(const char[] name);

	// Set the value of a Client preference cookie.
	//
	// @param client        Client index.
	// @param value         String value to set.
	// @error               Invalid cookie handle or invalid client index.
	public native void Set(int client, const char[] value);

	// Retrieve the value of a Client preference cookie.
	//
	// @param client        Client index.
	// @param buffer        Copyback buffer for value.
	// @param maxlen        Maximum length of the buffer.
	// @error               Invalid cookie handle or invalid client index.
	public native void Get(int client, char[] buffer, int maxlen);

	// Sets the value of a Client preference cookie based on an authID string.
	//
	// @param authID        String Auth/STEAM ID of player to set.
	// @param value         String value to set.
	// @error               Invalid cookie handle.
	public native void SetByAuthId(const char[] authID, const char[] value);

	// Add a new prefab item to the client cookie settings menu.
	//
	// Note: This handles everything automatically and does not require a callback
	//
	// @param type          A CookieMenu prefab menu type.
	// @param display       Text to show on the menu.
	// @param handler       Optional handler callback for translations and output on selection
	// @param info          Info data to pass to the callback.
	// @error               Invalid cookie handle.
	public native void SetPrefabMenu(CookieMenu type, const char[] display, CookieMenuHandler handler=INVALID_FUNCTION, any info=0);

	// Returns the last updated timestamp for a client cookie
	//
	// @param client        Client index.
	// @return              Last updated timestamp.
	public native int GetClientTime(int client);

	// Returns the access level of a cookie
	//
	// @return              CookieAccess access level.
	// @error               Invalid cookie handle.
	property CookieAccess AccessLevel {
		public native get();
	}
};

/**
 * Creates a new Client preference cookie.
 *
 * Handles returned by RegClientCookie can be closed via CloseHandle() when
 * no longer needed.
 *
 * @param name          Name of the new preference cookie.
 * @param description   Optional description of the preference cookie.
 * @param access        What CookieAccess level to assign to this cookie.
 * @return              A handle to the newly created cookie. If the cookie already
 *                      exists, a handle to it will still be returned.
 * @error               Cookie name is blank.
 */
native Handle RegClientCookie(const char[] name, const char[] description, CookieAccess access);

/**
 * Searches for a Client preference cookie.
 *
 * Handles returned by FindClientCookie can be closed via CloseHandle() when
 * no longer needed.
 *
 * @param name          Name of cookie to find.
 * @return              A handle to the cookie if it is found. INVALID_HANDLE otherwise.
 */
native Handle FindClientCookie(const char[] name);

/**
 * Set the value of a Client preference cookie.
 *
 * @param client        Client index.
 * @param cookie        Client preference cookie handle.
 * @param value         String value to set.
 * @error               Invalid cookie handle or invalid client index.
 */
native void SetClientCookie(int client, Handle cookie, const char[] value);

/**
 * Retrieve the value of a Client preference cookie.
 *
 * @param client        Client index.
 * @param cookie        Client preference cookie handle.
 * @param buffer        Copyback buffer for value.
 * @param maxlen        Maximum length of the buffer.
 * @error               Invalid cookie handle or invalid client index.
 */
native void GetClientCookie(int client, Handle cookie, char[] buffer, int maxlen);

/**
 * Sets the value of a Client preference cookie based on an authID string.
 *
 * @param authID        String Auth/STEAM ID of player to set.
 * @param cookie        Client preference cookie handle.
 * @param value         String value to set.
 * @error               Invalid cookie handle.
 */
native void SetAuthIdCookie(const char[] authID, Handle cookie, const char[] value);

/**
 * Checks if a clients cookies have been loaded from the database.
 *
 * @param client        Client index.
 * @return              True if loaded, false otherwise.
 * @error               Invalid client index.
 */
native bool AreClientCookiesCached(int client);

/**
 * Called once a client's saved cookies have been loaded from the database.
 *
 * @param client        Client index.
 */
forward void OnClientCookiesCached(int client);

/**
 * Add a new prefab item to the client cookie settings menu.
 *
 * Note: This handles everything automatically and does not require a callback
 *
 * @param cookie        Client preference cookie handle.
 * @param type          A CookieMenu prefab menu type.
 * @param display       Text to show on the menu.
 * @param handler       Optional handler callback for translations and output on selection
 * @param info          Info data to pass to the callback.
 * @error               Invalid cookie handle.
 */
native void SetCookiePrefabMenu(Handle cookie, CookieMenu type, const char[] display, CookieMenuHandler handler=INVALID_FUNCTION, any info=0);

/**
 * Adds a new item to the client cookie settings menu.
 *
 * Note: This only adds the top level menu item. You need to handle any submenus from the callback.
 *
 * @param handler       A MenuHandler callback function.
 * @param info          Data to pass to the callback.
 * @param display       Text to show on the menu.
 * @error               Invalid cookie handle.
 */
native void SetCookieMenuItem(CookieMenuHandler handler, any info, const char[] display);

/**
 * Displays the settings menu to a client.
 *
 * @param client        Client index.
 */
native void ShowCookieMenu(int client);

/**
 * Gets a cookie iterator.  Must be freed with CloseHandle().
 *
 * @return              A new cookie iterator.
 */
native Handle GetCookieIterator();

/**
 * Reads a cookie iterator, then advances to the next cookie if any.
 *
 * @param iter          Cookie iterator Handle.
 * @param name          Name buffer.
 * @param nameLen       Name buffer size.
 * @param access        Access level of the cookie.
 * @param desc          Cookie description buffer.
 * @param descLen       Cookie description buffer size.
 * @return              True on success, false if there are no more commands.
 */
native bool ReadCookieIterator(Handle iter, 
								char[] name, 
								int nameLen,
								CookieAccess &access, 
								char[] desc="", 
								int descLen=0);

/**
 * Returns the access level of a cookie
 *
 * @param cookie        Client preference cookie handle.
 * @return              CookieAccess access level.
 * @error               Invalid cookie handle.
 */
native CookieAccess GetCookieAccess(Handle cookie);

/**
 * Returns the last updated timestamp for a client cookie
 *
 * @param client        Client index.
 * @param cookie        Cookie handle.
 * @return              Last updated timestamp.
 */
native int GetClientCookieTime(int client, Handle cookie);

/**
 * Do not edit below this line!
 */
public Extension __ext_cprefs = 
{
	name = "Client Preferences",
	file = "clientprefs.ext",
	autoload = 1,
#if defined REQUIRE_EXTENSIONS
	required = 1,
#else
	required = 0,
#endif
};

#if !defined REQUIRE_EXTENSIONS
public void __ext_cprefs_SetNTVOptional()
{
	MarkNativeAsOptional("RegClientCookie");
	MarkNativeAsOptional("FindClientCookie");
	MarkNativeAsOptional("SetClientCookie");
	MarkNativeAsOptional("GetClientCookie");
	MarkNativeAsOptional("SetAuthIdCookie");
	MarkNativeAsOptional("AreClientCookiesCached");
	MarkNativeAsOptional("SetCookiePrefabMenu");
	MarkNativeAsOptional("SetCookieMenuItem");
	MarkNativeAsOptional("ShowCookieMenu");
	MarkNativeAsOptional("GetCookieIterator");
	MarkNativeAsOptional("ReadCookieIterator");
	MarkNativeAsOptional("GetCookieAccess");
	MarkNativeAsOptional("GetClientCookieTime");

	MarkNativeAsOptional("Cookie.Cookie");
	MarkNativeAsOptional("Cookie.Find");
	MarkNativeAsOptional("Cookie.Set");
	MarkNativeAsOptional("Cookie.Get");
	MarkNativeAsOptional("Cookie.SetByAuthId");
	MarkNativeAsOptional("Cookie.SetPrefabMenu");
	MarkNativeAsOptional("Cookie.GetClientTime");
	MarkNativeAsOptional("Cookie.AccessLevel.get");
}
#endif
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2017 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _sdktools_variant_t_included
 #endinput
#endif
#define _sdktools_variant_t_included

/**
 * Sets a bool value in the global variant object.
 *
 * @param val           Input value.
 */
native void SetVariantBool(bool val);

/**
 * Sets a string in the global variant object.
 *
 * @param str           Input string.
 */
native void SetVariantString(const char[] str);

/**
 * Sets an integer value in the global variant object.
 *
 * @param val           Input value.
 */
native void SetVariantInt(int val);

/**
 * Sets a floating point value in the global variant object.
 *
 * @param val           Input value.
 */
native void SetVariantFloat(float val);

/**
 * Sets a 3D vector in the global variant object.
 *
 * @param vec           Input vector.
 */
native void SetVariantVector3D(const float vec[3]);

/**
 * Sets a 3D position vector in the global variant object.
 *
 * @param vec           Input position vector.
 */
native void SetVariantPosVector3D(const float vec[3]);

/**
 * Sets a color in the global variant object.
 *
 * @param color         Input color.
 */
native void SetVariantColor(const int color[4]);

/**
 * Sets an entity in the global variant object.
 *
 * @param entity        Entity index.
 * @error               Invalid entity index.
 */
native void SetVariantEntity(int entity);
/**
 * vim: set ts=4 sw=4 tw=99 noet :
 * =============================================================================
 * SourceMod (C)2004-2014 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _files_included
 #endinput
#endif
#define _files_included

/**
 * @global All paths in SourceMod natives are relative to the mod folder
 * unless otherwise noted.
 *
 * Most functions in SourceMod (at least, ones that deal with direct
 * file manipulation) will support an alternate path specification.
 *
 * If the path starts with the string "file://" and the PathType is
 * not relative, then the "file://" portion is stripped off, and the
 * rest of the path is used without any modification (except for
 * correcting slashes).  This can be used to override the path
 * builder to supply alternate absolute paths.  Examples:
 *
 * file://C:/Temp/file.txt
 * file:///tmp/file.txt
 */

/**
 * File inode types.
 */
enum FileType
{
	FileType_Unknown = 0,   /* Unknown file type (device/socket) */
	FileType_Directory = 1, /* File is a directory */
	FileType_File = 2       /* File is a file */
};

/**
 * File time modes.
 */
enum FileTimeMode
{
	FileTime_LastAccess = 0,    /* Last access (does not work on FAT) */
	FileTime_Created = 1,       /* Creation (does not work on FAT) */
	FileTime_LastChange = 2     /* Last modification */
};

#define PLATFORM_MAX_PATH 256   /**< Maximum path length. */

#define SEEK_SET 0              /**< Seek from start. */
#define SEEK_CUR 1              /**< Seek from current position. */
#define SEEK_END 2              /**< Seek from end position. */

/**
 * Path types.
 */
enum PathType
{
	Path_SM,                    /**< SourceMod root folder */
};

// A DirectoryListing iterates over the contents of a directory. To obtain a
// DirectoryListing handle, call OpenDirectory().
methodmap DirectoryListing < Handle
{
	// Reads the current directory entry as a local filename, then moves to the
	// next file.
	//
	// Note: Both the '.' and '..' automatic directory entries will be retrieved.
	//
	// @param buffer          String buffer to hold directory name.
	// @param maxlength       Maximum size of string buffer.
	// @param type            Optional variable to store the file type.
	// @return                True on success, false if there are no more files to read.
	public native bool GetNext(char[] buffer, int maxlength, FileType &type=FileType_Unknown);
};

// A File object can be obtained by calling OpenFile(). File objects should be
// closed with delete or Close(). Note that, "delete file" does not
// actually delete the file, it just closes the handle.
methodmap File < Handle
{
	// Close the file handle. This is the same as using CloseHandle() or delete.
	public void Close() {
		CloseHandle(this);
	}

	// Reads a line of text from a file.
	//
	// @param buffer          String buffer to hold the line.
	// @param maxlength       Maximum size of string buffer.
	// @return                True on success, false otherwise.
	public native bool ReadLine(char[] buffer, int maxlength);

	// Reads binary data from a file.
	//
	// @param items           Array to store each item read.
	// @param num_items       Number of items to read into the array.
	// @param size            Size of each element, in bytes, to be read.
	//                        Valid sizes are 1, 2, or 4.
	// @return                Number of elements read, or -1 on error.
	public native int Read(int[] items, int num_items, int size);

	// Reads a UTF8 or ANSI string from a file.
	//
	// @param buffer          Buffer to store the string.
	// @param max_size        Maximum size of the string buffer.
	// @param read_count      If -1, reads until a null terminator is encountered in
	//                        the file.  Otherwise, read_count bytes are read
	//                        into the buffer provided.  In this case the buffer
	//                        is not explicitly null terminated, and the buffer
	//                        will contain any null terminators read from the file.
	// @return                Number of characters written to the buffer, or -1
	//                        if an error was encountered.
	// @error                 read_count > max_size.
	public native int ReadString(char[] buffer, int max_size, int read_count=-1);

	// Writes binary data to a file.
	//
	// @param items           Array of items to write.  The data is read directly.
	//                        That is, in 1 or 2-byte mode, the lower byte(s) in
	//                        each cell are used directly, rather than performing
	//                        any casts from a 4-byte number to a smaller number.
	// @param num_items       Number of items in the array.
	// @param size            Size of each item in the array in bytes.
	//                        Valid sizes are 1, 2, or 4.
	// @return                True on success, false on error.
	public native bool Write(const int[] items, int num_items, int size);

	// Writes a binary string to a file.
	//
	// @param buffer          String to write.
	// @param term            True to append NUL terminator, false otherwise.
	// @return                True on success, false on error.
	public native bool WriteString(const char[] buffer, bool term);

	// Writes a line of text to a text file.  A newline is automatically appended.
	//
	// @param hndl            Handle to the file.
	// @param format          Formatting rules.
	// @param ...             Variable number of format parameters.
	// @return                True on success, false otherwise.
	public native bool WriteLine(const char[] format, any ...);

	// Reads a single int8 (byte) from a file. The returned value is sign-
	// extended to an int32.
	//
	// @param data            Variable to store the data read.
	// @return                True on success, false on failure.
	public native bool ReadInt8(int &data);

	// Reads a single uint8 (unsigned byte) from a file. The returned value is
	// zero-extended to an int32.
	//
	// @param data            Variable to store the data read.
	// @return                True on success, false on failure.
	public native bool ReadUint8(int &data);

	// Reads a single int16 (short) from a file. The value is sign-extended to
	// an int32.
	//
	// @param data            Variable to store the data read.
	// @return                True on success, false on failure.
	public native bool ReadInt16(int &data);

	// Reads a single unt16 (unsigned short) from a file. The value is zero-
	// extended to an int32.
	//
	// @param data            Variable to store the data read.
	// @return                True on success, false on failure.
	public native bool ReadUint16(int &data);

	// Reads a single int32 (int/cell) from a file.
	//
	// @param data            Variable to store the data read.
	// @return                True on success, false on failure.
	public native bool ReadInt32(int &data);

	// Writes a single int8 (byte) to a file.
	//
	// @param data            Data to write (truncated to an int8).
	// @return                True on success, false on failure.
	public native bool WriteInt8(int data);

	// Writes a single int16 (short) to a file.
	//
	// @param data            Data to write (truncated to an int16).
	// @return                True on success, false on failure.
	public native bool WriteInt16(int data);

	// Writes a single int32 (int/cell) to a file.
	//
	// @param data            Data to write.
	// @return                True on success, false on failure.
	public native bool WriteInt32(int data);

	// Tests if the end of file has been reached.
	//
	// @return                True if end of file has been reached, false otherwise.
	public native bool EndOfFile();

	// Sets the file position indicator.
	//
	// @param position        Position relative to what is specified in whence.
	// @param where           SEEK_ constant value of where to see from.
	// @return                True on success, false otherwise.
	public native bool Seek(int position, int where);

	// Flushes a file's buffered output; any buffered output
	// is immediately written to the file.
	// 
	// @return              True on success or use_valve_fs specified with OpenFile,
	//                      otherwise false on failure.
	public native bool Flush();
	
	// Get the current position in the file; returns -1 on failure.
	property int Position {
		public native get();
	}
}

/**
 * Builds a path relative to the SourceMod folder.  This should be used instead of
 * directly referencing addons/sourcemod, in case users change the name of their
 * folder layout.
 *
 * @param type          Type of path to build as the base.
 * @param buffer        Buffer to store the path.
 * @param maxlength     Maximum length of buffer.
 * @param fmt           Format string.
 * @param ...           Format arguments.
 * @return              Number of bytes written to buffer (not including null terminator).
 */
native int BuildPath(PathType type, char[] buffer, int maxlength, const char[] fmt, any ...);

/**
 * Opens a directory/folder for contents enumeration.
 *
 * @note Directories are closed with CloseHandle() or delete.
 * @note Directories Handles can be cloned.
 * @note OpenDirectory() supports the "file://" notation.
 *
 * @param path          Path to open.
 * @param use_valve_fs  If true, the Valve file system will be used instead.
 *                      This can be used to find files existing in any of
 *                      the Valve search paths, rather than solely files
 *                      existing directly in the gamedir.
 * @param valve_path_id If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths.
 * @return              A Handle to the directory, null on error.
 */
native DirectoryListing OpenDirectory(const char[] path, bool use_valve_fs=false, const char[] valve_path_id="GAME");

/**
 * Reads the current directory entry as a local filename, then moves to the next file.
 *
 * @note Contents of buffers are undefined when returning false.
 * @note Both the '.' and '..' automatic directory entries will be retrieved for Windows and Linux.
 *
 * @param dir           Handle to a directory.
 * @param buffer        String buffer to hold directory name.
 * @param maxlength     Maximum size of string buffer.
 * @param type          Optional variable to store the file type.
 * @return              True on success, false if there are no more files to read.
 * @error               Invalid or corrupt Handle.
 */
native bool ReadDirEntry(Handle dir, char[] buffer, int maxlength, FileType &type=FileType_Unknown);

/**
 * Opens or creates a file, returning a File handle on success. File handles
 * should be closed with delete or CloseHandle().
 *
 * The open mode may be one of the following strings:
 *   "r": Open an existing file for reading.
 *   "w": Create a file for writing, or truncate (delete the contents of) an
 *        existing file and then open it for writing.
 *   "a": Create a file for writing, or open an existing file such that writes
 *        will be appended to the end.
 *   "r+": Open an existing file for both reading and writing.
 *   "w+": Create a file for reading and writing, or truncate an existing file
 *         and then open it for reading and writing.
 *   "a+": Create a file for both reading and writing, or open an existing file
 *         such that writes will be appended to the end.
 *
 * The open mode may also contain an additional character after "r", "w", or "a",
 * but before any "+" sign. This character may be "b" (indicating binary mode) or
 * "t" (indicating text mode). By default, "text" mode is implied. On Linux and
 * Mac, this has no distinction from binary mode. On Windows, it causes the '\n'
 * character (0xA) to be written as "\r\n" (0xD, 0xA).
 *
 * Example: "rb" opens a binary file for writing; "at" opens a text file for
 * appending.
 *
 * @param file          File to open.
 * @param mode          Open mode.
 * @param use_valve_fs  If true, the Valve file system will be used instead.
 *                      This can be used to find files existing in valve
 *                      search paths, rather than solely files existing directly
 *                      in the gamedir.
 * @param valve_path_id If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths.
 * @return              A File handle, or null if the file could not be opened.
 */
native File OpenFile(const char[] file, const char[] mode, bool use_valve_fs=false, const char[] valve_path_id="GAME");

/**
 * Deletes a file.
 *
 * @param path          Path of the file to delete.
 * @param use_valve_fs  If true, the Valve file system will be used instead.
 *                      This can be used to delete files existing in the Valve
 *                      search path, rather than solely files existing directly
 *                      in the gamedir.
 * @param valve_path_id If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths.
 * @return              True on success, false on failure or if file not immediately removed.
 */
native bool DeleteFile(const char[] path, bool use_valve_fs=false, const char[] valve_path_id="DEFAULT_WRITE_PATH");

/**
 * Reads a line from a text file.
 *
 * @param hndl          Handle to the file.
 * @param buffer        String buffer to hold the line.
 * @param maxlength     Maximum size of string buffer.
 * @return              True on success, false otherwise.
 */
native bool ReadFileLine(Handle hndl, char[] buffer, int maxlength);

/**
 * Reads binary data from a file.
 *
 * @param hndl          Handle to the file.
 * @param items         Array to store each item read.
 * @param num_items     Number of items to read into the array.
 * @param size          Size of each element, in bytes, to be read.
 *                      Valid sizes are 1, 2, or 4.
 * @return              Number of elements read, or -1 on error.
 */
native int ReadFile(Handle hndl, int[] items, int num_items, int size);

/**
 * Reads a UTF8 or ANSI string from a file.
 *
 * @param hndl          Handle to the file.
 * @param buffer        Buffer to store the string.
 * @param max_size      Maximum size of the string buffer.
 * @param read_count    If -1, reads until a null terminator is encountered in
 *                      the file.  Otherwise, read_count bytes are read
 *                      into the buffer provided.  In this case the buffer
 *                      is not explicitly null terminated, and the buffer
 *                      will contain any null terminators read from the file.
 * @return              Number of characters written to the buffer, or -1
 *                      if an error was encountered.
 * @error               Invalid Handle, or read_count > max_size.
 */
native int ReadFileString(Handle hndl, char[] buffer, int max_size, int read_count=-1);

/**
 * Writes binary data to a file.
 *
 * @param hndl          Handle to the file.
 * @param items         Array of items to write.  The data is read directly.
 *                      That is, in 1 or 2-byte mode, the lower byte(s) in
 *                      each cell are used directly, rather than performing
 *                      any casts from a 4-byte number to a smaller number.
 * @param num_items     Number of items in the array.
 * @param size          Size of each item in the array in bytes.
 *                      Valid sizes are 1, 2, or 4.
 * @return              True on success, false on error.
 * @error               Invalid Handle.
 */
native bool WriteFile(Handle hndl, const int[] items, int num_items, int size);

/**
 * Writes a binary string to a file.
 *
 * @param hndl          Handle to the file.
 * @param buffer        String to write.
 * @param term          True to append NUL terminator, false otherwise.
 * @return              True on success, false on error.
 * @error               Invalid Handle.
 */
native bool WriteFileString(Handle hndl, const char[] buffer, bool term);

/**
 * Writes a line of text to a text file.  A newline is automatically appended.
 *
 * @param hndl          Handle to the file.
 * @param format        Formatting rules.
 * @param ...           Variable number of format parameters.
 * @return              True on success, false otherwise.
 * @error               Invalid Handle.
 */
native bool WriteFileLine(Handle hndl, const char[] format, any ...);

/**
 * Reads a single binary cell from a file.
 *
 * @param hndl          Handle to the file.
 * @param data          Variable to store the data read.
 * @param size          Size of the data to read in bytes.  Valid
 *                      sizes are 1, 2, or 4 bytes.
 * @return              Number of elements read (max 1), or -1 on error.
 * @error               Invalid Handle.
 */
stock int ReadFileCell(Handle hndl, int &data, int size)
{
	int ret;
	int array[1];

	if ((ret = ReadFile(hndl, array, 1, size)) == 1)
	{
		data = array[0];
	}

	return ret;
}

/**
 * Writes a single binary cell to a file.
 *
 * @param hndl          Handle to the file.
 * @param data          Cell to write to the file.
 * @param size          Size of the data to read in bytes.  Valid
 *                      sizes are 1, 2, or 4 bytes.  If the size
 *                      is less than 4 bytes, the data is truncated
 *                      rather than casted.  That is, only the lower
 *                      bits will be read.
 * @return              True on success, false on error.
 * @error               Invalid Handle.
 */
stock bool WriteFileCell(Handle hndl, int data, int size)
{
	int array[1];
	array[0] = data;

	return WriteFile(hndl, array, 1, size);
}

/**
 * Tests if the end of file has been reached.
 *
 * @param file          Handle to the file.
 * @return              True if end of file has been reached, false otherwise.
 * @error               Invalid Handle.
 */
native bool IsEndOfFile(Handle file);

/**
 * Sets the file position indicator.
 *
 * @param file          Handle to the file.
 * @param position      Position relative to what is specified in whence.
 * @param where         SEEK_ constant value of where to see from.
 * @return              True on success, false otherwise.
 * @error               Invalid Handle.
 */
native bool FileSeek(Handle file, int position, int where);

/**
 * Get current position in the file.
 *
 * @param file          Handle to the file.
 * @return              Value for the file position indicator.
 * @error               Invalid Handle.
 */
native int FilePosition(Handle file);

/**
 * Checks if a file exists.
 *
 * @param path          Path to the file.
 * @param use_valve_fs  If true, the Valve file system will be used instead.
 *                      This can be used to find files existing in any of
 *                      the Valve search paths, rather than solely files
 *                      existing directly in the gamedir.
 * @param valve_path_id If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths.
 * @return              True if the file exists, false otherwise.
 */
native bool FileExists(const char[] path, bool use_valve_fs=false, const char[] valve_path_id="GAME");

/**
 * Renames a file.
 *
 * @param newpath       New path to the file.
 * @param oldpath       Path to the existing file.
 * @param use_valve_fs  If true, the Valve file system will be used instead.
 *                      This can be used to rename files in the game's
 *                      Valve search paths, rather than directly in the gamedir.
 * @param valve_path_id If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths.
 * @return              True on success or use_valve_fs specified, false otherwise.
 */
native bool RenameFile(const char[] newpath, const char[] oldpath, bool use_valve_fs=false, const char[] valve_path_id="DEFAULT_WRITE_PATH");

/**
 * Checks if a directory exists.
 *
 * @param path          Path to the directory.
 * @param use_valve_fs  If true, the Valve file system will be used instead.
 *                      This can be used to find files existing in any of
 *                      the Valve search paths, rather than solely files
 *                      existing directly in the gamedir.
 * @param valve_path_id If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths.
 * @return              True if the directory exists, false otherwise.
 */
native bool DirExists(const char[] path, bool use_valve_fs=false, const char[] valve_path_id="GAME");

/**
 * Get the file size in bytes.
 *
 * @param path          Path to the file.
 * @param use_valve_fs  If true, the Valve file system will be used instead.
 *                      This can be used to find files existing in any of
 *                      the Valve search paths, rather than solely files
 *                      existing directly in the gamedir.
 * @param valve_path_id If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths.
 * @return              File size in bytes, -1 if file not found.
 */
native int FileSize(const char[] path, bool use_valve_fs=false, const char[] valve_path_id="GAME");

/**
 * Flushes a file's buffered output; any buffered output
 * is immediately written to the file.
 *
 * @param file          Handle to the file.
 * @return              True on success or use_valve_fs specified with OpenFile,
 *                      otherwise false on failure.
 */
native bool FlushFile(Handle file);

/**
 * Removes a directory.
 * @note On most Operating Systems you cannot remove a directory which has files inside it.
 *
 * @param path          Path to the directory.
 * @return              True on success, false otherwise.
 */
native bool RemoveDir(const char[] path);

#define FPERM_U_READ        0x0100  /* User can read. */
#define FPERM_U_WRITE       0x0080  /* User can write. */
#define FPERM_U_EXEC        0x0040  /* User can exec. */
#define FPERM_G_READ        0x0020  /* Group can read. */
#define FPERM_G_WRITE       0x0010  /* Group can write. */
#define FPERM_G_EXEC        0x0008  /* Group can exec. */
#define FPERM_O_READ        0x0004  /* Anyone can read. */
#define FPERM_O_WRITE       0x0002  /* Anyone can write. */
#define FPERM_O_EXEC        0x0001  /* Anyone can exec. */

/**
 * Creates a directory.
 *
 * @param path          Path to create.
 * @param mode          Permissions (default is o=rx,g=rx,u=rwx).  Note that folders must have
 *                      the execute bit set on Linux.  On Windows, the mode is ignored.
 * @param use_valve_fs  If true, the Valve file system will be used instead.
 *                      This can be used to create folders in the game's
 *                      Valve search paths, rather than directly in the gamedir.
 * @param valve_path_id If use_valve_fs, a search path from gameinfo or NULL_STRING for default.
 *                      In this case, mode is ignored.
 * @return              True on success, false otherwise.
 */
native bool CreateDirectory(const char[] path, int mode, bool use_valve_fs=false, const char[] valve_path_id="DEFAULT_WRITE_PATH");

/**
 * Changes a file or directories permissions.
 *
 * @param path          Path to the file.
 * @param mode          Permissions to set.
 * @return              True on success, false otherwise.
 */
native bool SetFilePermissions(const char[] path, int mode);

/**
 * Returns a file timestamp as a unix timestamp.
 *
 * @param file          File name.
 * @param tmode         Time mode.
 * @return              Time value, or -1 on failure.
 */
native int GetFileTime(const char[] file, FileTimeMode tmode);

/**
 * Same as LogToFile(), except uses an open file Handle.  The file must
 * be opened in text appending mode.
 *
 * @param hndl          Handle to the file.
 * @param message       Message format.
 * @param ...           Message format parameters.
 * @error               Invalid Handle.
 */
native void LogToOpenFile(Handle hndl, const char[] message, any ...);

/**
 * Same as LogToFileEx(), except uses an open file Handle.  The file must
 * be opened in text appending mode.
 *
 * @param hndl          Handle to the file.
 * @param message       Message format.
 * @param ...           Message format parameters.
 * @error               Invalid Handle.
 */
native void LogToOpenFileEx(Handle hndl, const char[] message, any ...);
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _sdktools_engine_included
 #endinput
#endif
#define _sdktools_engine_included

#define MAX_LIGHTSTYLES 64

/**
 * Sets a client's "viewing entity."
 *
 * @param client        Client index.
 * @param entity        Entity index.
 * @error               Invalid client or entity, lack of mod support, or client not in 
 *                      game.
 */
native void SetClientViewEntity(int client, int entity);

/**
 * Sets a light style.
 *
 * @param style         Light style (from 0 to MAX_LIGHTSTYLES-1)
 * @param value         Light value string (see world.cpp/light.cpp in dlls)
 * @error               Light style index is out of range.
 */
native void SetLightStyle(int style, const char[] value);

/**
 * Returns the client's eye position.
 *
 * @param client        Player's index.
 * @param pos           Destination vector to store the client's eye position.
 * @error               Invalid client index, client not in game, or no mod support.
 */
native void GetClientEyePosition(int client, float pos[3]);
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _banning_included
 #endinput
#endif
#define _banning_included

#define BANFLAG_AUTO        (1<<0)  /**< Auto-detects whether to ban by steamid or IP */
#define BANFLAG_IP          (1<<1)  /**< Always ban by IP address */
#define BANFLAG_AUTHID      (1<<2)  /**< Always ban by authstring (for BanIdentity) if possible */
#define BANFLAG_NOKICK      (1<<3)  /**< Does not kick the client */

/**
 * Called for calls to BanClient() with a non-empty command.
 *
 * @param client        Client being banned.
 * @param time          Time the client is being banned for (0 = permanent).
 * @param flags         One if AUTHID or IP will be enabled.  If AUTO is also 
 *                      enabled, it means Core autodetected which to use.
 * @param reason        Reason passed via BanClient().
 * @param kick_message  Kick message passed via BanClient().
 * @param command       Command string to identify the ban source.
 * @param source        Source value passed via BanClient().
 * @return              Plugin_Handled to block the actual server banning.
 *                      Kicking will still occur.
 */
forward Action OnBanClient(int client,
						   int time, 
						   int flags, 
						   const char[] reason, 
						   const char[] kick_message, 
						   const char[] command,
						   any source);

/**
 * Called for calls to BanIdentity() with a non-empty command.
 *
 * @param identity      Identity string being banned (authstring or ip).
 * @param time          Time the client is being banned for (0 = permanent).
 * @param flags         Ban flags (only IP or AUTHID are valid here).
 * @param reason        Reason passed via BanIdentity().
 * @param command       Command string to identify the ban source.
 * @param source        Source value passed via BanIdentity().
 * @return              Plugin_Handled to block the actual server banning.
 */
forward Action OnBanIdentity(const char[] identity,
							 int time,
							 int flags,
							 const char[] reason,
							 const char[] command,
							 any source);

/**
 * Called for calls to RemoveBan() with a non-empty command.
 *
 * @param identity      Identity string being banned (authstring or ip).
 * @param flags         Ban flags (only IP or AUTHID are valid here).
 * @param command       Command string to identify the ban source.
 * @param source        Source value passed via BanIdentity().
 * @return              Plugin_Handled to block the actual unbanning.
 */
forward Action OnRemoveBan(const char[] identity,
						   int flags,
						   const char[] command,
						   any source);

/**
 * Bans a client.
 *
 * @param client        Client being banned.
 * @param time          Time (in minutes) to ban (0 = permanent).
 * @param flags         Flags for controlling the ban mechanism.  If AUTHID 
 *                      is set and no AUTHID is available, the ban will fail 
 *                      unless AUTO is also flagged.
 * @param reason        Reason to ban the client for.
 * @param kick_message  Message to display to the user when kicking.
 * @param command       Command string to identify the source.  If this is left 
 *                      empty, then the OnBanClient forward will not be called.
 * @param source        A source value that could be interpreted as a player 
 *                      index of any sort (not actually checked by Core).
 * @return              True on success, false on failure.
 * @error               Invalid client index or client not in game.
 */
native bool BanClient(int client, 
					  int time, 
					  int flags, 
					  const char[] reason, 
					  const char[] kick_message="", 
					  const char[] command="",
					  any source=0);

/**
 * Bans an identity (either an IP address or auth string).
 *
 * @param identity      String to ban (ip or authstring).
 * @param time          Time to ban for (0 = permanent).
 * @param flags         Flags (only IP and AUTHID are valid flags here).
 * @param reason        Ban reason string.
 * @param command       Command string to identify the source.  If this is left 
 *                      empty, then the OnBanIdentity forward will not be called.
 * @param source        A source value that could be interpreted as a player
 *                      index of any sort (not actually checked by Core).
 * @return              True on success, false on failure.
 */
native bool BanIdentity(const char[] identity, 
						int time, 
						int flags, 
						const char[] reason,
						const char[] command="",
						any source=0);

/**
 * Removes a ban that was written to the server (either in memory or on disk).
 *
 * @param identity      String to unban (ip or authstring).
 * @param flags         Flags (only IP and AUTHID are valid flags here).
 * @param command       Command string to identify the source.  If this is left 
 *                      empty, then OnRemoveBan will not be called.
 * @param source        A source value that could be interpreted as a player 
 *                      index of any sort (not actually checked by Core).
 * @return              True on success, false on failure.
 */
native bool RemoveBan(const char[] identity, 
					  int flags, 
					  const char[] command="", 
					  any source=0);
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2011 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _sdktools_gamerules_included
 #endinput
#endif
#define _sdktools_gamerules_included

enum RoundState {
	// initialize the game, create teams
	RoundState_Init,

	//Before players have joined the game. Periodically checks to see if enough players are ready
	//to start a game. Also reverts to this when there are no active players
	RoundState_Pregame,

	//The game is about to start, wait a bit and spawn everyone
	RoundState_StartGame,

	//All players are respawned, frozen in place
	RoundState_Preround,

	//Round is on, playing normally
	RoundState_RoundRunning,

	//Someone has won the round
	RoundState_TeamWin,

	//Noone has won, manually restart the game, reset scores
	RoundState_Restart,

	//Noone has won, restart the game
	RoundState_Stalemate,

	//Game is over, showing the scoreboard etc
	RoundState_GameOver,

	//Game is over, doing bonus round stuff
	RoundState_Bonus,

	//Between rounds
	RoundState_BetweenRounds
};

/**
 * Retrieves an integer value from a property of the gamerules entity.
 *
 * @param prop          Property name.
 * @param size          Number of bytes to read (valid values are 1, 2, or 4).
 *                      This value is auto-detected, and the size parameter is
 *                      only used as a fallback in case detection fails.
 * @param element       Element # (starting from 0) if property is an array.
 * @return              Value at the given property offset.
 * @error               Not supported.
 */
native int GameRules_GetProp(const char[] prop, int size=4, int element=0);

/**
 * Sets an integer value for a property of the gamerules entity.
 *
 * @param prop          Property name.
 * @param value         Value to set.
 * @param size          Number of bytes to write (valid values are 1, 2, or 4).
 *                      This value is auto-detected, and the size parameter is
 *                      only used as a fallback in case detection fails.
 * @param element       Element # (starting from 0) if property is an array.
 * @param changeState   This parameter is ignored.
 * @error               Not supported.
 */
native void GameRules_SetProp(const char[] prop, any value, int size=4, int element=0, bool changeState=false);

/**
 * Retrieves a float value from a property of the gamerules entity.
 *
 * @param prop          Property name.
 * @param element       Element # (starting from 0) if property is an array.
 * @return              Value at the given property offset.
 * @error               Not supported.
 */
native float GameRules_GetPropFloat(const char[] prop, int element=0);

/**
 * Sets a float value for a property of the gamerules entity.
 *
 * @param prop          Property name.
 * @param value         Value to set.
 * @param element       Element # (starting from 0) if property is an array.
 * @param changeState   This parameter is ignored.
 * @error               Not supported.
 */
native void GameRules_SetPropFloat(const char[] prop, float value, int element=0, bool changeState=false);

/**
 * Retrieves a entity index from a property of the gamerules entity.
 *
 * @param prop          Property name.
 * @param element       Element # (starting from 0) if property is an array.
 * @return              Entity index at the given property.
 *                      If there is no entity, or the entity is not valid,
 *                      then -1 is returned.
 * @error               Not supported.
 */
native int GameRules_GetPropEnt(const char[] prop, int element=0);

/**
 * Sets an entity index for a property of the gamerules entity.
 *
 * @param prop          Property name.
 * @param other         Entity index to set, or -1 to unset.
 * @param element       Element # (starting from 0) if property is an array.
 * @param changeState   This parameter is ignored.
 * @error               Not supported.
 */
native void GameRules_SetPropEnt(const char[] prop, int other, int element=0, bool changeState=false);

/**
 * Retrieves a vector of floats from the gamerules entity, given a named network property.
 *
 * @param prop          Property name.
 * @param vec           Vector buffer to store data in.
 * @param element       Element # (starting from 0) if property is an array.
 * @error               Not supported.
 */
native void GameRules_GetPropVector(const char[] prop, float vec[3], int element=0);

/**
 * Sets a vector of floats in the gamerules entity, given a named network property.
 *
 * @param prop          Property name.
 * @param vec           Vector to set.
 * @param element       Element # (starting from 0) if property is an array.
 * @param changeState   This parameter is ignored.
 * @error               Not supported.
 */
native void GameRules_SetPropVector(const char[] prop, const float vec[3], int element=0, bool changeState=false);

/**
 * Gets a gamerules property as a string.
 *
 * @param prop          Property to use.
 * @param buffer        Destination string buffer.
 * @param maxlen        Maximum length of output string buffer.
 * @return              Number of non-null bytes written.
 * @error               Not supported.
 */
native int GameRules_GetPropString(const char[] prop, char[] buffer, int maxlen);

/**
 * Sets a gamerules property as a string.
 *
 * @param prop          Property to use.
 * @param buffer        String to set.
 * @param changeState   This parameter is ignored.
 * @return              Number of non-null bytes written.
 * @error               Not supported.
 */
native int GameRules_SetPropString(const char[] prop, const char[] buffer, bool changeState=false);

/**
 * Gets the current round state.
 *
 * @return              Round state.
 * @error               Game doesn't support round state.
 */
stock RoundState GameRules_GetRoundState()
{
	return view_as<RoundState>(GameRules_GetProp("m_iRoundState"));
}
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2017 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _sdktools_entinput_included
 #endinput
#endif
#define _sdktools_entinput_included

/**
 * Invokes a named input method on an entity.
 *
 * After completion (successful or not), the current global variant is re-initialized.
 *
 * @param dest          Destination entity index.
 * @param input         Input action.
 * @param activator     Entity index which initiated the sequence of actions (-1 for a NULL entity).
 * @param caller        Entity index from which this event is sent (-1 for a NULL entity).
 * @param outputid      Unknown.
 * @return              True if successful otherwise false.
 * @error               Invalid entity index or no mod support.
 */
native bool AcceptEntityInput(int dest, const char[] input, int activator=-1, int caller=-1, int outputid=0);
/**
 * vim: set ts=4 sw=4 tw=99 noet :
 * =============================================================================
 * SourceMod (C)2004-2014 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

static int TestNumber = 0;
static char TestContext[255];

stock void SetTestContext(const char[] context)
{
	strcopy(TestContext, sizeof(TestContext), context);
}

stock void AssertEq(const char[] text, int cell1, int cell2)
{
	TestNumber++;
	if (cell1 == cell2)
	{
		PrintToServer("[%d] %s: %s == %d OK", TestNumber, TestContext, text, cell2);
	}
	else
	{
		PrintToServer("[%d] %s FAIL: %s should be %d, got %d", TestNumber, TestContext, text, cell2, cell1);
		ThrowError("test %d (%s in %s) failed", TestNumber, text, TestContext);
	}
}

stock void AssertFalse(const char[] text, bool value)
{
	TestNumber++;
	if (!value)
	{
		PrintToServer("[%d] %s: %s == false OK", TestNumber, TestContext, text, value);
	}
	else
	{
		PrintToServer("[%d] %s FAIL: %s should be false, got true", TestNumber, TestContext, text);
		ThrowError("test %d (%s in %s) failed", TestNumber, text, TestContext);
	}
}

stock void AssertTrue(const char[] text, bool value)
{
	TestNumber++;
	if (value)
	{
		PrintToServer("[%d] %s: %s == true OK", TestNumber, TestContext, text, value);
	}
	else
	{
		PrintToServer("[%d] %s FAIL: %s should be true, got false", TestNumber, TestContext, text);
		ThrowError("test %d (%s in %s) failed", TestNumber, text, TestContext);
	}
}
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _float_included
 #endinput
#endif
#define _float_included

#if !defined __sourcepawn2__
/**
 * Converts an integer into a floating point value.
 *
 * @param value         Integer to convert.
 * @return              Floating point value.
 */
native float float(int value);
#endif

/**
 * Multiplies two floats together.
 *
 * Note: This native is internal implementation. For multiplication use the '*' operator.
 *
 * @param oper1         First value.
 * @param oper2         Second value.
 * @return              oper1*oper2.
 * @deprecated          This native is internal implementation. For multiplication use the '*' operator.
 */
#pragma deprecated This native is internal implementation. For multiplication use the '*' operator.
native float FloatMul(float oper1, float oper2);

/**
 * Divides the dividend by the divisor.
 *
 * Note: This native is internal implementation. For division use the '/' operator.
 *
 * @param dividend      First value.
 * @param divisor       Second value.
 * @return              dividend/divisor.
 * @deprecated          This native is internal implementation. For division use the '/' operator.
 */
#pragma deprecated This native is internal implementation. For division use the '/' operator.
native float FloatDiv(float dividend, float divisor);

/**
 * Adds two floats together.
 *
 * Note: This native is internal implementation. For addition use the '+' operator.
 *
 * @param oper1         First value.
 * @param oper2         Second value.
 * @return              oper1+oper2.
 * @deprecated          This native is internal implementation. For addition use the '+' operator.
 */
#pragma deprecated This native is internal implementation. For addition use the '+' operator.
native float FloatAdd(float oper1, float oper2);

/**
 * Subtracts oper2 from oper1.
 *
 * Note: This native is internal implementation. For subtraction use the '-' operator.
 *
 * @param oper1         First value.
 * @param oper2         Second value.
 * @return              oper1-oper2.
 * @deprecated          This native is internal implementation. For subtraction use the '-' operator.
 */
#pragma deprecated This native is internal implementation. For subtraction use the '-' operator.
native float FloatSub(float oper1, float oper2);

/**
 * Returns the decimal part of a float.
 *
 * @param value         Input value.
 * @return              Decimal part.
 */
native float FloatFraction(float value);

/**
 * Rounds a float to the closest integer to zero.
 *
 * @param value         Input value to be rounded.
 * @return              Rounded value.
 */
native int RoundToZero(float value);

/**
 * Rounds a float to the next highest integer value.
 *
 * @param value         Input value to be rounded.
 * @return              Rounded value.
 */
native int RoundToCeil(float value);

/**
 * Rounds a float to the next lowest integer value.
 *
 * @param value         Input value to be rounded.
 * @return              Rounded value.
 */
native int RoundToFloor(float value);

/**
 * Standard IEEE rounding.
 *
 * @param value         Input value to be rounded.
 * @return              Rounded value.
 */
native int RoundToNearest(float value);

/**
 * Compares two floats.
 *
 * @param fOne          First value.
 * @param fTwo          Second value.
 * @return              Returns 1 if the first argument is greater than the second argument.
 *                      Returns -1 if the first argument is smaller than the second argument.
 *                      Returns 0 if both arguments are equal.
 */
native int FloatCompare(float fOne, float fTwo);

/**
 * Returns the square root of the input value, equivalent to floatpower(value, 0.5).
 *
 * @param value         Input value.
 * @return              Square root of the value.
 */
native float SquareRoot(float value);

/**
 * Returns the value raised to the power of the exponent.
 *
 * @param value         Value to be raised.
 * @param exponent      Value to raise the base.
 * @return              value^exponent.
 */
native float Pow(float value, float exponent);

/**
 * Returns the value of raising the input by e.
 *
 * @param value         Input value.
 * @return              exp(value).
 */
native float Exponential(float value);

/**
 * Returns the logarithm of any base specified.
 *
 * @param value         Input value.
 * @param base          Logarithm base to use, default is 10.
 * @return              log(value)/log(base).
 */
native float Logarithm(float value, float base=10.0);

/**
 * Returns the sine of the argument.
 *
 * @param value         Input value in radians.
 * @return              sin(value).
 */
native float Sine(float value);

/**
 * Returns the cosine of the argument.
 *
 * @param value         Input value in radians.
 * @return              cos(value).
 */
native float Cosine(float value);

/**
 * Returns the tangent of the argument.
 *
 * @param value         Input value in radians.
 * @return              tan(value).
 */
native float Tangent(float value);

/**
 * Returns an absolute value.
 *
 * @param value         Input value.
 * @return              Absolute value of the input.
 */
native float FloatAbs(float value);

/**
 * Returns the arctangent of the input value.
 *
 * @param angle         Input value.
 * @return              atan(value) in radians.
 */
native float ArcTangent(float angle);

/**
 * Returns the arccosine of the input value.
 *
 * @param angle         Input value.
 * @return              acos(value) in radians.
 */
native float ArcCosine(float angle);

/**
 * Returns the arcsine of the input value.
 *
 * @param angle         Input value.
 * @return              asin(value) in radians.
 */
native float ArcSine(float angle);

/**
 * Returns the arctangent2 of the input values.
 *
 * @param x             Horizontal value.
 * @param y             Vertical value.
 * @return              atan2(value) in radians.
 */
native float ArcTangent2(float x, float y);

/**
 * Rounds a floating point number using the "round to nearest" algorithm.
 *
 * @param value         Floating point value to round.
 * @return              The value rounded to the nearest integer.
 */
stock int RoundFloat(float value)
{
	return RoundToNearest(value);
}

/**
 * User defined operators.
 */
#if !defined __sourcepawn2__
#pragma rational Float

// Internal aliases for backwards compatability.
native float __FLOAT_MUL__(float a, float b) = FloatMul;
native float __FLOAT_DIV__(float a, float b) = FloatDiv;
native float __FLOAT_ADD__(float a, float b) = FloatAdd;
native float __FLOAT_SUB__(float a, float b) = FloatSub;

native bool __FLOAT_GT__(float a, float b);
native bool __FLOAT_GE__(float a, float b);
native bool __FLOAT_LT__(float a, float b);
native bool __FLOAT_LE__(float a, float b);
native bool __FLOAT_EQ__(float a, float b);
native bool __FLOAT_NE__(float a, float b);
native bool __FLOAT_NOT__(float a);

native float operator*(float oper1, float oper2) = FloatMul;
native float operator/(float oper1, float oper2) = FloatDiv;
native float operator+(float oper1, float oper2) = FloatAdd;
native float operator-(float oper1, float oper2) = FloatSub;
native bool operator!(float oper1) = __FLOAT_NOT__;
native bool operator>(float oper1, float oper2) = __FLOAT_GT__;
native bool operator>=(float oper1, float oper2) = __FLOAT_GE__;
native bool operator<(float oper1, float oper2) = __FLOAT_LT__;
native bool operator<=(float oper1, float oper2) = __FLOAT_LE__;
native bool operator!=(float oper1, float oper2) = __FLOAT_NE__;
native bool operator==(float oper1, float oper2) = __FLOAT_EQ__;

stock float operator++(float oper)
{
	return oper+1.0;
}

stock float operator--(float oper)
{
	return oper-1.0;
}

stock float operator-(float oper)
{
	return oper^view_as<float>(cellmin);                /* IEEE values are sign/magnitude */
}

// The stocks below are int->float converting versions of the above natives.

stock float operator*(float oper1, int oper2)
{
	return __FLOAT_MUL__(oper1, float(oper2));          /* "*" is commutative */
}

stock float operator/(float oper1, int oper2)
{
	return __FLOAT_DIV__(oper1, float(oper2));
}

stock float operator/(int oper1, float oper2)
{
	return __FLOAT_DIV__(float(oper1), oper2);
}

stock float operator+(float oper1, int oper2)
{
	return __FLOAT_ADD__(oper1, float(oper2));          /* "+" is commutative */
}

stock float operator-(float oper1, int oper2)
{
	return __FLOAT_SUB__(oper1, float(oper2));
}

stock float operator-(int oper1, float oper2)
{
	return __FLOAT_SUB__(float(oper1), oper2);
}

stock bool operator==(float oper1, int oper2)
{
	return __FLOAT_EQ__(oper1, float(oper2));
}

stock bool operator!=(float oper1, int oper2)
{
	return __FLOAT_NE__(oper1, float(oper2));
}

stock bool operator>(float oper1, int oper2)
{
	return __FLOAT_GT__(oper1, float(oper2));
}

stock bool operator>(int oper1, float oper2)
{
	return __FLOAT_GT__(float(oper1), oper2);
}

stock bool operator>=(float oper1, int oper2)
{
	return __FLOAT_GE__(oper1, float(oper2));
}

stock bool operator>=(int oper1, float oper2)
{
	return __FLOAT_GE__(float(oper1), oper2);
}

stock bool operator<(float oper1, int oper2)
{
	return __FLOAT_LT__(oper1, float(oper2));
}

stock bool operator<(int oper1, float oper2)
{
	return __FLOAT_LT__(float(oper1), oper2);
}

stock bool operator<=(float oper1, int oper2)
{
	return __FLOAT_LE__(oper1, float(oper2));
}

stock bool operator<=(int oper1, float oper2)
{
	return __FLOAT_LE__(float(oper1), oper2);
}

/**
 * Forbidden operators.
 */
forward operator%(float oper1, float oper2);
forward operator%(float oper1, int oper2);
forward operator%(int oper1, float oper2);
#endif // __sourcepawn2__

#define FLOAT_PI 3.1415926535897932384626433832795

/**
 * Converts degrees to radians.
 *
 * @param angle         Degrees.
 * @return              Radians.
 */
stock float DegToRad(float angle)
{
	return (angle*FLOAT_PI)/180;
}

/**
 * Converts radians to degrees.
 *
 * @param angle         Radians.
 * @return              Degrees.
 */
stock float RadToDeg(float angle)
{
	return (angle*180)/FLOAT_PI;
}

/**
 * Returns a random integer in the range [0, 2^31-1].
 *
 * Note: Uniform random number streams are seeded automatically per-plugin.
 *
 * @return              Random integer.
 */
native int GetURandomInt();

/**
 * Returns a uniform random float in the range [0, 1).
 *
 * Note: Uniform random number streams are seeded automatically per-plugin.
 *
 * @return              Uniform random floating-point number.
 */
native float GetURandomFloat();

/**
 * Seeds a plugin's uniform random number stream. This is done automatically,
 * so normally it is totally unnecessary to call this.
 *
 * @param seeds         Array of numbers to use as seeding data.
 * @param numSeeds      Number of seeds in the seeds array.
 */
native void SetURandomSeed(const int[] seeds, int numSeeds);

/**
 * Seeds a plugin's uniform random number stream. This is done automatically,
 * so normally it is totally unnecessary to call this.
 *
 * @param seed      Single seed value.
 */
stock void SetURandomSeedSimple(int seed)
{
	int seeds[1];
	seeds[0] = seed;
	SetURandomSeed(seeds, 1);
}
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _sdktools_trace_included
 #endinput
#endif
#define _sdktools_trace_included

#define CONTENTS_EMPTY                   0           /**< No contents. */
#define CONTENTS_SOLID                   0x1         /**< an eye is never valid in a solid . */
#define CONTENTS_WINDOW                  0x2         /**< translucent, but not watery (glass). */
#define CONTENTS_AUX                     0x4
#define CONTENTS_GRATE                   0x8         /**< alpha-tested "grate" textures.  Bullets/sight pass through, but solids don't. */
#define CONTENTS_SLIME                   0x10
#define CONTENTS_WATER                   0x20
#define CONTENTS_MIST                    0x40
#define CONTENTS_OPAQUE                  0x80        /**< things that cannot be seen through (may be non-solid though). */
#define LAST_VISIBLE_CONTENTS            0x80
#define ALL_VISIBLE_CONTENTS             (LAST_VISIBLE_CONTENTS | (LAST_VISIBLE_CONTENTS-1))
#define CONTENTS_TESTFOGVOLUME           0x100
#define CONTENTS_UNUSED5                 0x200
#define CONTENTS_UNUSED6                 0x4000
#define CONTENTS_TEAM1                   0x800       /**< per team contents used to differentiate collisions. */
#define CONTENTS_TEAM2                   0x1000      /**< between players and objects on different teams. */
#define CONTENTS_IGNORE_NODRAW_OPAQUE    0x2000      /**< ignore CONTENTS_OPAQUE on surfaces that have SURF_NODRAW. */
#define CONTENTS_MOVEABLE                0x4000      /**< hits entities which are MOVETYPE_PUSH (doors, plats, etc) */
#define CONTENTS_AREAPORTAL              0x8000      /**< remaining contents are non-visible, and don't eat brushes. */
#define CONTENTS_PLAYERCLIP              0x10000
#define CONTENTS_MONSTERCLIP             0x20000

/**
 * @section currents can be added to any other contents, and may be mixed
 */
#define CONTENTS_CURRENT_0      0x40000
#define CONTENTS_CURRENT_90     0x80000
#define CONTENTS_CURRENT_180    0x100000
#define CONTENTS_CURRENT_270    0x200000
#define CONTENTS_CURRENT_UP     0x400000
#define CONTENTS_CURRENT_DOWN   0x800000

/**
 * @endsection
 */

#define CONTENTS_ORIGIN         0x1000000   /**< removed before bsp-ing an entity. */
#define CONTENTS_MONSTER        0x2000000   /**< should never be on a brush, only in game. */
#define CONTENTS_DEBRIS         0x4000000
#define CONTENTS_DETAIL         0x8000000   /**< brushes to be added after vis leafs. */
#define CONTENTS_TRANSLUCENT    0x10000000  /**< auto set if any surface has trans. */
#define CONTENTS_LADDER         0x20000000
#define CONTENTS_HITBOX         0x40000000  /**< use accurate hitboxes on trace. */

/**
 * @section Trace masks.
 */
#define MASK_ALL                    (0xFFFFFFFF)
#define MASK_SOLID                  (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)                      /**< everything that is normally solid */
#define MASK_PLAYERSOLID            (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)  /**< everything that blocks player movement */
#define MASK_NPCSOLID               (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE) /**< blocks npc movement */
#define MASK_WATER                  (CONTENTS_WATER|CONTENTS_MOVEABLE|CONTENTS_SLIME)                                                       /**< water physics in these contents */
#define MASK_OPAQUE                 (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_OPAQUE)                                                      /**< everything that blocks line of sight for AI, lighting, etc */
#define MASK_OPAQUE_AND_NPCS        (MASK_OPAQUE|CONTENTS_MONSTER)                                                                          /**< everything that blocks line of sight for AI, lighting, etc, but with monsters added. */
#define MASK_VISIBLE                (MASK_OPAQUE|CONTENTS_IGNORE_NODRAW_OPAQUE)                                                             /**< everything that blocks line of sight for players */
#define MASK_VISIBLE_AND_NPCS       (MASK_OPAQUE_AND_NPCS|CONTENTS_IGNORE_NODRAW_OPAQUE)                                                    /**< everything that blocks line of sight for players, but with monsters added. */
#define MASK_SHOT                   (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_HITBOX)     /**< bullets see these as solid */
#define MASK_SHOT_HULL              (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_GRATE)      /**< non-raycasted weapons see this as solid (includes grates) */
#define MASK_SHOT_PORTAL            (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW)                                                      /**< hits solids (not grates) and passes through everything else */
#define MASK_SOLID_BRUSHONLY        (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_GRATE)                                       /**< everything normally solid, except monsters (world+brush only) */
#define MASK_PLAYERSOLID_BRUSHONLY  (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_PLAYERCLIP|CONTENTS_GRATE)                   /**< everything normally solid for player movement, except monsters (world+brush only) */
#define MASK_NPCSOLID_BRUSHONLY     (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE)                  /**< everything normally solid for npc movement, except monsters (world+brush only) */
#define MASK_NPCWORLDSTATIC         (CONTENTS_SOLID|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE)                                    /**< just the world, used for route rebuilding */
#define MASK_SPLITAREAPORTAL        (CONTENTS_WATER|CONTENTS_SLIME)                                                                         /**< These are things that can split areaportals */

/**
 * @endsection
 */

/**
 * @section Surface flags.
 */

#define SURF_LIGHT       0x0001      /**< value will hold the light strength */
#define SURF_SKY2D       0x0002      /**< don't draw, indicates we should skylight + draw 2d sky but not draw the 3D skybox */
#define SURF_SKY         0x0004      /**< don't draw, but add to skybox */
#define SURF_WARP        0x0008      /**< turbulent water warp */
#define SURF_TRANS       0x0010
#define SURF_NOPORTAL    0x0020      /**< the surface can not have a portal placed on it */
#define SURF_TRIGGER     0x0040      /**< This is an xbox hack to work around elimination of trigger surfaces, which breaks occluders */
#define SURF_NODRAW      0x0080      /**< don't bother referencing the texture */

#define SURF_HINT        0x0100      /**< make a primary bsp splitter */

#define SURF_SKIP        0x0200      /**< completely ignore, allowing non-closed brushes */
#define SURF_NOLIGHT     0x0400      /**< Don't calculate light */
#define SURF_BUMPLIGHT   0x0800      /**< calculate three lightmaps for the surface for bumpmapping */
#define SURF_NOSHADOWS   0x1000      /**< Don't receive shadows */
#define SURF_NODECALS    0x2000      /**< Don't receive decals */
#define SURF_NOCHOP      0x4000      /**< Don't subdivide patches on this surface */
#define SURF_HITBOX      0x8000      /**< surface is part of a hitbox */

/**
 * @endsection
 */

/**
 * @section Partition masks.
 */

#define PARTITION_SOLID_EDICTS        (1 << 1) /**< every edict_t that isn't SOLID_TRIGGER or SOLID_NOT (and static props) */
#define PARTITION_TRIGGER_EDICTS      (1 << 2) /**< every edict_t that IS SOLID_TRIGGER */
#define PARTITION_NON_STATIC_EDICTS   (1 << 5) /**< everything in solid & trigger except the static props, includes SOLID_NOTs */
#define PARTITION_STATIC_PROPS        (1 << 7)

/**
 * @endsection
 */

/**
 * @section Displacement flags.
 */

#define DISPSURF_FLAG_SURFACE         (1<<0)
#define DISPSURF_FLAG_WALKABLE        (1<<1)
#define DISPSURF_FLAG_BUILDABLE       (1<<2)
#define DISPSURF_FLAG_SURFPROP1       (1<<3)
#define DISPSURF_FLAG_SURFPROP2       (1<<4)

/**
 * @endsection
 */

enum RayType
{
	RayType_EndPoint,   /**< The trace ray will go from the start position to the end position. */
	RayType_Infinite    /**< The trace ray will go from the start position to infinity using a direction vector. */
};

typeset TraceEntityFilter
{
	/**
	 * Called on entity filtering.
	 *
	 * @param entity        Entity index.
	 * @param contentsMask  Contents Mask.
	 * @return              True to allow the current entity to be hit, otherwise false.
	 */
	function bool (int entity, int contentsMask);

	/**
	 * Called on entity filtering.
	 *
	 * @param entity        Entity index.
	 * @param contentsMask  Contents Mask.
	 * @param data          Data value, if used.
	 * @return              True to allow the current entity to be hit, otherwise false.
	 */
	function bool (int entity, int contentsMask, any data);
};

typeset TraceEntityEnumerator
{
	/**
	 * Called for each entity enumerated with EnumerateEntities*.
	 *
	 * @param entity        Entity index.
	 * @return              True to continue enumerating, otherwise false.
	 */
	function bool (int entity);

	/**
	 * Called for each entity enumerated with EnumerateEntities*.
	 *
	 * @param entity        Entity index.
	 * @param data          Data value, if used.
	 * @return              True to continue enumerating, otherwise false. */
	function bool (int entity, any data);
}

/**
 * Get the contents mask and the entity index at the given position.
 *
 * @param pos           World position to test.
 * @param entindex      Entity index found at the given position (by reference).
 * @return              Contents mask.
 */
native int TR_GetPointContents(const float pos[3], int &entindex=-1);

/**
 * Get the point contents testing only the given entity index.
 *
 * @param entindex      Entity index to test.
 * @param pos           World position.
 * @return              Contents mask.
 */
native int TR_GetPointContentsEnt(int entindex, const float pos[3]);

/**
 * Starts up a new trace ray using a global trace result.
 *
 * @param pos           Starting position of the ray.
 * @param vec           Depending on RayType, it will be used as the
 *                      ending point, or the direction angle.
 * @param flags         Trace flags.
 * @param rtype         Method to calculate the ray direction.
 */
native void TR_TraceRay(const float pos[3],
                        const float vec[3],
                        int flags,
                        RayType rtype);

/**
 * Starts up a new trace hull using a global trace result.
 *
 * @param pos           Starting position of the ray.
 * @param vec           Ending position of the ray.
 * @param mins          Hull minimum size.
 * @param maxs          Hull maximum size.
 * @param flags         Trace flags.
 */
native void TR_TraceHull(const float pos[3],
                         const float vec[3],
                         const float mins[3],
                         const float maxs[3],
                         int flags);

/**
 * Enumerates over entities along a ray. This may find entities that are
 * close to the ray but do not actually intersect it. Use TR_Clip*RayToEntity
 * with TR_DidHit to check if the ray actually intersects the entity.
 *
 * @param pos           Starting position of the ray.
 * @param vec           Depending on RayType, it will be used as the ending
 *                      point, or the direction angle.
 * @param mask          Mask to use for the trace. See PARTITION_* flags.
 * @param rtype         Method to calculate the ray direction.
 * @param enumerator    Function to use as enumerator. For each entity found
 *                      along the ray, this function is called.
 * @param data          Arbitrary data value to pass through to the enumerator.
 */
native void TR_EnumerateEntities(const float pos[3],
                                 const float vec[3],
                                 int mask,
                                 RayType rtype,
                                 TraceEntityEnumerator enumerator,
                                 any data=0);

/**
 * Enumerates over entities along a ray hull. This may find entities that are
 * close to the ray but do not actually intersect it. Use TR_Clip*RayToEntity
 * with TR_DidHit to check if the ray actually intersects the entity.
 *
 * @param pos           Starting position of the ray.
 * @param vec           Ending position of the ray.
 * @param mins          Hull minimum size.
 * @param maxs          Hull maximum size.
 * @param mask          Mask to use for the trace. See PARTITION_* flags.
 * @param enumerator    Function to use as enumerator. For each entity found
 *                      along the ray, this function is called.
 * @param data          Arbitrary data value to pass through to the enumerator.
 */
native void TR_EnumerateEntitiesHull(const float pos[3],
                                    const float vec[3],
                                    const float mins[3],
                                    const float maxs[3],
                                    int mask,
                                    TraceEntityEnumerator enumerator,
                                    any data=0);

/**
 * Starts up a new trace ray using a global trace result and a customized
 * trace ray filter.
 *
 * Calling TR_Trace*Filter or TR_Trace*FilterEx from inside a filter
 * function is currently not allowed and may not work.
 *
 * @param pos           Starting position of the ray.
 * @param vec           Depending on RayType, it will be used as the ending
 *                      point, or the direction angle.
 * @param flags         Trace flags.
 * @param rtype         Method to calculate the ray direction.
 * @param filter        Function to use as a filter.
 * @param data          Arbitrary data value to pass through to the filter
 *                      function.
 */
native void TR_TraceRayFilter(const float pos[3],
                              const float vec[3],
                              int flags,
                              RayType rtype,
                              TraceEntityFilter filter,
                              any data=0);

/**
 * Starts up a new trace hull using a global trace result and a customized
 * trace ray filter.
 *
 * Calling TR_Trace*Filter or TR_Trace*FilterEx from inside a filter
 * function is currently not allowed and may not work.
 *
 * @param pos           Starting position of the ray.
 * @param vec           Ending position of the ray.
 * @param mins          Hull minimum size.
 * @param maxs          Hull maximum size.
 * @param flags         Trace flags.
 * @param filter        Function to use as a filter.
 * @param data          Arbitrary data value to pass through to the filter
 *                      function.
 */
native void TR_TraceHullFilter(const float pos[3],
                               const float vec[3],
                               const float mins[3],
                               const float maxs[3],
                               int flags,
                               TraceEntityFilter filter,
                               any data=0);

/**
 * Clips a ray to a particular entity.
 *
 * @param pos           Starting position of the ray.
 * @param vec           Depending on RayType, it will be used as the ending
 *                      point, or the direction angle.
 * @param flags         Trace flags.
 * @param rtype         Method to calculate the ray direction.
 * @param entity        Entity to clip to.
 */
native void TR_ClipRayToEntity(const float pos[3],
                               const float vec[3],
                               int flags,
                               RayType rtype,
                               int entity);

/**
 * Clips a ray hull to a particular entity.
 *
 * @param pos           Starting position of the ray.
 * @param vec           Ending position of the ray.
 * @param mins          Hull minimum size.
 * @param maxs          Hull maximum size.
 * @param flags         Trace flags.
 * @param entity        Entity to clip to.
 */
native void TR_ClipRayHullToEntity(const float pos[3],
                                   const float vec[3],
                                   const float mins[3],
                                   const float maxs[3],
                                   int flags,
                                   int entity);

/**
 * Clips the current global ray (or hull) to a particular entity.
 *
 * @param flags         Trace flags.
 * @param entity        Entity to clip to.
 */
native void TR_ClipCurrentRayToEntity(int flags, int entity);

/**
 * Starts up a new trace ray using a new trace result.
 *
 * @param pos           Starting position of the ray.
 * @param vec           Depending on RayType, it will be used as the ending
 *                      point, or the direction angle.
 * @param flags         Trace flags.
 * @param rtype         Method to calculate the ray direction.
 * @return              Ray trace handle, which must be closed via CloseHandle().
 */
native Handle TR_TraceRayEx(const float pos[3],
                            const float vec[3],
                            int flags,
                            RayType rtype);

/**
 * Starts up a new trace hull using a new trace result.
 *
 * @param pos           Starting position of the ray.
 * @param vec           Ending position of the ray.
 * @param mins          Hull minimum size.
 * @param maxs          Hull maximum size.
 * @param flags         Trace flags.
 * @return              Ray trace handle, which must be closed via CloseHandle().
 */
native Handle TR_TraceHullEx(const float pos[3],
                             const float vec[3],
                             const float mins[3],
                             const float maxs[3],
                             int flags);

/**
 * Starts up a new trace ray using a new trace result and a customized
 * trace ray filter.
 *
 * Calling TR_Trace*Filter or TR_TraceRay*Ex from inside a filter
 * function is currently not allowed and may not work.
 *
 * @param pos           Starting position of the ray.
 * @param vec           Depending on RayType, it will be used as the ending
 *                      point, or the direction angle.
 * @param flags         Trace flags.
 * @param rtype         Method to calculate the ray direction.
 * @param filter        Function to use as a filter.
 * @param data          Arbitrary data value to pass through to the filter function.
 * @return              Ray trace handle, which must be closed via CloseHandle().
 */
native Handle TR_TraceRayFilterEx(const float pos[3],
                                  const float vec[3],
                                  int flags,
                                  RayType rtype,
                                  TraceEntityFilter filter,
                                  any data=0);

/**
 * Starts up a new trace hull using a new trace result and a customized
 * trace ray filter.
 *
 * Calling TR_Trace*Filter or TR_Trace*FilterEx from inside a filter
 * function is currently not allowed and may not work.
 *
 * @param pos           Starting position of the ray.
 * @param vec           Ending position of the ray.
 * @param mins          Hull minimum size.
 * @param maxs          Hull maximum size.
 * @param flags         Trace flags.
 * @param filter        Function to use as a filter.
 * @param data          Arbitrary data value to pass through to the filter function.
 * @return              Ray trace handle, which must be closed via CloseHandle().
 */
native Handle TR_TraceHullFilterEx(const float pos[3],
                                   const float vec[3],
                                   const float mins[3],
                                   const float maxs[3],
                                   int flags,
                                   TraceEntityFilter filter,
                                   any data=0);

/**
 * Clips a ray to a particular entity.
 *
 * @param pos           Starting position of the ray.
 * @param vec           Depending on RayType, it will be used as the ending
 *                      point, or the direction angle.
 * @param flags         Trace flags.
 * @param rtype         Method to calculate the ray direction.
 * @param entity        Entity to clip to.
 * @return              Ray trace handle, which must be closed via CloseHandle().
 */
native Handle TR_ClipRayToEntityEx(const float pos[3],
                                   const float vec[3],
                                   int flags,
                                   RayType rtype,
                                   int entity);

/**
 * Clips a ray hull to a particular entity.
 *
 * @param pos           Starting position of the ray.
 * @param vec           Ending position of the ray.
 * @param mins          Hull minimum size.
 * @param maxs          Hull maximum size.
 * @param flags         Trace flags.
 * @param entity        Entity to clip to.
 * @return              Ray trace handle, which must be closed via CloseHandle().
 */
native Handle TR_ClipRayHullToEntityEx(const float pos[3],
                                       const float vec[3],
                                       const float mins[3],
                                       const float maxs[3],
                                       int flags,
                                       int entity);

/**
 * Clips the current global ray (or hull) to a particular entity.
 *
 * @param flags         Trace flags.
 * @param entity        Entity to clip to.
 * @return              Ray trace handle, which must be closed via CloseHandle().
 */
native Handle TR_ClipCurrentRayToEntityEx(int flags, int entity);

/**
 * Returns the time fraction from a trace result (1.0 means no collision).
 *
 * @param hndl          A trace Handle, or INVALID_HANDLE to use a global trace result.
 * @return              Time fraction value of the trace.
 * @error               Invalid Handle.
 */
native float TR_GetFraction(Handle hndl=INVALID_HANDLE);

/**
 * Returns the time fraction from a trace result when it left a solid.
 * Only valid if trace started in solid
 *
 * @param hndl          A trace Handle, or INVALID_HANDLE to use a global trace result.
 * @return              Time fraction left solid value of the trace.
 * @error               Invalid Handle.
 */
native float TR_GetFractionLeftSolid(Handle hndl=INVALID_HANDLE);

/**
 * Returns the starting position of a trace.
 *
 * @param hndl          A trace Handle, or INVALID_HANDLE to use a global trace result.
 * @param pos           Vector buffer to store data in.
 * @error               Invalid Handle.
 */
native void TR_GetStartPosition(Handle hndl, float pos[3]);

/**
 * Returns the collision position of a trace result.
 *
 * @param pos           Vector buffer to store data in.
 * @param hndl          A trace Handle, or INVALID_HANDLE to use a global trace result.
 * @error               Invalid Handle.
 */
native void TR_GetEndPosition(float pos[3], Handle hndl=INVALID_HANDLE);

/**
 * Returns the entity index that collided with the trace.
 *
 * @param hndl          A trace Handle, or INVALID_HANDLE to use a global trace result.
 * @return              Entity index or -1 for no collision.
 * @error               Invalid Handle.
 */
native int TR_GetEntityIndex(Handle hndl=INVALID_HANDLE);

/**
 * Returns the displacement flags for the surface that was hit. See DISPSURF_FLAG_*.
 *
 * @param hndl          A trace Handle, or INVALID_HANDLE to use a global trace result.
 * @return              Displacement flags.
 * @error               Invalid Handle.
 */
native int TR_GetDisplacementFlags(Handle hndl=INVALID_HANDLE);

/**
 * Returns the name of the surface that was hit.
 *
 * @param hndl          A trace Handle, or INVALID_HANDLE to use a global trace result.
 * @param buffer        Buffer to store surface name in
 * @param maxlen        Maximum length of output buffer
 * @error               Invalid Handle.
 */
native void TR_GetSurfaceName(Handle hndl, char[] buffer, int maxlen);

/**
 * Returns the surface properties index of the surface that was hit.
 *
 * @param hndl          A trace Handle, or INVALID_HANDLE to use a global trace result.
 * @return              Surface props.
 * @error               Invalid Handle.
 */
native int TR_GetSurfaceProps(Handle hndl=INVALID_HANDLE);

/**
 * Returns the surface flags. See SURF_*.
 *
 * @param hndl          A trace Handle, or INVALID_HANDLE to use a global trace result.
 * @return              Surface flags.
 * @error               Invalid Handle.
 */
native int TR_GetSurfaceFlags(Handle hndl=INVALID_HANDLE);

/**
 * Returns the index of the physics bone that was hit.
 *
 * @param hndl          A trace Handle, or INVALID_HANDLE to use a global trace result.
 * @return              Physics bone index.
 * @error               Invalid Handle.
 */
native int TR_GetPhysicsBone(Handle hndl=INVALID_HANDLE);

/**
 * Returns whether the entire trace was in a solid area.
 *
 * @param hndl          A trace Handle, or INVALID_HANDLE to use a global trace result.
 * @return              True if entire trace was in a solid area, otherwise false.
 * @error               Invalid Handle.
 */
native bool TR_AllSolid(Handle hndl=INVALID_HANDLE);

/**
 * Returns whether the initial point was in a solid area.
 *
 * @param hndl          A trace Handle, or INVALID_HANDLE to use a global trace result.
 * @return              True if initial point was in a solid area, otherwise false.
 * @error               Invalid Handle.
 */
native bool TR_StartSolid(Handle hndl=INVALID_HANDLE);

/**
 * Returns if there was any kind of collision along the trace ray.
 *
 * @param hndl          A trace Handle, or INVALID_HANDLE to use a global trace result.
 * @return              True if any collision found, otherwise false.
 * @error               Invalid Handle.
 */
native bool TR_DidHit(Handle hndl=INVALID_HANDLE);

/**
 * Returns in which body hit group the trace collided if any.
 *
 * @param hndl          A trace Handle, or INVALID_HANDLE to use a global trace result.
 * @return              Body hit group.
 * @error               Invalid Handle.
 */
native int TR_GetHitGroup(Handle hndl=INVALID_HANDLE);

/**
 * Returns in which hitbox the trace collided if any. 
 *
 * Note: if the entity that collided with the trace is the world entity, 
 * then this function doesn't return an hitbox index but a static prop index.
 *
 * @param hndl          A trace Handle, or INVALID_HANDLE to use a global trace result.
 * @return              Hitbox index (Or static prop index).
 * @error               Invalid Handle.
 */
native int TR_GetHitBoxIndex(Handle hndl=INVALID_HANDLE);

/**
 * Find the normal vector to the collision plane of a trace.
 *
 * @param hndl          A trace Handle, or INVALID_HANDLE to use a global trace result.
 * @param normal        Vector buffer to store the vector normal to the collision plane
 * @error               Invalid Handle
 */
native void TR_GetPlaneNormal(Handle hndl, float normal[3]);

/**
 * Tests a point to see if it's outside any playable area
 *
 * @param pos           Vector buffer to store data in.
 * @return              True if outside world, otherwise false.
 */
native bool TR_PointOutsideWorld(float pos[3]);
/**
 * vim: set ts=4 sw=4 tw=99 noet :
 * =============================================================================
 * SourceMod (C)2004-2014 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _adt_array_included
 #endinput
#endif
#define _adt_array_included

/**
 * Given a maximum string size (including the null terminator),
 * returns the number of cells required to fit that string.
 *
 * @param size          Number of bytes.
 * @return              Minimum number of cells required to fit the byte count.
 */
stock int ByteCountToCells(int size)
{
	if (!size)
	{
		return 1;
	}
	
	return (size + 3) / 4;
}

methodmap ArrayList < Handle {
	// Creates a dynamic global cell array.  While slower than a normal array,
	// it can be used globally AND dynamically, which is otherwise impossible.
	//
	// The contents of the array are uniform; i.e. storing a string at index X
	// and then retrieving it as an integer is NOT the same as StringToInt()!
	// The "blocksize" determines how many cells each array slot has; it cannot
	// be changed after creation.
	//
	// @param blocksize     The number of cells each member of the array can
	//                      hold.  For example, 32 cells is equivalent to:
	//                      new Array[X][32]
	// @param startsize     Initial size of the array.  Note that data will
	//                      NOT be auto-initialized.
	// @return              New Handle to the array object.
	public native ArrayList(int blocksize=1, int startsize=0);

	// Clears an array of all entries.  This is the same as Resize(0).
	public native void Clear();

	// Clones an array, returning a new handle with the same size and data.
	// This should NOT be confused with CloneHandle. This is a completely new
	// handle with the same data but no relation to the original. It should
	// closed when no longer needed.
	//
	// @return              New handle to the cloned array object
	public native ArrayList Clone();

	// Resizes an array.  If the size is smaller than the current size, the
	// array is truncated.  If the size is larger than the current size,
	// the data at the additional indexes will not be initialized.
	//
	// @param newsize       New size.
	public native void Resize(int newsize);

	// Pushes a value onto the end of an array, adding a new index.
	//
	// This may safely be used even if the array has a blocksize greater
	// than 1.
	//
	// @param value         Value to push.
	// @return              Index of the new entry.
	// @error               Invalid Handle or out of memory.
	public native int Push(any value);

	// Pushes a string onto the end of an array, truncating it if it is too big.
	//
	// @param value         String to push.
	// @return              Index of the new entry.
	public native int PushString(const char[] value);

	// Pushes an array of cells onto the end of an array.  The cells
	// are pushed as a block (i.e. the entire array sits at the index),
	// rather than pushing each cell individually.
	//
	// @param values        Block of values to copy.
	// @param size          If not set, the number of elements copied from the array
	//                      will be equal to the blocksize.  If set higher than the
	//                      blocksize, the operation will be truncated.
	// @return              Index of the new entry.
	public native int PushArray(const any[] values, int size=-1);

	// Retrieves a cell value from an array.
	//
	// @param index         Index in the array.
	// @param block         Optionally specify which block to read from
	//                      (useful if the blocksize > 0).
	// @param asChar        Optionally read as a byte instead of a cell.
	// @return              Value read.
	// @error               Invalid index.
	public native any Get(int index, int block=0, bool asChar=false);

	// Retrieves a string value from an array.
	//
	// @param index         Index in the array.
	// @param buffer        Buffer to copy to.
	// @param maxlength     Maximum size of the buffer.
	// @return              Number of characters copied.
	// @error               Invalid index.
	public native int GetString(int index, char[] buffer, int maxlength);

	// Retrieves an array of cells from an array.
	//
	// @param index         Index in the array.
	// @param buffer        Buffer to store the array in.
	// @param size          If not set, assumes the buffer size is equal to the
	//                      blocksize.  Otherwise, the size passed is used.
	// @return              Number of cells copied.
	// @error               Invalid index.
	public native int GetArray(int index, any[] buffer, int size=-1);

	// Sets a cell value in an array.
	//
	// @param index         Index in the array.
	// @param value         Cell value to set.
	// @param block         Optionally specify which block to write to
	//                      (useful if the blocksize > 0).
	// @param asChar        Optionally set as a byte instead of a cell.
	// @error               Invalid index, or invalid block.
	public native void Set(int index, any value, int block=0, bool asChar=false);

	// Sets a string value in an array.
	//
	// @param index         Index in the array.
	// @param value         String value to set.
	// @return              Number of characters copied.
	// @error               Invalid index.
	public native void SetString(int index, const char[] value);

	// Sets an array of cells in an array.
	//
	// @param index         Index in the array.
	// @param values        Array to copy.
	// @param size          If not set, assumes the buffer size is equal to the
	//                      blocksize.  Otherwise, the size passed is used.
	// @return              Number of cells copied.
	// @error               Invalid index.
	public native void SetArray(int index, const any[] values, int size=-1);

	// Shifts an array up.  All array contents after and including the given
	// index are shifted up by one, and the given index is then "free."
	// After shifting, the contents of the given index is undefined.
	//
	// @param index         Index in the array to shift up from.
	// @error               Invalid index.
	public native void ShiftUp(int index);

	// Removes an array index, shifting the entire array down from that position
	// on.  For example, if item 8 of 10 is removed, the last 3 items will then be
	// (6,7,8) instead of (7,8,9), and all indexes before 8 will remain unchanged.
	//
	// @param index         Index in the array to remove at.
	// @error               Invalid index.
	public native void Erase(int index);

	// Swaps two items in the array.
	//
	// @param index1        First index.
	// @param index2        Second index.
	// @error               Invalid index.
	public native void SwapAt(int index1, int index2);

	// Returns the index for the first occurrence of the provided string. If
	// the string cannot be located, -1 will be returned.
	//
	// @param item          String to search for
	// @return              Array index, or -1 on failure
	public native int FindString(const char[] item);

	// Returns the index for the first occurrence of the provided value. If the
	// value cannot be located, -1 will be returned.
	//
	// @param item          Value to search for
	// @param block         Optionally which block to search in
	// @return              Array index, or -1 on failure
	// @error               Invalid block index
	public native int FindValue(any item, int block=0);

	// Sort an ADT Array. Specify the type as Integer, Float, or String.
	//
	// @param order         Sort order to use, same as other sorts.
	// @param type          Data type stored in the ADT Array
	public native void Sort(SortOrder order, SortType type);

	// Custom sorts an ADT Array. You must pass in a comparison function.
	//
	// @param sortfunc      Sort comparison function to use
	// @param hndl          Optional Handle to pass through the comparison calls.
	public native void SortCustom(SortFuncADTArray sortfunc, Handle hndl=INVALID_HANDLE); 

	// Retrieve the size of the array.
	property int Length {
		public native get();
	}
	
	// Retrieve the blocksize the array was created with.
	property int BlockSize {
		public native get();
	}
};

/**
 * Creates a dynamic global cell array.  While slower than a normal array,
 * it can be used globally AND dynamically, which is otherwise impossible.
 *
 * The contents of the array are uniform; i.e. storing a string at index X
 * and then retrieving it as an integer is NOT the same as StringToInt()!
 * The "blocksize" determines how many cells each array slot has; it cannot
 * be changed after creation.
 *
 * @param blocksize     The number of cells each member of the array can
 *                      hold.  For example, 32 cells is equivalent to:
 *                      new Array[X][32]
 * @param startsize     Initial size of the array.  Note that data will
 *                      NOT be auto-initialized.
 * @return              New Handle to the array object.
 */
native ArrayList CreateArray(int blocksize=1, int startsize=0);

/**
 * Clears an array of all entries.  This is the same as ResizeArray(0).
 *
 * @param array         Array Handle.
 * @error               Invalid Handle.
 */
native void ClearArray(Handle array);

/**
 * Clones an array, returning a new handle with the same size and data. This should NOT
 * be confused with CloneHandle. This is a completely new handle with the same data but
 * no relation to the original. You MUST close it.
 *
 * @param array         Array handle to be cloned
 * @return              New handle to the cloned array object
 * @error               Invalid Handle
 */
native Handle CloneArray(Handle array);

/**
 * Resizes an array.  If the size is smaller than the current size,
 * the array is truncated.  If the size is larger than the current size,
 * the data at the additional indexes will not be initialized.
 *
 * @param array         Array Handle.
 * @param newsize       New size.
 * @error               Invalid Handle or out of memory.
 */
native void ResizeArray(Handle array, int newsize);

/**
 * Returns the array size.
 *
 * @param array         Array Handle.
 * @return              Number of elements in the array.
 * @error               Invalid Handle.
 */
native int GetArraySize(Handle array);

/**
 * Pushes a value onto the end of an array, adding a new index.
 *
 * This may safely be used even if the array has a blocksize
 * greater than 1.
 *
 * @param array         Array Handle.
 * @param value         Value to push.
 * @return              Index of the new entry.
 * @error               Invalid Handle or out of memory.
 */
native int PushArrayCell(Handle array, any value);

/**
 * Pushes a string onto the end of an array, truncating it
 * if it is too big.
 *
 * @param array         Array Handle.
 * @param value         String to push.
 * @return              Index of the new entry.
 * @error               Invalid Handle or out of memory.
 */
native int PushArrayString(Handle array, const char[] value);

/**
 * Pushes an array of cells onto the end of an array.  The cells
 * are pushed as a block (i.e. the entire array sits at the index),
 * rather than pushing each cell individually.
 *
 * @param array         Array Handle.
 * @param values        Block of values to copy.
 * @param size          If not set, the number of elements copied from the array
 *                      will be equal to the blocksize.  If set higher than the
 *                      blocksize, the operation will be truncated.
 * @return              Index of the new entry.
 * @error               Invalid Handle or out of memory.
 */
native int PushArrayArray(Handle array, const any[] values, int size=-1);

/**
 * Retrieves a cell value from an array.
 *
 * @param array         Array Handle.
 * @param index         Index in the array.
 * @param block         Optionally specify which block to read from
 *                      (useful if the blocksize > 0).
 * @param asChar        Optionally read as a byte instead of a cell.
 * @return              Value read.
 * @error               Invalid Handle, invalid index, or invalid block.
 */
native any GetArrayCell(Handle array, int index, int block=0, bool asChar=false);

/**
 * Retrieves a string value from an array.
 *
 * @param array         Array Handle.
 * @param index         Index in the array.
 * @param buffer        Buffer to copy to.
 * @param maxlength     Maximum size of the buffer.
 * @return              Number of characters copied.
 * @error               Invalid Handle or invalid index.
 */
native int GetArrayString(Handle array, int index, char[] buffer, int maxlength);

/**
 * Retrieves an array of cells from an array.
 *
 * @param array         Array Handle.
 * @param index         Index in the array.
 * @param buffer        Buffer to store the array in.
 * @param size          If not set, assumes the buffer size is equal to the
 *                      blocksize.  Otherwise, the size passed is used.
 * @return              Number of cells copied.
 * @error               Invalid Handle or invalid index.
 */
native int GetArrayArray(Handle array, int index, any[] buffer, int size=-1);

/**
 * Sets a cell value in an array.
 *
 * @param array         Array Handle.
 * @param index         Index in the array.
 * @param value         Cell value to set.
 * @param block         Optionally specify which block to write to
 *                      (useful if the blocksize > 0).
 * @param asChar        Optionally set as a byte instead of a cell.
 * @error               Invalid Handle, invalid index, or invalid block.
 */
native void SetArrayCell(Handle array, int index, any value, int block=0, bool asChar=false);

/**
 * Sets a string value in an array.
 *
 * @param array         Array Handle.
 * @param index         Index in the array.
 * @param value         String value to set.
 * @return              Number of characters copied.
 * @error               Invalid Handle or invalid index.
 */
native int SetArrayString(Handle array, int index, const char[] value);

/**
 * Sets an array of cells in an array.
 *
 * @param array         Array Handle.
 * @param index         Index in the array.
 * @param values        Array to copy.
 * @param size          If not set, assumes the buffer size is equal to the
 *                      blocksize.  Otherwise, the size passed is used.
 * @return              Number of cells copied.
 * @error               Invalid Handle or invalid index.
 */
native int SetArrayArray(Handle array, int index, const any[] values, int size=-1);

/**
 * Shifts an array up.  All array contents after and including the given
 * index are shifted up by one, and the given index is then "free."
 * After shifting, the contents of the given index is undefined.
 *
 * @param array         Array Handle.
 * @param index         Index in the array to shift up from.
 * @error               Invalid Handle or invalid index.
 */
native void ShiftArrayUp(Handle array, int index);

/**
 * Removes an array index, shifting the entire array down from that position
 * on.  For example, if item 8 of 10 is removed, the last 3 items will then be
 * (6,7,8) instead of (7,8,9), and all indexes before 8 will remain unchanged.
 *
 * @param array         Array Handle.
 * @param index         Index in the array to remove at.
 * @error               Invalid Handle or invalid index.
 */
native void RemoveFromArray(Handle array, int index);

/**
 * Swaps two items in the array.
 *
 * @param array         Array Handle.
 * @param index1        First index.
 * @param index2        Second index.
 * @error               Invalid Handle or invalid index.
 */
native void SwapArrayItems(Handle array, int index1, int index2);

/**
 * Returns the index for the first occurrence of the provided string. If the string
 * cannot be located, -1 will be returned.
 *
 * @param array         Array Handle.
 * @param item          String to search for
 * @return              Array index, or -1 on failure
 * @error               Invalid Handle
 */
native int FindStringInArray(Handle array, const char[] item);

/**
 * Returns the index for the first occurrence of the provided value. If the value
 * cannot be located, -1 will be returned.
 *
 * @param array         Array Handle.
 * @param item          Value to search for
 * @param block         Optionally which block to search in
 * @return              Array index, or -1 on failure
 * @error               Invalid Handle or invalid block
 */
native int FindValueInArray(Handle array, any item, int block=0);

/**
 * Returns the blocksize the array was created with.
 *
 * @param array         Array Handle.
 * @return              The blocksize of the array.
 * @error               Invalid Handle
 */
native int GetArrayBlockSize(Handle array);
/**
 * vim: set ts=4 sw=4 tw=99 noet :
 * =============================================================================
 * SourceMod (C)2004-2014 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _keyvalues_included
 #endinput
#endif
#define _keyvalues_included

/**
 * KeyValue data value types
 */
enum KvDataTypes
{
	KvData_None = 0,    /**< Type could not be identified, or no type */
	KvData_String,      /**< String value */
	KvData_Int,         /**< Integer value */
	KvData_Float,       /**< Floating point value */
	KvData_Ptr,         /**< Pointer value (sometimes called "long") */
	KvData_WString,     /**< Wide string value */
	KvData_Color,       /**< Color value */
	KvData_UInt64,      /**< Large integer value */
	/* --- */
	KvData_NUMTYPES
};

methodmap KeyValues < Handle
{
	// Creates a new KeyValues structure.  The Handle must be closed with
	// CloseHandle() or delete.
	//
	// @param name          Name of the root section.
	// @param firstKey      If non-empty, specifies the first key value.
	// @param firstValue    If firstKey is non-empty, specifies the first key's value.
	public native KeyValues(const char[] name, const char[] firstKey="", const char[] firstValue="");

	// Exports a KeyValues tree to a file. The tree is dumped from the current position.
	//
	// @param file          File to dump write to.
	// @return              True on success, false otherwise.
	public native bool ExportToFile(const char[] file);

	// Exports a KeyValues tree to a string. The string is dumped from the current position.
	//
	// @param buffer        Buffer to write to.
	// @param maxlength     Max length of buffer.
	// @return              Number of bytes that can be written to buffer.
	public native int ExportToString(char[] buffer, int maxlength);

	// Amount of bytes written by ExportToFile & ExportToString.
	property int ExportLength {
		public native get();
	}

	// Imports a file in KeyValues format. The file is read into the current
	// position of the tree.
	//
	// @param file          File to read from.
	// @return              True on success, false otherwise.
	public native bool ImportFromFile(const char[] file);

	// Converts a given string to a KeyValues tree.  The string is read into
	// the current postion of the tree.
	//
	// @param buffer        String buffer to load into the KeyValues.
	// @param resourceName  The resource name of the KeyValues, used for error tracking purposes.
	// @return              True on success, false otherwise.
	public native bool ImportFromString(const char[] buffer, const char[] resourceName="StringToKeyValues");

	// Imports subkeys in the given KeyValues, at the current position in that
	// KeyValues, into the current position in this KeyValues. Note that this
	// copies keys; it does not embed a reference to them.
	//
	// @param other         Origin KeyValues Handle.
	public native void Import(KeyValues other);

	// Sets a string value of a KeyValues key.
	//
	// @param kv            KeyValues Handle.
	// @param key           Name of the key, or NULL_STRING.
	// @param value         String value.
	public native void SetString(const char[] key, const char[] value);

	// Sets an integer value of a KeyValues key.
	//
	// @param key           Name of the key, or NULL_STRING.
	// @param value         Value number.
	public native void SetNum(const char[] key, int value);

	// Sets a large integer value of a KeyValues key.
	//
	// @param key           Name of the key, or NULL_STRING.
	// @param value         Large integer value (0=High bits, 1=Low bits)
	public native void SetUInt64(const char[] key, const int value[2]);

	// Sets a floating point value of a KeyValues key.
	//
	// @param key           Name of the key, or NULL_STRING.
	// @param value         Floating point value.
	public native void SetFloat(const char[] key, float value);

	// Sets a set of color values of a KeyValues key.
	//
	// @param key           Name of the key, or NULL_STRING.
	// @param r             Red value.
	// @param g             Green value.
	// @param b             Blue value.
	// @param a             Alpha value.
	public native void SetColor(const char[] key, int r, int g, int b, int a=0);

	// Sets a set of color values of a KeyValues key.
	//
	// @param key           Name of the key, or NULL_STRING.
	// @param color         Red, green, blue and alpha channels.
	public void SetColor4(const char[] key, const int color[4]) {
		this.SetColor(key, color[0], color[1], color[2], color[3]);
	}

	// Sets a vector value of a KeyValues key.
	//
	// @param key           Name of the key, or NULL_STRING.
	// @param vec           Vector value.
	public native void SetVector(const char[] key, const float vec[3]);

	// Retrieves a string value from a KeyValues key.
	//
	// @param key           Name of the key, or NULL_STRING.
	// @param value         Buffer to store key value in.
	// @param maxlength     Maximum length of the value buffer.
	// @param defvalue      Optional default value to use if the key is not found.
	public native void GetString(const char[] key, char[] value, int maxlength, const char[] defvalue="");

	// Retrieves an integer value from a KeyValues key.
	//
	// @param key           Name of the key, or NULL_STRING.
	// @param defvalue      Optional default value to use if the key is not found.
	// @return              Integer value of the key.
	public native int GetNum(const char[] key, int defvalue=0);

	// Retrieves a floating point value from a KeyValues key.
	//
	// @param key           Name of the key, or NULL_STRING.
	// @param defvalue      Optional default value to use if the key is not found.
	// @return              Floating point value of the key.
	public native float GetFloat(const char[] key, float defvalue=0.0);

	// Retrieves a set of color values from a KeyValues key.
	//
	// @param key           Name of the key, or NULL_STRING.
	// @param r             Red value, set by reference.
	// @param g             Green value, set by reference.
	// @param b             Blue value, set by reference.
	// @param a             Alpha value, set by reference.
	public native void GetColor(const char[] key, int &r, int &g, int &b, int &a);

	// Retrieves a set of color values from a KeyValues key.
	//
	// @param key           Name of the key, or NULL_STRING.
	// @param color         Red, green, blue, and alpha channels.
	public void GetColor4(const char[] key, int color[4]) {
		int r, g, b, a;
		this.GetColor(key, r, g, b, a);
		color[0] = r;
		color[1] = g;
		color[2] = b;
		color[3] = a;
	}

	// Retrieves a large integer value from a KeyValues key.
	//
	// @param key           Name of the key, or NULL_STRING.
	// @param value         Array to represent the large integer.
	// @param defvalue      Optional default value to use if the key is not found.
	public native void GetUInt64(const char[] key, int value[2], int defvalue[2]={0,0});

	// Retrieves a vector value from a KeyValues key.
	//
	// @param key           Name of the key, or NULL_STRING.
	// @param vec           Destination vector to store the value in.
	// @param defvalue      Optional default value to use if the key is not found.
	public native void GetVector(const char[] key, float vec[3], const float defvalue[3]={0.0, 0.0, 0.0});

	// Sets the current position in the KeyValues tree to the given key.
	//
	// @param key           Name of the key.
	// @param create        If true, and the key does not exist, it will be created.
	// @return              True if the key exists, false if it does not and was not created.
	public native bool JumpToKey(const char[] key, bool create=false);

	// Sets the current position in the KeyValues tree to the given key.
	//
	// @param id            KeyValues id.
	// @return              True if the key exists, false if it does not.
	public native bool JumpToKeySymbol(int id);

	// Sets the current position in the KeyValues tree to the first sub key.
	// This native adds to the internal traversal stack.
	//
	// @param keyOnly       If false, non-keys will be traversed (values).
	// @return              True on success, false if there was no first sub key.
	public native bool GotoFirstSubKey(bool keyOnly=true);

	// Sets the current position in the KeyValues tree to the next sub key.
	// This native does NOT add to the internal traversal stack, and thus
	// GoBack() is not needed for each successive call to this function.
	//
	// @param keyOnly       If false, non-keys will be traversed (values).
	// @return              True on success, false if there was no next sub key.
	public native bool GotoNextKey(bool keyOnly=true);

	// Saves the current position in the traversal stack onto the traversal
	// stack.  This can be useful if you wish to use KvGotoNextKey() and
	// have the previous key saved for backwards traversal.
	//
	// @param kv            KeyValues Handle.
	public native void SavePosition();

	// Jumps back to the previous position.  Returns false if there are no
	// previous positions (i.e., at the root node).  This should be called
	// once for each successful Jump call, in order to return to the top node.
	// This function pops one node off the internal traversal stack.
	//
	// @return              True on success, false if there is no higher node.
	public native bool GoBack();

	// Removes the given key from the current position.
	//
	// @param key           Name of the key.
	// @return              True on success, false if key did not exist.
	public native bool DeleteKey(const char[] key);

	// Removes the current sub-key and attempts to set the position
	// to the sub-key after the removed one.  If no such sub-key exists,
	// the position will be the parent key in the traversal stack.
	// Given the sub-key having position "N" in the traversal stack, the
	// removal will always take place from position "N-1."
	//
	// @param kv            KeyValues Handle.
	// @return              1 if removal succeeded and there was another key.
	//                      0 if the current node was not contained in the
	//                        previous node, or no previous node exists.
	//                      -1 if removal succeeded and there were no more keys,
	//                        thus the state is as if KvGoBack() was called.
	public native int DeleteThis();

	// Sets the position back to the top node, emptying the entire node
	// traversal history.  This can be used instead of looping KvGoBack()
	// if recursive iteration is not important.
	//
	// @param kv            KeyValues Handle.
	public native void Rewind();

	// Retrieves the current section name.
	//
	// @param section       Buffer to store the section name.
	// @param maxlength     Maximum length of the name buffer.
	// @return              True on success, false on failure.
	public native bool GetSectionName(char[] section, int maxlength);

	// Sets the current section name.
	//
	// @param section       Section name.
	public native void SetSectionName(const char[] section);

	// Returns the data type at a key.
	//
	// @param key           Key name.
	// @return              KvDataType value of the key.
	public native KvDataTypes GetDataType(const char[] key);

	// Sets whether or not the KeyValues parser will read escape sequences.
	// For example, \n would be read as a literal newline.  This defaults
	// to false for new KeyValues structures.
	//
	// @param useEscapes    Whether or not to read escape sequences.
	public native void SetEscapeSequences(bool useEscapes);

	// Returns the position in the jump stack; I.e. the number of calls
	// required for KvGoBack to return to the root node.  If at the root node,
	// 0 is returned.
	//
	// @return              Number of non-root nodes in the jump stack.
	public native int NodesInStack();

	// Finds a KeyValues name by id.
	//
	// @param id            KeyValues id.
	// @param name          Buffer to store the name.
	// @param maxlength     Maximum length of the value buffer.
	// @return              True on success, false if id not found.
	public native bool FindKeyById(int id, char[] name, int maxlength);

	// Finds a KeyValues id inside a KeyValues tree.
	//
	// @param key           Key name.
	// @param id            Id of the found KeyValue.
	// @return              True on success, false if key not found.
	public native bool GetNameSymbol(const char[] key, int &id);

	// Retrieves the current section id.
	//
	// @param kv            KeyValues Handle.
	// @param id            Id of the current section.
	// @return              True on success, false on failure.
	public native bool GetSectionSymbol(int &id);
};

/**
 * Creates a new KeyValues structure.  The Handle must always be closed.
 *
 * @param name          Name of the root section.
 * @param firstKey      If non-empty, specifies the first key value.
 * @param firstValue    If firstKey is non-empty, specifies the first key's value.
 * @return              A Handle to a new KeyValues structure.
 */
native KeyValues CreateKeyValues(const char[] name, const char[] firstKey="", const char[] firstValue="");

/**
 * Sets a string value of a KeyValues key.
 *
 * @param kv            KeyValues Handle.
 * @param key           Name of the key, or NULL_STRING.
 * @param value         String value.
 * @error               Invalid Handle.
 */
native void KvSetString(Handle kv, const char[] key, const char[] value);

/**
 * Sets an integer value of a KeyValues key.
 *
 * @param kv            KeyValues Handle.
 * @param key           Name of the key, or NULL_STRING.
 * @param value         Value number.
 * @error               Invalid Handle.
 */
native void KvSetNum(Handle kv, const char[] key, int value);

/**
 * Sets a large integer value of a KeyValues key.
 *
 * @param kv            KeyValues Handle.
 * @param key           Name of the key, or NULL_STRING.
 * @param value         Large integer value (0=High bits, 1=Low bits)
 * @error               Invalid Handle.
 */
native void KvSetUInt64(Handle kv, const char[] key, const int value[2]);

/**
 * Sets a floating point value of a KeyValues key.
 *
 * @param kv            KeyValues Handle.
 * @param key           Name of the key, or NULL_STRING.
 * @param value         Floating point value.
 * @error               Invalid Handle.
 */
native void KvSetFloat(Handle kv, const char[] key, float value);

/**
 * Sets a set of color values of a KeyValues key.
 *
 * @param kv            KeyValues Handle.
 * @param key           Name of the key, or NULL_STRING.
 * @param r             Red value.
 * @param g             Green value.
 * @param b             Blue value.
 * @param a             Alpha value.
 * @error               Invalid Handle.
 */
native void KvSetColor(Handle kv, const char[] key, int r, int g, int b, int a=0);

/**
 * Sets a vector value of a KeyValues key.
 *
 * @param kv            KeyValues Handle.
 * @param key           Name of the key, or NULL_STRING.
 * @param vec           Vector value.
 * @error               Invalid Handle.
 */
native void KvSetVector(Handle kv, const char[] key, const float vec[3]);

/**
 * Retrieves a string value from a KeyValues key.
 *
 * @param kv            KeyValues Handle.
 * @param key           Name of the key, or NULL_STRING.
 * @param value         Buffer to store key value in.
 * @param maxlength     Maximum length of the value buffer.
 * @param defvalue      Optional default value to use if the key is not found.
 * @error               Invalid Handle.
 */
native void KvGetString(Handle kv, const char[] key, char[] value, int maxlength, const char[] defvalue="");

/**
 * Retrieves an integer value from a KeyValues key.
 *
 * @param kv            KeyValues Handle.
 * @param key           Name of the key, or NULL_STRING.
 * @param defvalue      Optional default value to use if the key is not found.
 * @return              Integer value of the key.
 * @error               Invalid Handle.
 */
native int KvGetNum(Handle kv, const char[] key, int defvalue=0);

/**
 * Retrieves a floating point value from a KeyValues key.
 *
 * @param kv            KeyValues Handle.
 * @param key           Name of the key, or NULL_STRING.
 * @param defvalue      Optional default value to use if the key is not found.
 * @return              Floating point value of the key.
 * @error               Invalid Handle.
 */
native float KvGetFloat(Handle kv, const char[] key, float defvalue=0.0);

/**
 * Retrieves a set of color values from a KeyValues key.
 *
 * @param kv            KeyValues Handle.
 * @param key           Name of the key, or NULL_STRING.
 * @param r             Red value, set by reference.
 * @param g             Green value, set by reference.
 * @param b             Blue value, set by reference.
 * @param a             Alpha value, set by reference.
 * @error               Invalid Handle.
 */
native void KvGetColor(Handle kv, const char[] key, int &r, int &g, int &b, int &a);

/**
 * Retrieves a large integer value from a KeyValues key.
 *
 * @param kv            KeyValues Handle.
 * @param key           Name of the key, or NULL_STRING.
 * @param value         Array to represent the large integer.
 * @param defvalue      Optional default value to use if the key is not found.
 * @error               Invalid Handle.
 */
native void KvGetUInt64(Handle kv, const char[] key, int value[2], int defvalue[2]={0,0});

/**
 * Retrieves a vector value from a KeyValues key.
 *
 * @param kv            KeyValues Handle.
 * @param key           Name of the key, or NULL_STRING.
 * @param vec           Destination vector to store the value in.
 * @param defvalue      Optional default value to use if the key is not found.
 * @error               Invalid Handle.
 */
native void KvGetVector(Handle kv, const char[] key, float vec[3], const float defvalue[3]={0.0, 0.0, 0.0});

/**
 * Sets the current position in the KeyValues tree to the given key.
 *
 * @param kv            KeyValues Handle.
 * @param key           Name of the key.
 * @param create        If true, and the key does not exist, it will be created.
 * @return              True if the key exists, false if it does not and was not created.
 */
native bool KvJumpToKey(Handle kv, const char[] key, bool create=false);

/**
 * Sets the current position in the KeyValues tree to the given key.
 *
 * @param kv            KeyValues Handle.
 * @param id            KeyValues id.
 * @return              True if the key exists, false if it does not.
 */
native bool KvJumpToKeySymbol(Handle kv, int id);

/**
 * Sets the current position in the KeyValues tree to the first sub key.
 * This native adds to the internal traversal stack.
 *
 * @param kv            KeyValues Handle.
 * @param keyOnly       If false, non-keys will be traversed (values).
 * @return              True on success, false if there was no first sub key.
 * @error               Invalid Handle.
 */
native bool KvGotoFirstSubKey(Handle kv, bool keyOnly=true);

/**
 * Sets the current position in the KeyValues tree to the next sub key.
 * This native does NOT add to the internal traversal stack, and thus
 * KvGoBack() is not needed for each successive call to this function.
 *
 * @param kv            KeyValues Handle.
 * @param keyOnly       If false, non-keys will be traversed (values).
 * @return              True on success, false if there was no next sub key.
 * @error               Invalid Handle.
 */
native bool KvGotoNextKey(Handle kv, bool keyOnly=true);

/**
 * Saves the current position in the traversal stack onto the traversal
 * stack.  This can be useful if you wish to use KvGotoNextKey() and
 * have the previous key saved for backwards traversal.
 *
 * @param kv            KeyValues Handle.
 * @error               Invalid Handle.
 */
native void KvSavePosition(Handle kv);

/**
 * Removes the given key from the current position.
 *
 * @param kv            KeyValues Handle.
 * @param key           Name of the key.
 * @return              True on success, false if key did not exist.
 * @error               Invalid Handle.
 */
native bool KvDeleteKey(Handle kv, const char[] key);

/**
 * Removes the current sub-key and attempts to set the position
 * to the sub-key after the removed one.  If no such sub-key exists,
 * the position will be the parent key in the traversal stack.
 * Given the sub-key having position "N" in the traversal stack, the
 * removal will always take place from position "N-1."
 *
 * @param kv            KeyValues Handle.
 * @return              1 if removal succeeded and there was another key.
 *                      0 if the current node was not contained in the
 *                        previous node, or no previous node exists.
 *                     -1 if removal succeeded and there were no more keys,
 *                        thus the state is as if KvGoBack() was called.
 * @error               Invalid Handle.
 */
native int KvDeleteThis(Handle kv);

/**
 * Jumps back to the previous position.  Returns false if there are no
 * previous positions (i.e., at the root node).  This should be called
 * once for each successful Jump call, in order to return to the top node.
 * This function pops one node off the internal traversal stack.
 *
 * @param kv            KeyValues Handle.
 * @return              True on success, false if there is no higher node.
 * @error               Invalid Handle.
 */
native bool KvGoBack(Handle kv);

/**
 * Sets the position back to the top node, emptying the entire node
 * traversal history.  This can be used instead of looping KvGoBack()
 * if recursive iteration is not important.
 *
 * @param kv            KeyValues Handle.
 * @error               Invalid Handle.
 */
native void KvRewind(Handle kv);

/**
 * Retrieves the current section name.
 *
 * @param kv            KeyValues Handle.
 * @param section       Buffer to store the section name.
 * @param maxlength     Maximum length of the name buffer.
 * @return              True on success, false on failure.
 * @error               Invalid Handle.
 */
native bool KvGetSectionName(Handle kv, char[] section, int maxlength);

/**
 * Sets the current section name.
 *
 * @param kv            KeyValues Handle.
 * @param section       Section name.
 * @error               Invalid Handle.
 */
native void KvSetSectionName(Handle kv, const char[] section);

/**
 * Returns the data type at a key.
 *
 * @param kv            KeyValues Handle.
 * @param key           Key name.
 * @return              KvDataType value of the key.
 * @error               Invalid Handle.
 */
native KvDataTypes KvGetDataType(Handle kv, const char[] key);

/**
 * Converts a KeyValues tree to a file.  The tree is dumped
 * from the current position.
 *
 * @param kv            KeyValues Handle.
 * @param file          File to dump write to.
 * @return              True on success, false otherwise.
 * @error               Invalid Handle.
 */
native bool KeyValuesToFile(Handle kv, const char[] file);

/**
 * Converts a file to a KeyValues tree.  The file is read into
 * the current position of the tree.
 *
 * @param kv            KeyValues Handle.
 * @param file          File to read from.
 * @return              True on success, false otherwise.
 * @error               Invalid Handle.
 */
native bool FileToKeyValues(Handle kv, const char[] file);

/**
 * Converts a given string to a KeyValues tree.  The string is read into
 * the current postion of the tree.
 *
 * @param kv            KeyValues Handle.
 * @param buffer        String buffer to load into the KeyValues.
 * @param resourceName  The resource name of the KeyValues, used for error tracking purposes.
 * @return              True on success, false otherwise.
 * @error               Invalid Handle.
 */
native bool StringToKeyValues(Handle kv, const char[] buffer, const char[] resourceName="StringToKeyValues");

/**
 * Sets whether or not the KeyValues parser will read escape sequences.
 * For example, \n would be read as a literal newline.  This defaults
 * to false for new KeyValues structures.
 *
 * @param kv            KeyValues Handle.
 * @param useEscapes    Whether or not to read escape sequences.
 * @error               Invalid Handle.
 */
native void KvSetEscapeSequences(Handle kv, bool useEscapes);

/**
 * Returns the position in the jump stack; I.e. the number of calls
 * required for KvGoBack to return to the root node.  If at the root node,
 * 0 is returned.
 *
 * @param kv            KeyValues Handle.
 * @return              Number of non-root nodes in the jump stack.
 * @error               Invalid Handle.
 */
native int KvNodesInStack(Handle kv);

/**
 * Makes a new copy of all subkeys in the origin KeyValues to
 * the destination KeyValues.
 * NOTE: All KeyValues are processed from the current location not the root one.
 *
 * @param origin        Origin KeyValues Handle.
 * @param dest          Destination KeyValues Handle.
 * @error               Invalid Handle.
 */
native void KvCopySubkeys(Handle origin, Handle dest);

/**
 * Finds a KeyValues name by id.
 *
 * @param kv            KeyValues Handle.
 * @param id            KeyValues id.
 * @param name          Buffer to store the name.
 * @param maxlength     Maximum length of the value buffer.
 * @return              True on success, false if id not found.
 * @error               Invalid Handle.
 */
native bool KvFindKeyById(Handle kv, int id, char[] name, int maxlength);

/**
 * Finds a KeyValues id inside a KeyValues tree.
 *
 * @param kv            KeyValues Handle.
 * @param key           Key name.
 * @param id            Id of the found KeyValue.
 * @return              True on success, false if key not found.
 * @error               Invalid Handle.
 */
native bool KvGetNameSymbol(Handle kv, const char[] key, int &id);

/**
 * Retrieves the current section id.
 *
 * @param kv            KeyValues Handle.
 * @param id            Id of the current section.
 * @return              True on success, false on failure.
 * @error               Invalid Handle.
 */
native bool KvGetSectionSymbol(Handle kv, int &id);
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _sdktools_functions_included
 #endinput
#endif
#define _sdktools_functions_included

/**
 * Removes a player's item.
 *
 * @param client        Client index.
 * @param item          CBaseCombatWeapon entity index.
 * @return              True on success, false otherwise.
 * @error               Invalid client or entity, lack of mod support, or client not in
 *                      game.
 */
native bool RemovePlayerItem(int client, int item);

/**
 * Gives a named item to a player.
 *
 * @param client        Client index.
 * @param item          Item classname (such as weapon_ak47).
 * @param iSubType      Unknown.
 * @return              Entity index on success, or -1 on failure.
 * @error               Invalid client or client not in game, or lack of mod support.
 */
native int GivePlayerItem(int client, const char[] item, int iSubType=0);

/**
 * Returns the weapon in a player's slot.
 *
 * @param client        Client index.
 * @param slot          Slot index (mod specific).
 * @return              Entity index on success, -1 if no weapon existed.
 * @error               Invalid client or client not in game, or lack of mod support.
 */
native int GetPlayerWeaponSlot(int client, int slot);

/**
 * Ignites an entity on fire.
 *
 * @param entity        Entity index.
 * @param time          Number of seconds to set on fire.
 * @param npc           True to only affect NPCs.
 * @param size          Unknown.
 * @param level         Unknown.
 * @error               Invalid entity or client not in game, or lack of mod support.
 */
native void IgniteEntity(int entity, float time, bool npc=false, float size=0.0, bool level=false);

/**
 * Extinguishes an entity that is on fire.
 *
 * @param entity        Entity index.
 * @error               Invalid entity or client not in game, or lack of mod support.
 */
native void ExtinguishEntity(int entity);

/**
 * Teleports an entity.
 *
 * @param entity        Client index.
 * @param origin        New origin, or NULL_VECTOR for no change.
 * @param angles        New angles, or NULL_VECTOR for no change.
 * @param velocity      New velocity, or NULL_VECTOR for no change.
 * @error               Invalid entity or client not in game, or lack of mod support.
 */
native void TeleportEntity(int entity, const float origin[3], const float angles[3], const float velocity[3]);

/**
 * Forces a player to commit suicide.
 *
 * @param client        Client index.
 * @error               Invalid client or client not in game, or lack of mod support.
 */
native void ForcePlayerSuicide(int client);

/**
 * Slaps a player in a random direction.
 *
 * @param client        Client index.
 * @param health        Health to subtract.
 * @param sound         False to disable the sound effects.
 * @error               Invalid client or client not in game, or lack of mod support.
 */
native void SlapPlayer(int client, int health=5, bool sound=true);

/**
 * Searches for an entity by classname.
 *
 * @param startEnt      The entity index after which to begin searching from.
 *                      Use -1 to start from the first entity.
 * @param classname     Classname of the entity to find.
 * @return              Entity index >= 0 if found, -1 otherwise.
 * @error               Lack of mod support.
 */
native int FindEntityByClassname(int startEnt, const char[] classname);

/**
 * Returns the client's eye angles.
 *
 * @param client        Player's index.
 * @param ang           Destination vector to store the client's eye angles.
 * @return              True on success, false on failure.
 * @error               Invalid client index, client not in game, or no mod support.
 */
native bool GetClientEyeAngles(int client, float ang[3]);

/**
 * Creates an entity by string name, but does not spawn it (see DispatchSpawn).
 * If ForceEdictIndex is not -1, then it will use the edict by that index. If the index is
 *  invalid or there is already an edict using that index, it will error out.
 *
 * @param classname         Entity classname.
 * @param ForceEdictIndex   Edict index used by the created entity (ignored on Orangebox and above).
 * @return                  Entity index on success, or -1 on failure.
 * @error                   Invalid edict index, or no mod support.
 */
native int CreateEntityByName(const char[] classname, int ForceEdictIndex=-1);

/**
 * Spawns an entity into the game.
 *
 * @param entity        Entity index of the created entity.
 * @return              True on success, false otherwise.
 * @error               Invalid entity index, or no mod support.
 */
native bool DispatchSpawn(int entity);

/**
 * Dispatches a KeyValue into given entity using a string value.
 *
 * @param entity        Destination entity index.
 * @param keyName       Name of the key.
 * @param value         String value.
 * @return              True on success, false otherwise.
 * @error               Invalid entity index, or no mod support.
 */
native bool DispatchKeyValue(int entity, const char[] keyName, const char[] value);

/**
 * Dispatches a KeyValue into given entity using a floating point value.
 *
 * @param entity        Destination entity index.
 * @param keyName       Name of the key.
 * @param value         Floating point value.
 * @return              True on success, false otherwise.
 * @error               Invalid entity index, or no mod support.
 */
native bool DispatchKeyValueFloat(int entity, const char[] keyName, float value);

/**
 * Dispatches a KeyValue into given entity using a vector value.
 *
 * @param entity        Destination entity index.
 * @param keyName       Name of the key.
 * @param vec           Vector value.
 * @return              True on success, false otherwise.
 * @error               Invalid entity index, or no mod support.
 */
native bool DispatchKeyValueVector(int entity, const char[] keyName, const float vec[3]);

/**
 * Returns the entity a client is aiming at.
 *
 * @param client        Client performing the aiming.
 * @param only_clients  True to exclude all entities but clients.
 * @return              Entity index being aimed at.
 *                      -1 if no entity is being aimed at.
 *                      -2 if the function is not supported.
 * @error               Invalid client index or client not in game.
 */
native int GetClientAimTarget(int client, bool only_clients=true);

/**
 * Returns the total number of teams in a game.
 * Note: This native should not be called before OnMapStart.
 *
 * @return              Total number of teams.
 */
native int GetTeamCount();

/**
 * Retrieves the team name based on a team index.
 * Note: This native should not be called before OnMapStart.
 *
 * @param index         Team index.
 * @param name          Buffer to store string in.
 * @param maxlength     Maximum length of string buffer.
 * @error               Invalid team index.
 */
native void GetTeamName(int index, char[] name, int maxlength);

/**
 * Returns the score of a team based on a team index.
 * Note: This native should not be called before OnMapStart.
 *
 * @param index         Team index.
 * @return              Score.
 * @error               Invalid team index.
 */
native int GetTeamScore(int index);

/**
 * Sets the score of a team based on a team index.
 * Note: This native should not be called before OnMapStart.
 *
 * @param index         Team index.
 * @param value         New score value.
 * @error               Invalid team index.
 */
native void SetTeamScore(int index, int value);

/**
 * Retrieves the number of players in a certain team.
 * Note: This native should not be called before OnMapStart.
 *
 * @param index         Team index.
 * @return              Number of players in the team.
 * @error               Invalid team index.
 */
native int GetTeamClientCount(int index);

/**
 * Returns the entity index of a team.
 *
 * @param teamIndex     Team index.
 * @return              Entity index of team.
 * @error               Invalid team index.
 */
native int GetTeamEntity(int teamIndex);

/**
 * Sets the model to a given entity.
 *
 * @param entity        Entity index.
 * @param model         Model name.
 * @error               Invalid entity index, or no mod support.
 */
native void SetEntityModel(int entity, const char[] model);

/**
 * Retrieves the decal file name associated with a given client.
 *
 * @param client        Player's index.
 * @param hex           Buffer to store the logo filename.
 * @param maxlength     Maximum length of string buffer.
 * @return              True on success, otherwise false.
 * @error               Invalid client or client not in game.
 */
native bool GetPlayerDecalFile(int client, char[] hex, int maxlength);

/**
 * Retrieves the jingle file name associated with a given client.
 *
 * @param client        Player's index.
 * @param hex           Buffer to store the jingle filename.
 * @param maxlength     Maximum length of string buffer.
 * @return              True on success, otherwise false.
 * @error               Invalid client or client not in game.
 */
native bool GetPlayerJingleFile(int client, char[] hex, int maxlength);

/**
 * Returns the average server network traffic in bytes/sec.
 *
 * @param in            Buffer to store the input traffic velocity.
 * @param out           Buffer to store the output traffic velocity.
 */
native void GetServerNetStats(float &inAmount, float &outAmout);

/**
 * Equip's a player's weapon.
 *
 * @param client        Client index.
 * @param weapon        CBaseCombatWeapon entity index.
 * @error               Invalid client or entity, lack of mod support, or client not in
 *                      game.
 */
native void EquipPlayerWeapon(int client, int weapon);

/**
 * Activates an entity (CBaseAnimating::Activate)
 *
 * @param entity        Entity index.
 * @error               Invalid entity or lack of mod support.
 */
native void ActivateEntity(int entity);

/**
 * Sets values to client info buffer keys and notifies the engine of the change.
 * The change does not get propagated to mods until the next frame.
 *
 * @param client        Player's index.
 * @param key           Key string.
 * @param value         Value string.
 * @error               Invalid client index, or client not connected.
 */
native void SetClientInfo(int client, const char[] key, const char[] value);

/**
 * Changes a client's name.
 *
 * @param client        Player's index.
 * @param name          New name.
 * @error               Invalid client index, or client not connected.
 */
native void SetClientName(int client, const char[] name);

/**
 * Gives ammo of a certain type to a player.
 * This natives obeys the maximum amount of ammo a player can carry per ammo type.
 *
 * @param client        The client index.
 * @param amount        Amount of ammo to give. Is capped at ammotype's limit.
 * @param ammotype      Type of ammo to give to player.
 * @param suppressSound If true, don't play the ammo pickup sound.
 * @return              Amount of ammo actually given.
 */
native int GivePlayerAmmo(int client, int amount, int ammotype, bool suppressSound=false);
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */
 
#if defined _helpers_included
 #endinput
#endif
#define _helpers_included

/**
 * This function is deprecated. Use the %L format specifier instead.
 * 
 * Formats a user's info as log text.
 *
 * @param client        Client index.
 * @param buffer        Buffer for text.
 * @param maxlength     Maximum length of text.
 * @deprecated          Use the %L format specifier instead.
 */
#pragma deprecated Use the %L format specifier instead.
stock void FormatUserLogText(int client, char[] buffer, int maxlength)
{
	FormatEx(buffer, maxlength, "\"%L\"", client);
}

/**
 * Returns plugin handle from plugin filename.
 *
 * @param filename      Filename of the plugin to search for.
 * @return              Handle to plugin if found, INVALID_HANDLE otherwise.
 */
stock Handle FindPluginByFile(const char[] filename)
{
	char buffer[256];
	
	Handle iter = GetPluginIterator();
	Handle pl;
	
	while (MorePlugins(iter))
	{
		pl = ReadPlugin(iter);
		
		GetPluginFilename(pl, buffer, sizeof(buffer));
		if (strcmp(buffer, filename, false) == 0)
		{
			CloseHandle(iter);
			return pl;
		}
	}
	
	CloseHandle(iter);
	
	return INVALID_HANDLE;
}

/**
 * @deprecated          Use FindTarget() or ProcessTargetString().
 */
#pragma deprecated Use FindTarget() or ProcessTargetString()
stock int SearchForClients(const char[] pattern, int[] clients, int maxClients)
{
	int total = 0;
	
	if (maxClients == 0)
	{
		return 0;
	}
	
	if (pattern[0] == '#')
	{
		int input = StringToInt(pattern[1]);
		if (!input) {
			char name[MAX_NAME_LENGTH];
			for (int i=1; i<=MaxClients; i++)
			{
				if (!IsClientInGame(i))
				{
					continue;
				}
				GetClientName(i, name, sizeof(name));
				if (strcmp(name, pattern, false) == 0)
				{
					clients[0] = i;
					return 1;
				}
			}
		}
		else
		{
			int client = GetClientOfUserId(input);
			if (client)
			{
				clients[0] = client;
				return 1;
			}
		}
	}
	
	char name[MAX_NAME_LENGTH];
	for (int i=1; i<=MaxClients; i++)
	{
		if (!IsClientInGame(i))
		{
			continue;
		}

		GetClientName(i, name, sizeof(name));
		if (StrContains(name, pattern, false) != -1)
		{
			clients[total++] = i;
			if (total >= maxClients)
			{
				break;
			}
		}
	}
	
	return total;
}

/**
 * Wraps ProcessTargetString() and handles producing error messages for
 * bad targets.
 *
 * Note that you should use LoadTranslations("common.phrases") in OnPluginStart(). 
 * "common.phrases" contains all of the translatable phrases that FindTarget() will
 * reply with in the event a target is not found (error).
 *
 * @param client        Client who issued command
 * @param target        Client's target argument
 * @param nobots        Optional. Set to true if bots should NOT be targetted
 * @param immunity      Optional. Set to false to ignore target immunity.
 * @return              Index of target client, or -1 on error.
 */
stock int FindTarget(int client, const char[] target, bool nobots = false, bool immunity = true)
{
	char target_name[MAX_TARGET_LENGTH];
	int target_list[1], target_count;
	bool tn_is_ml;
	
	int flags = COMMAND_FILTER_NO_MULTI;
	if (nobots)
	{
		flags |= COMMAND_FILTER_NO_BOTS;
	}
	
	if (!immunity)
	{
		flags |= COMMAND_FILTER_NO_IMMUNITY;
	}
	
	if ((target_count = ProcessTargetString(
			target,
			client, 
			target_list, 
			1, 
			flags,
			target_name,
			sizeof(target_name),
			tn_is_ml)) > 0)
	{
		return target_list[0];
	}

	ReplyToTargetError(client, target_count);
	return -1;
}

/**
 * This function is no longer supported.  It has been replaced with ReadMapList(), 
 * which uses a more unified caching and configuration mechanism.  This function also 
 * has a bug where if the cvar contents changes, the fileTime change won't be recognized.
 * 
 * Loads a specified array with maps. The maps will be either loaded from mapcyclefile, or if supplied
 * a cvar containing a file name. If the file in the cvar is bad, it will use mapcyclefile. The fileTime
 * parameter is used to store a timestamp of the file. If specified, the file will only be reloaded if it
 * has changed.
 *
 * @param array         Valid array handle, should be created with CreateArray(33) or larger. 
 * @param fileTime      Variable containing the "last changed" time of the file. Used to avoid needless reloading.
 * @param fileCvar      CVAR set to the file to be loaded. Optional.
 * @return              Number of maps loaded or 0 if in error.
 * @deprecated          Use ReadMapList() instead.
 */
#pragma deprecated Use ReadMapList() instead. 
stock int LoadMaps(Handle array, int &fileTime = 0, Handle fileCvar = INVALID_HANDLE)
{ 
	char mapPath[256], mapFile[64];
	bool fileFound = false;
	
	if (fileCvar != INVALID_HANDLE)
	{
		GetConVarString(fileCvar, mapFile, 64);
		BuildPath(Path_SM, mapPath, sizeof(mapPath), mapFile);
		fileFound = FileExists(mapPath);
	}
 
	if (!fileFound)
	{
		Handle mapCycleFile = FindConVar("mapcyclefile");
		GetConVarString(mapCycleFile, mapPath, sizeof(mapPath));
		fileFound = FileExists(mapPath);
	}
	
	if (!fileFound)
	{
		LogError("Failed to find a file to load maps from. No maps loaded.");
		ClearArray(array);
		
		return 0;		
	}
 
	// If the file hasn't changed, there's no reason to reload
	// all of the maps.
	int newTime =  GetFileTime(mapPath, FileTime_LastChange);
	if (fileTime == newTime)
	{
		return GetArraySize(array);
	}
	
	fileTime = newTime;
	
	ClearArray(array);
 
	File file = OpenFile(mapPath, "rt");
	if (!file) {
		LogError("Could not open file: %s", mapPath);
		return 0;
	}
 
	LogMessage("Loading maps from file: %s", mapPath);
	
	int len;
	char buffer[64];
	while (!file.EndOfFile() && file.ReadLine(buffer, sizeof(buffer)))
	{
		TrimString(buffer);
 
		if ((len = StrContains(buffer, ".bsp", false)) != -1)
		{
			buffer[len] = '\0';
		}
 
		if (buffer[0] == '\0' || !IsValidConVarChar(buffer[0]) || !IsMapValid(buffer))
		{
			continue;
		}
		
		if (FindStringInArray(array, buffer) != -1)
		{
			continue;
		}
 
		PushArrayString(array, buffer);
	}
 
	file.Close();
	return GetArraySize(array);
}
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _lang_included
 #endinput
#endif
#define _lang_included

#define LANG_SERVER 0      /**< Translate using the server's language */

/**
 * Loads a translation file for the plugin calling this native.
 * If no extension is specified, .txt is assumed.
 *
 * @param file          Translation file.
 */
native void LoadTranslations(const char[] file);

/**
 * Sets the global language target.  This is useful for creating functions
 * that will be compatible with the %t format specifier.  Note that invalid
 * indexes can be specified but the error will occur during translation,
 * not during this function call.
 *
 * @param client        Client index or LANG_SERVER.
 */
native void SetGlobalTransTarget(int client);

/**
 * Retrieves the language number of a client.
 *
 * @param client        Client index.
 * @return              Language number client is using.
 * @error               Invalid client index or client not connected.
 */
native int GetClientLanguage(int client);

/**
 * Retrieves the server's language.
 *
 * @return              Language number server is using.
 */
native int GetServerLanguage();

/**
 * Returns the number of languages known in languages.cfg.
 *
 * @return              Language count.
 */
native int GetLanguageCount();

/**
 * Retrieves info about a given language number.
 *
 * @param language      Language number.
 * @param code          Language code buffer (2-3 characters usually).
 * @param codeLen       Maximum length of the language code buffer.
 * @param name          Language name buffer.
 * @param nameLen       Maximum length of the language name buffer.
 * @error               Invalid language number.
 */
native void GetLanguageInfo(int language, char[] code="", int codeLen=0, char[] name="", int nameLen=0);

/**
 * Sets the language number of a client.
 *
 * @param client        Client index.
 * @param language      Language number.
 * @error               Invalid client index or client not connected.
 */
native void SetClientLanguage(int client, int language);

/**
 * Retrieves the language number from a language code.
 *
 * @param code          Language code (2-3 characters usually).
 * @return              Language number. -1 if not found.
 */
native int GetLanguageByCode(const char[] code);

/**
 * Retrieves the language number from a language name.
 *
 * @param name          Language name (case insensitive).
 * @return              Language number. -1 if not found.
 */
native int GetLanguageByName(const char[] name);

/**
 * Determines if the specified phrase exists within the plugin's
 * translation cache.
 *
 * @param phrase        Phrase to look for.
 * @return              True if phrase exists.
 */
native bool TranslationPhraseExists(const char[] phrase);

/**
 * Determines if there is a translation for the specified language.
 *
 * @param phrase        Phrase to check.
 * @param language      Language number.
 * @return              True if translation exists.
 */
native bool IsTranslatedForLanguage(const char[] phrase, int language);
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _handles_included
 #endinput
#endif
#define _handles_included

/**
 * Preset Handle values.
 */
enum Handle // Tag disables introducing "Handle" as a symbol.
{
	INVALID_HANDLE = 0
};


/**
 * Closes a Handle.  If the handle has multiple copies open,
 * it is not destroyed unless all copies are closed.
 *
 * @note Closing a Handle has a different meaning for each Handle type.  Make
 *       sure you read the documentation on whatever provided the Handle.
 *
 * @param hndl      Handle to close.
 * @error           Invalid handles will cause a run time error.
 */
native void CloseHandle(Handle hndl);

/**
 * Clones a Handle.  When passing handles in between plugins, caching handles
 * can result in accidental invalidation when one plugin releases the Handle, or is its owner
 * is unloaded from memory.  To prevent this, the Handle may be "cloned" with a new owner.
 *
 * @note Usually, you will be cloning Handles for other plugins.  This means that if you clone
 *       the Handle without specifying the new owner, it will assume the identity of your original
 *       calling plugin, which is not very useful.  You should either specify that the receiving
 *       plugin should clone the handle on its own, or you should explicitly clone the Handle
 *       using the receiving plugin's identity Handle.
 *
 * @param hndl      Handle to clone/duplicate.
 * @param plugin    Optional Handle to another plugin to mark as the new owner.
 *                  If no owner is passed, the owner becomes the calling plugin.
 * @return          Handle on success, INVALID_HANDLE if not cloneable.
 * @error           Invalid handles will cause a run time error.
 */
native Handle CloneHandle(Handle hndl, Handle plugin=INVALID_HANDLE);

using __intrinsics__.Handle;

/**
 * Do not use this function.  Returns if a Handle and its contents
 * are readable, whereas INVALID_HANDLE only checks for the absence
 * of a Handle.
 *
 * This function is intended only for tests where the validity of a
 * Handle can absolutely not be known.
 *
 * Do not use this to check the return values of functions, or to
 * check if timers should be closed (except in very rare cases).
 * This function is for very specific usage and using it for general
 * purpose routines can and will hide very subtle bugs.
 *
 * @param hndl      Handle to test for validity.
 * @return          True if handle is valid, false otherwise.
 * @deprecated      Do not use this function.
 */
#pragma deprecated Do not use this function.
native bool IsValidHandle(Handle hndl);
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _sourcemod_included
 #endinput
#endif
#define _sourcemod_included

/**
 * Plugin public information.
 */
struct Plugin
{
   public const char[] name;        /**< Plugin Name */
   public const char[] description; /**< Plugin Description */
   public const char[] author;      /**< Plugin Author */
   public const char[] version;     /**< Plugin Version */
   public const char[] url;         /**< Plugin URL */
};

#include <core>
#include <float>
#include <vector>
#include <string>
#include <handles>
#include <functions>
#include <files>
#include <logging>
#include <timers>
#include <admin>
#include <keyvalues>
#include <dbi>
#include <lang>
#include <sorting>
#include <textparse>
#include <clients>
#include <console>
#include <convars>
#include <events>
#include <bitbuffer>
#include <protobuf>
#include <usermessages>
#include <menus>
#include <halflife>
#include <adt>
#include <banning>
#include <commandfilters>
#include <nextmap>
#include <commandline>

enum APLRes
{
	APLRes_Success = 0,     /**< Plugin should load */
	APLRes_Failure,         /**< Plugin shouldn't load and should display an error */
	APLRes_SilentFailure    /**< Plugin shouldn't load but do so silently */
};

methodmap GameData < Handle
{
	// Loads a game config file.
	//
	// @param file          File to load.  The path must be relative to the 'gamedata' folder under the config folder
	//                      and the extension should be omitted.
	// @return              A handle to the game config file or null on failure.
	public native GameData(const char[] file);

	// Returns an offset value.
	//
	// @param key           Key to retrieve from the offset section.
	// @return              An offset, or -1 on failure.
	public native int GetOffset(const char[] key);

	// Gets the value of a key from the "Keys" section.
	//
	// @param key           Key to retrieve from the Keys section.
	// @param buffer        Destination string buffer.
	// @param maxlen        Maximum length of output string buffer.
	// @return              True if key existed, false otherwise.
	public native bool GetKeyValue(const char[] key, char[] buffer, int maxlen);

	// Finds an address calculation in a GameConfig file,
	// performs LoadFromAddress on it as appropriate, then returns the final address.
	//
	// @param name          Name of the property to find.
	// @return              An address calculated on success, or 0 on failure.
	public native Address GetAddress(const char[] name);
};

/**
 * Called when the plugin is fully initialized and all known external references
 * are resolved. This is only called once in the lifetime of the plugin, and is
 * paired with OnPluginEnd().
 *
 * If any run-time error is thrown during this callback, the plugin will be marked
 * as failed.
 */
forward void OnPluginStart();

/**
 * @deprecated Use AskPluginLoad2() instead.
 * If a plugin contains both AskPluginLoad() and AskPluginLoad2(), the former will
 * not be called, but old plugins with only AskPluginLoad() will work.
 */
#pragma deprecated Use AskPluginLoad2() instead
forward bool AskPluginLoad(Handle myself, bool late, char[] error, int err_max);

/**
 * Called before OnPluginStart, in case the plugin wants to check for load failure.
 * This is called even if the plugin type is "private."  Any natives from modules are
 * not available at this point.  Thus, this forward should only be used for explicit
 * pre-emptive things, such as adding dynamic natives, setting certain types of load
 * filters (such as not loading the plugin for certain games).
 *
 * @note It is not safe to call externally resolved natives until OnPluginStart().
 * @note Any sort of RTE in this function will cause the plugin to fail loading.
 * @note If you do not return anything, it is treated like returning success.
 * @note If a plugin has an AskPluginLoad2(), AskPluginLoad() will not be called.
 *
 * @param myself        Handle to the plugin.
 * @param late          Whether or not the plugin was loaded "late" (after map load).
 * @param error         Error message buffer in case load failed.
 * @param err_max       Maximum number of characters for error message buffer.
 * @return              APLRes_Success for load success, APLRes_Failure or APLRes_SilentFailure otherwise
 */
forward APLRes AskPluginLoad2(Handle myself, bool late, char[] error, int err_max);

/**
 * Called when the plugin is about to be unloaded.
 *
 * It is not necessary to close any handles or remove hooks in this function.
 * SourceMod guarantees that plugin shutdown automatically and correctly releases
 * all resources.
 */
forward void OnPluginEnd();

/**
 * Called when the plugin's pause status is changing.
 *
 * @param pause         True if the plugin is being paused, false otherwise.
 */
forward void OnPluginPauseChange(bool pause);

/**
 * Called before every server frame.  Note that you should avoid
 * doing expensive computations or declaring large local arrays.
 */
forward void OnGameFrame();

/**
 * Called when the map is loaded.
 *
 * @note This used to be OnServerLoad(), which is now deprecated.
 *       Plugins still using the old forward will work.
 */
forward void OnMapStart();

/**
 * Called right before a map ends.
 */
forward void OnMapEnd();

/**
 * Called when the map has loaded, servercfgfile (server.cfg) has been
 * executed, and all plugin configs are done executing.  This is the best
 * place to initialize plugin functions which are based on cvar data.
 *
 * @note This will always be called once and only once per map.  It will be
 *       called after OnMapStart().
 */
forward void OnConfigsExecuted();

/**
 * This is called once, right after OnMapStart() but any time before
 * OnConfigsExecuted().  It is called after the "exec sourcemod.cfg"
 * command and all AutoExecConfig() exec commands have been added to
 * the ServerCommand() buffer.
 *
 * If you need to load per-map settings that override default values,
 * adding commands to the ServerCommand() buffer here will guarantee
 * that they're set before OnConfigsExecuted().
 *
 * Unlike OnMapStart() and OnConfigsExecuted(), this is not called on
 * late loads that occur after OnMapStart().
 */
forward void OnAutoConfigsBuffered();

/**
 * @deprecated          Use OnConfigsExecuted() instead.
 */
#pragma deprecated Use OnConfigsExecuted() instead
forward void OnServerCfg();

/**
 * Called after all plugins have been loaded.  This is called once for
 * every plugin.  If a plugin late loads, it will be called immediately
 * after OnPluginStart().
 */
forward void OnAllPluginsLoaded();

/**
 * Returns the calling plugin's Handle.
 *
 * @return              Handle of the calling plugin.
 */
native Handle GetMyHandle();

/**
 * Returns an iterator that can be used to search through plugins.
 *
 * @return              Handle to iterate with.  Must be closed via
 *                      CloseHandle().
 * @error               Invalid Handle.
 */
native Handle GetPluginIterator();

/**
 * Returns whether there are more plugins available in the iterator.
 *
 * @param iter          Handle to the plugin iterator.
 * @return              True on more plugins, false otherwise.
 * @error               Invalid Handle.
 */
native bool MorePlugins(Handle iter);

/**
 * Returns the current plugin in the iterator and advances the iterator.
 *
 * @param iter          Handle to the plugin iterator.
 * @return              Current plugin the iterator is at, before
 *                      the iterator is advanced.
 * @error               Invalid Handle.
 */
native Handle ReadPlugin(Handle iter);

/**
 * Returns a plugin's status.
 *
 * @param plugin        Plugin Handle (INVALID_HANDLE uses the calling plugin).
 * @return              Status code for the plugin.
 * @error               Invalid Handle.
 */
native PluginStatus GetPluginStatus(Handle plugin);

/**
 * Retrieves a plugin's file name relative to the plugins folder.
 *
 * @param plugin        Plugin Handle (INVALID_HANDLE uses the calling plugin).
 * @param buffer        Buffer to the store the file name.
 * @param maxlength     Maximum length of the name buffer.
 * @error               Invalid Handle.
 */
native void GetPluginFilename(Handle plugin, char[] buffer, int maxlength);

/**
 * Retrieves whether or not a plugin is being debugged.
 *
 * @param plugin        Plugin Handle (INVALID_HANDLE uses the calling plugin).
 * @return              True if being debugged, false otherwise.
 * @error               Invalid Handle.
 */
native bool IsPluginDebugging(Handle plugin);

/**
 * Retrieves a plugin's public info.
 *
 * @param plugin        Plugin Handle (INVALID_HANDLE uses the calling plugin).
 * @param info          Plugin info property to retrieve.
 * @param buffer        Buffer to store info in.
 * @param maxlength     Maximum length of buffer.
 * @return              True on success, false if property is not available.
 * @error               Invalid Handle.
 */
native bool GetPluginInfo(Handle plugin, PluginInfo info, char[] buffer, int maxlength);

/**
 * Finds a plugin by its order in the list from the "plugins list" server
 * "sm" command.  You should not use this function to loop through all plugins,
 * use the iterator instead.  Looping through all plugins using this native
 * is O(n^2), whereas using the iterator is O(n).
 *
 * @param order_num     Number of the plugin as it appears in "sm plugins list".
 * @return              Plugin Handle on success, INVALID_HANDLE if no plugin
 *                      matches the given number.
 */
native Handle FindPluginByNumber(int order_num);

/**
 * Causes the plugin to enter a failed state.  An error will be thrown and
 * the plugin will be paused until it is unloaded or reloaded.
 *
 * For backwards compatibility, if no extra arguments are passed, no
 * formatting is applied.  If one or more additional arguments is passed,
 * the string is formatted using Format().  If any errors are encountered
 * during formatting, both the format specifier string and an additional
 * error message are written.
 *
 * This function does not return, and no further code in the plugin is
 * executed.
 *
 * @param string        Format specifier string.
 * @param ...           Formatting arguments.
 * @error               Always throws SP_ERROR_ABORT.
 */
native void SetFailState(const char[] string, any ...);

/**
 * Aborts the current callback and throws an error.  This function
 * does not return in that no code is executed following it.
 *
 * @param fmt           String format.
 * @param ...           Format arguments.
 * @error               Always!
 */
native void ThrowError(const char[] fmt, any ...);

/**
 * Logs a stack trace from the current function call. Code
 * execution continues after the call
 *
 * @param fmt           Format string to send with the stack trace.
 * @param ...           Format arguments.
 * @error               Always logs a stack trace.
 */
native void LogStackTrace(const char[] fmt, any ...);

/**
 * Gets the system time as a unix timestamp.
 *
 * @param bigStamp      Optional array to store the 64bit timestamp in.
 * @return              32bit timestamp (number of seconds since unix epoch).
 */
native int GetTime(int bigStamp[2]={0,0});

/**
 * Produces a date and/or time string value for a timestamp.
 *
 * See this URL for valid parameters:
 * http://cplusplus.com/reference/clibrary/ctime/strftime.html
 *
 * Note that available parameters depends on support from your operating system.
 * In particular, ones highlighted in yellow on that page are not currently
 * available on Windows and should be avoided for portable plugins.
 *
 * @param buffer        Destination string buffer.
 * @param maxlength     Maximum length of output string buffer.
 * @param format        Formatting rules (passing NULL_STRING will use the rules defined in sm_datetime_format).
 * @param stamp         Optional time stamp.
 * @error               Buffer too small or invalid time format.
 */
native void FormatTime(char[] buffer, int maxlength, const char[] format, int stamp=-1);

/**
 * Loads a game config file.
 *
 * @param file          File to load.  The path must be relative to the 'gamedata' folder under the config folder
 *                      and the extension should be omitted.
 * @return              A handle to the game config file or INVALID_HANDLE on failure.
 */
native GameData LoadGameConfigFile(const char[] file);

/**
 * Returns an offset value.
 *
 * @param gc            Game config handle.
 * @param key           Key to retrieve from the offset section.
 * @return              An offset, or -1 on failure.
 */
native int GameConfGetOffset(Handle gc, const char[] key);

/**
 * Gets the value of a key from the "Keys" section.
 *
 * @param gc            Game config handle.
 * @param key           Key to retrieve from the Keys section.
 * @param buffer        Destination string buffer.
 * @param maxlen        Maximum length of output string buffer.
 * @return              True if key existed, false otherwise.
 */
native bool GameConfGetKeyValue(Handle gc, const char[] key, char[] buffer, int maxlen);

/**
 * Finds an address calculation in a GameConfig file,
 * performs LoadFromAddress on it as appropriate, then returns the final address.
 *
 * @param gameconf      Game config handle.
 * @param name          Name of the property to find.
 * @return              An address calculated on success, or 0 on failure.
 */
native Address GameConfGetAddress(Handle gameconf, const char[] name);

/**
 * Returns the operating system's "tick count," which is a number of
 * milliseconds since the operating system loaded.  This can be used
 * for basic benchmarks.
 *
 * @return              Tick count in milliseconds.
 */
native int GetSysTickCount();

/**
 * Specifies that the given config file should be executed after plugin load.
 * OnConfigsExecuted() will not be called until the config file has executed,
 * but it will be called if the execution fails.
 *
 * @param autoCreate    If true, and the config file does not exist, such a config
 *                      file will be automatically created and populated with
 *                      information from the plugin's registered cvars.
 * @param name          Name of the config file, excluding the .cfg extension.
 *                      If empty, <plugin.filename.cfg> is assumed.
 * @param folder        Folder under cfg/ to use.  By default this is "sourcemod."
 */
native void AutoExecConfig(bool autoCreate=true, const char[] name="", const char[] folder="sourcemod");

/**
 * Registers a library name for identifying as a dependency to
 * other plugins.
 *
 * @param name          Library name.
 */
native void RegPluginLibrary(const char[] name);

/**
 * Returns whether a library exists.  This function should be considered
 * expensive; it should only be called on plugin to determine availability
 * of resources.  Use OnLibraryAdded()/OnLibraryRemoved() to detect changes
 * in optional resources.
 *
 * @param name          Library name of a plugin or extension.
 * @return              True if exists, false otherwise.
 */
native bool LibraryExists(const char[] name);

/**
 * Returns the status of an extension, by filename.
 *
 * @param name          Extension name (like "sdktools.ext").
 * @param error         Optional error message buffer.
 * @param maxlength     Length of optional error message buffer.
 * @return              -2 if the extension was not found.
 *                      -1 if the extension was found but failed to load.
 *                      0 if the extension loaded but reported an error.
 *                      1 if the extension is running without error.
 */
native int GetExtensionFileStatus(const char[] name, char[] error="", int maxlength=0);

/**
 * Called after a library is added that the current plugin references
 * optionally. A library is either a plugin name or extension name, as
 * exposed via its include file.
 *
 * @param name          Library name.
 */
forward void OnLibraryAdded(const char[] name);

/**
 * Called right before a library is removed that the current plugin references
 * optionally.  A library is either a plugin name or extension name, as
 * exposed via its include file.
 *
 * @param name          Library name.
 */
forward void OnLibraryRemoved(const char[] name);

#define MAPLIST_FLAG_MAPSFOLDER    (1<<0)    /**< On failure, use all maps in the maps folder. */
#define MAPLIST_FLAG_CLEARARRAY    (1<<1)    /**< If an input array is specified, clear it before adding. */
#define MAPLIST_FLAG_NO_DEFAULT    (1<<2)    /**< Do not read "default" or "mapcyclefile" on failure. */

/**
 * Loads a map list to an ADT Array.
 *
 * A map list is a list of maps from a file.  SourceMod allows easy configuration of
 * maplists through addons/sourcemod/configs/maplists.cfg.  Each entry is given a
 * name and a file (for example, "rtv" => "rtv.cfg"), or a name and a redirection
 * (for example, "rtv" => "default").  This native will read a map list entry,
 * cache the file, and return the list of maps it holds.
 *
 * Serial change numbers are used to identify if a map list has changed.  Thus, if
 * you pass a serial change number and it's equal to what SourceMod currently knows
 * about the map list, then SourceMod won't re-parse the file.
 *
 * If the maps end up being read from the maps folder (MAPLIST_FLAG_MAPSFOLDER), they
 * are automatically sorted in alphabetical, ascending order.
 *
 * Arrays created by this function are temporary and must be freed via CloseHandle().
 * Modifying arrays created by this function will not affect future return values or
 * or the contents of arrays returned to other plugins.
 *
 * @param array         Array to store the map list.  If INVALID_HANDLE, a new blank
 *                      array will be created.  The blocksize should be at least 16;
 *                      otherwise results may be truncated.  Items are added to the array
 *                      as strings.  The array is never checked for duplicates, and it is
 *                      not read beforehand.  Only the serial number is used to detect
 *                      changes.
 * @param serial        Serial number to identify last known map list change.  If -1, the
 *                      the value will not be checked.  If the map list has since changed,
 *                      the serial is updated (even if -1 was passed).  If there is an error
 *                      finding a valid maplist, then the serial is set to -1.
 * @param str           Config name, or "default" for the default map list.  Config names
 *                      should be somewhat descriptive.  For example, the admin menu uses
 *                      a config name of "admin menu".  The list names can be configured
 *                      by users in addons/sourcemod/configs/maplists.cfg.
 * @param flags         MAPLIST_FLAG flags.
 * @return              On failure:
 *                      INVALID_HANDLE is returned, the serial is set to -1, and the input
 *                      array (if any) is left unchanged.
 *                      On no change:
 *                      INVALID_HANDLE is returned, the serial is unchanged, and the input
 *                      array (if any) is left unchanged.
 *                      On success:
 *                      A valid array Handle is returned, containing at least one map string.
 *                      If an array was passed, the return value is equal to the passed Array
 *                      Handle.  If the passed array was not cleared, it will have grown by at
 *                      least one item.  The serial number is updated to a positive number.
 * @error               Invalid array Handle that is not INVALID_HANDLE.
 */
native Handle ReadMapList(Handle array=INVALID_HANDLE,
                          int &serial=-1,
                          const char[] str="default",
                          int flags=MAPLIST_FLAG_CLEARARRAY);

/**
 * Makes a compatibility binding for map lists.  For example, if a function previously used
 * "clam.cfg" for map lists, this function will insert a "fake" binding to "clam.cfg" that
 * will be overridden if it's in the maplists.cfg file.
 *
 * @param name          Configuration name that would be used with ReadMapList().
 * @param file          Default file to use.
 */
native void SetMapListCompatBind(const char[] name, const char[] file);

/**
 * Called when a client has sent chat text.  This must return either true or
 * false to indicate that a client is or is not spamming the server.
 *
 * The return value is a hint only.  Core or another plugin may decide
 * otherwise.
 *
 * @param client        Client index.  The server (0) will never be passed.
 * @return              True if client is spamming the server, false otherwise.
 */
forward bool OnClientFloodCheck(int client);

/**
 * Called after a client's flood check has been computed.  This can be used
 * by antiflood algorithms to decay/increase flooding weights.
 *
 * Since the result from "OnClientFloodCheck" isn't guaranteed to be the
 * final result, it is generally a good idea to use this to play with other
 * algorithms nicely.
 *
 * @param client        Client index.  The server (0) will never be passed.
 * @param blocked       True if client flooded last "say", false otherwise.
 */
forward void OnClientFloodResult(int client, bool blocked);

/**
 * Feature types.
 */
enum FeatureType
{
	/**
	 * A native function call.
	 */
	FeatureType_Native,

	/**
	 * A named capability. This is distinctly different from checking for a
	 * native, because the underlying functionality could be enabled on-demand
	 * to improve loading time. Thus a native may appear to exist, but it might
	 * be part of a set of features that are not compatible with the current game
	 * or version of SourceMod.
	 */
	FeatureType_Capability
};

/**
 * Feature statuses.
 */
enum FeatureStatus
{
	/**
	 * Feature is available for use.
	 */
	FeatureStatus_Available,

	/**
	 * Feature is not available.
	 */
	FeatureStatus_Unavailable,

	/**
	 * Feature is not known at all.
	 */
	FeatureStatus_Unknown
};

/**
 * Returns whether "GetFeatureStatus" will work. Using this native
 * or this function will not cause SourceMod to fail loading on older versions,
 * however, GetFeatureStatus will only work if this function returns true.
 *
 * @return              True if GetFeatureStatus will work, false otherwise.
 */
stock bool CanTestFeatures()
{
	return LibraryExists("__CanTestFeatures__");
}

/**
 * Returns whether a feature exists, and if so, whether it is usable.
 *
 * @param type          Feature type.
 * @param name          Feature name.
 * @return              Feature status.
 */
native FeatureStatus GetFeatureStatus(FeatureType type, const char[] name);

/**
 * Requires that a given feature is available. If it is not, SetFailState()
 * is called with the given message.
 *
 * @param type          Feature type.
 * @param name          Feature name.
 * @param fmt           Message format string, or empty to use default.
 * @param ...           Message format parameters, if any.
 */
native void RequireFeature(FeatureType type, const char[] name,
                           const char[] fmt="", any ...);

/**
 * Represents how many bytes we can read from an address with one load
 */
enum NumberType
{
    NumberType_Int8,
    NumberType_Int16,
    NumberType_Int32
};

enum Address
{
    Address_Null = 0               // a typical invalid result when an address lookup fails
};

/**
 * Load up to 4 bytes from a memory address.
 *
 * @param addr          Address to a memory location.
 * @param size          How many bytes should be read.
 * @return              The value that is stored at that address.
 */
native int LoadFromAddress(Address addr, NumberType size);

/**
 * Store up to 4 bytes to a memory address.
 *
 * @param addr          Address to a memory location.
 * @param data          Value to store at the address.
 * @param size          How many bytes should be written.
 */
native void StoreToAddress(Address addr, int data, NumberType size);

methodmap FrameIterator < Handle {
	// Creates a stack frame iterator to build your own stack traces.
	// @return              New handle to a FrameIterator.
	public native FrameIterator();

	// Advances the iterator to the next stack frame.
	// @return              True if another frame was fetched and data can be successfully read.
	// @error               No next element exception.
	public native bool Next();

	// Resets the iterator back to it's starting position.
	public native void Reset();

	// Returns the line number of the current function call.
	property int LineNumber {
		public native get();
	}

	// Gets the name of the current function in the call stack.
	//
	// @param buffer Buffer to copy to.
	// @param maxlen Max size of the buffer.
	public native void GetFunctionName(char[] buffer, int maxlen);

	// Gets the file path to the current call in the call stack.
	//
	// @param buffer Buffer to copy to.
	// @param maxlen Max size of the buffer.
	public native void GetFilePath(char[] buffer, int maxlen);
}

#include <helpers>
#include <entity>
#include <entity_prop_stocks>
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */
 
#if defined _adt_included
 #endinput
#endif
#define _adt_included

#include <adt_array>
#include <adt_trie>
#include <adt_stack>
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2009-2013 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 */

#if defined _sdkhooks_included
 #endinput
#endif
#define _sdkhooks_included

// this is obviously _not_ a robust check, but it will solve most conflict and is clean
#if !defined DMG_GENERIC
#define DMG_GENERIC                  0          /**< generic damage was done */
#define DMG_CRUSH                   (1 << 0)    /**< crushed by falling or moving object.
                                                     NOTE: It's assumed crush damage is occurring as a result of physics collision,
                                                     so no extra physics force is generated by crush damage.
                                                     DON'T use DMG_CRUSH when damaging entities unless it's the result of a physics
                                                     collision. You probably want DMG_CLUB instead. */
#define DMG_BULLET                  (1 << 1)    /**< shot */
#define DMG_SLASH                   (1 << 2)    /**< cut, clawed, stabbed */
#define DMG_BURN                    (1 << 3)    /**< heat burned */
#define DMG_VEHICLE                 (1 << 4)    /**< hit by a vehicle */
#define DMG_FALL                    (1 << 5)    /**< fell too far */
#define DMG_BLAST                   (1 << 6)    /**< explosive blast damage */
#define DMG_CLUB                    (1 << 7)    /**< crowbar, punch, headbutt */
#define DMG_SHOCK                   (1 << 8)    /**< electric shock */
#define DMG_SONIC                   (1 << 9)    /**< sound pulse shockwave */
#define DMG_ENERGYBEAM              (1 << 10)   /**< laser or other high energy beam  */
#define DMG_PREVENT_PHYSICS_FORCE   (1 << 11)   /**< Prevent a physics force  */
#define DMG_NEVERGIB                (1 << 12)   /**< with this bit OR'd in, no damage type will be able to gib victims upon death */
#define DMG_ALWAYSGIB               (1 << 13)   /**< with this bit OR'd in, any damage type can be made to gib victims upon death. */
#define DMG_DROWN                   (1 << 14)   /**< Drowning */
#define DMG_PARALYZE                (1 << 15)   /**< slows affected creature down */
#define DMG_NERVEGAS                (1 << 16)   /**< nerve toxins, very bad */
#define DMG_POISON                  (1 << 17)   /**< blood poisoning - heals over time like drowning damage */
#define DMG_RADIATION               (1 << 18)   /**< radiation exposure */
#define DMG_DROWNRECOVER            (1 << 19)   /**< drowning recovery */
#define DMG_ACID                    (1 << 20)   /**< toxic chemicals or acid burns */
#define DMG_SLOWBURN                (1 << 21)   /**< in an oven */
#define DMG_REMOVENORAGDOLL         (1 << 22)   /**< with this bit OR'd in, no ragdoll will be created, and the target will be quietly removed.
                                                     use this to kill an entity that you've already got a server-side ragdoll for */
#define DMG_PHYSGUN                 (1 << 23)   /**< Hit by manipulator. Usually doesn't do any damage. */
#define DMG_PLASMA                  (1 << 24)   /**< Shot by Cremator */
#define DMG_AIRBOAT                 (1 << 25)   /**< Hit by the airboat's gun */
#define DMG_DISSOLVE                (1 << 26)   /**< Dissolving! */
#define DMG_BLAST_SURFACE           (1 << 27)   /**< A blast on the surface of water that cannot harm things underwater */
#define DMG_DIRECT                  (1 << 28)
#define DMG_BUCKSHOT                (1 << 29)   /**< not quite a bullet. Little, rounder, different. */
#endif

#if !defined DMG_CRIT
	#define DMG_CRIT                DMG_ACID        /**< TF2 crits and minicrits */
#endif

#if !defined DMG_RADIUS_MAX
	#define DMG_RADIUS_MAX          DMG_ENERGYBEAM  /**< No damage falloff */
#endif

#if !defined DMG_NOCLOSEDISTANCEMOD
	#define DMG_NOCLOSEDISTANCEMOD  DMG_POISON      /**< Don't do damage falloff too close */
#endif

#if !defined DMG_HALF_FALLOFF
	#define DMG_HALF_FALLOFF        DMG_RADIATION   /**< 50% damage falloff */
#endif

#if !defined DMG_USEDISTANCEMOD
	#define DMG_USEDISTANCEMOD      DMG_SLOWBURN    /**< Do damage falloff */
#endif

#if !defined DMG_IGNITE
	#define DMG_IGNITE              DMG_PLASMA      /**< Ignite victim */
#endif

#if !defined DMG_USE_HITLOCATIONS
	#define DMG_USE_HITLOCATIONS    DMG_AIRBOAT     /**< Do hit location damage (Like the sniperrifle and ambassador) */
#endif

enum SDKHookType
{
	SDKHook_EndTouch,
	SDKHook_FireBulletsPost,
	SDKHook_OnTakeDamage,
	SDKHook_OnTakeDamagePost,
	SDKHook_PreThink,
	SDKHook_PostThink,
	SDKHook_SetTransmit,
	SDKHook_Spawn,
	SDKHook_StartTouch,
	SDKHook_Think,
	SDKHook_Touch,
	SDKHook_TraceAttack,
	SDKHook_TraceAttackPost,
	SDKHook_WeaponCanSwitchTo,
	SDKHook_WeaponCanUse,
	SDKHook_WeaponDrop,
	SDKHook_WeaponEquip,
	SDKHook_WeaponSwitch,
	SDKHook_ShouldCollide,
	SDKHook_PreThinkPost,
	SDKHook_PostThinkPost,
	SDKHook_ThinkPost,
	SDKHook_EndTouchPost,
	SDKHook_GroundEntChangedPost,
	SDKHook_SpawnPost,
	SDKHook_StartTouchPost,
	SDKHook_TouchPost,
	SDKHook_VPhysicsUpdate,
	SDKHook_VPhysicsUpdatePost,
	SDKHook_WeaponCanSwitchToPost,
	SDKHook_WeaponCanUsePost,
	SDKHook_WeaponDropPost,
	SDKHook_WeaponEquipPost,
	SDKHook_WeaponSwitchPost,
	SDKHook_Use,
	SDKHook_UsePost,
	SDKHook_Reload,
	SDKHook_ReloadPost,
	SDKHook_GetMaxHealth,  /**< ep2v and later */
	SDKHook_Blocked,
	SDKHook_BlockedPost,
	SDKHook_OnTakeDamageAlive,
	SDKHook_OnTakeDamageAlivePost,
	SDKHook_CanBeAutobalanced
};

/*
	Alphabetized for easy readability

	SDKHook_Blocked,
	SDKHook_BlockedPost,

	SDKHook_CanBeAutobalanced,

	SDKHook_EndTouch,
	SDKHook_EndTouchPost,

	SDKHook_FireBulletsPost,

	SDKHook_GetMaxHealth,  (ep2v and later)

	SDKHook_GroundEntChangedPost,

	SDKHook_OnTakeDamage,
	SDKHook_OnTakeDamagePost,

	SDKHook_OnTakeDamageAlive,
	SDKHook_OnTakeDamageAlivePost,

	SDKHook_PreThink,
	SDKHook_PreThinkPost,

	SDKHook_PostThink,
	SDKHook_PostThinkPost,

	SDKHook_Reload,
	SDKHook_ReloadPost,

	SDKHook_SetTransmit,

	SDKHook_ShouldCollide,

	SDKHook_Spawn,
	SDKHook_SpawnPost,

	SDKHook_StartTouch,
	SDKHook_StartTouchPost,

	SDKHook_Think,
	SDKHook_ThinkPost,

	SDKHook_Touch,
	SDKHook_TouchPost,

	SDKHook_TraceAttack,
	SDKHook_TraceAttackPost,

	SDKHook_Use,
	SDKHook_UsePost,

	SDKHook_VPhysicsUpdate,
	SDKHook_VPhysicsUpdatePost,

	SDKHook_WeaponCanSwitchTo,
	SDKHook_WeaponCanSwitchToPost,

	SDKHook_WeaponCanUse,
	SDKHook_WeaponCanUsePost,

	SDKHook_WeaponDrop,
	SDKHook_WeaponDropPost,

	SDKHook_WeaponEquip,
	SDKHook_WeaponEquipPost,

	SDKHook_WeaponSwitch,
	SDKHook_WeaponSwitchPost
*/

enum UseType
{
	Use_Off,
	Use_On,
	Use_Set,
	Use_Toggle
};

typeset SDKHookCB
{
	// PreThink/Post
	// PostThink/Post
	function void (int client);

	// Spawn
	function Action (int entity);

	// GroundEntChanged
	// SpawnPost
	// Think/Post
	// VPhysicsUpdate/Post
	function void (int entity);

	// EndTouch
	// StartTouch
	// Touch
	// Blocked
	function Action (int entity, int other);

	// EndTouchPost
	// StartTouchPost
	// TouchPost
	function void (int entity, int other);

	// SetTransmit
	function Action (int entity, int client);

	// WeaponCanSwitchTo
	// WeaponCanUse
	// WeaponDrop
	// WeaponEquip
	// WeaponSwitch
	function Action (int client, int weapon);

	// WeaponCanSwitchToPost
	// WeaponCanUsePost
	// WeaponDropPost
	// WeaponEquipPost
	// WeaponSwitchPost
	function void (int client, int weapon);

	// GetMaxHealth (ep2v and later)
	function Action (int entity, int &maxhealth);

	// OnTakeDamage
	// OnTakeDamageAlive
	// SDKHooks 1.0+
	function Action (int victim, int &attacker, int &inflictor, float &damage, int &damagetype);

	// OnTakeDamage
	// OnTakeDamageAlive
	// Note: The weapon parameter is not used by all games and damage sources.
	// Note: Force application is dependent on game and damage type(s)
	// SDKHooks 2.0+
	function Action (int victim, int &attacker, int &inflictor, float &damage, int &damagetype, int &weapon, float damageForce[3], float damagePosition[3]);

	// OnTakeDamage
	// OnTakeDamageAlive
	// Note: The weapon parameter is not used by all games and damage sources.
	// Note: Force application is dependent on game and damage type(s)
	// SDKHooks 2.1+  (can check for support at runtime using GetFeatureStatus on SDKHook_DmgCustomInOTD capability.
	// DON'T attempt to access 'damagecustom' var if feature status != available
	function Action (int victim, int &attacker, int &inflictor, float &damage, int &damagetype, int &weapon,
		float damageForce[3], float damagePosition[3], int damagecustom);

	// OnTakeDamagePost
	// OnTakeDamageAlivePost
	function void (int victim, int attacker, int inflictor, float damage, int damagetype);

	// OnTakeDamagePost
	// OnTakeDamageAlivePost
	function void (int victim, int attacker, int inflictor, float damage, int damagetype, int weapon, const float damageForce[3], const float damagePosition[3]);

	// OnTakeDamagePost
	// OnTakeDamageAlivePost
	function void (int victim, int attacker, int inflictor, float damage, int damagetype, int weapon,
		const float damageForce[3], const float damagePosition[3], int damagecustom);

	// FireBulletsPost
	function void (int client, int shots, const char[] weaponname);

	// TraceAttack
	function Action (int victim, int &attacker, int &inflictor, float &damage, int &damagetype, int &ammotype, int hitbox, int hitgroup);

	// TraceAttackPost
	function void (int victim, int attacker, int inflictor, float damage, int damagetype, int ammotype, int hitbox, int hitgroup);

	// ShouldCollide
	function bool (int entity, int collisiongroup, int contentsmask, bool originalResult);

	// Use
	function Action (int entity, int activator, int caller, UseType type, float value);

	// UsePost
	function void (int entity, int activator, int caller, UseType type, float value);

	// Reload
	function Action (int weapon);

	// Reload post
	function void (int weapon, bool bSuccessful);

	// CanBeAutobalanced
	function bool (int client, bool origRet);
};


/**
 * When an entity is created
 *
 * @param entity        Entity index
 * @param classname     Class name
 */
forward void OnEntityCreated(int entity, const char[] classname);

/**
 * When an entity is destroyed
 *
 * @param entity        Entity index
 */
forward void OnEntityDestroyed(int entity);

/**
 * When the game description is retrieved
 *
 * @note Not supported on ep2v.
 *
 * @param gameDesc      Game description
 * @return              Plugin_Changed if gameDesc has been edited, else no change.
 */
forward Action OnGetGameDescription(char gameDesc[64]);

/**
 * When the level is initialized
 *
 * @param mapName       Name of the map
 * @param mapEntities   Entities of the map
 * @return              Plugin_Changed if mapEntities has been edited, else no change.
 */
forward Action OnLevelInit(const char[] mapName, char mapEntities[2097152]);

/**
 * Hooks an entity
 *
 * @param entity        Entity index
 * @param type          Type of function to hook
 * @param callback      Function to call when hook is called
 */
native void SDKHook(int entity, SDKHookType type, SDKHookCB callback);

/**
 * Hooks an entity
 *
 * @param entity        Entity index
 * @param type          Type of function to hook
 * @param callback      Function to call when hook is called
 * @return              Hook Successful
 */
native bool SDKHookEx(int entity, SDKHookType type, SDKHookCB callback);

/**
 * Unhooks an entity
 *
 * @param entity   Entity index
 * @param type     Type of function to unhook
 * @param callback Callback function to unhook
 */
native void SDKUnhook(int entity, SDKHookType type, SDKHookCB callback);

/**
 * Applies damage to an entity
 *
 * @note Force application is dependent on game and damage type(s)
 *
 * @param entity         Entity index taking damage
 * @param inflictor      Inflictor entity index
 * @param attacker       Attacker entity index
 * @param damage         Amount of damage
 * @param damageType     Bitfield of damage types
 * @param weapon         Weapon index (orangebox and later) or -1 for unspecified
 * @param damageForce    Velocity of damage force
 * @param damagePosition Origin of damage
 */
native void SDKHooks_TakeDamage(int entity, int inflictor, int attacker,
		float damage, int damageType=DMG_GENERIC, int weapon=-1,
		const float damageForce[3]=NULL_VECTOR, const float damagePosition[3]=NULL_VECTOR);

/**
 * Forces a client to drop the specified weapon
 *
 * @param client        Client index.
 * @param weapon        Weapon entity index.
 * @param vecTarget     Location to toss weapon to, or NULL_VECTOR for default.
 * @param vecVelocity   Velocity at which to toss weapon, or NULL_VECTOR for default.
 * @error               Invalid client or weapon entity, weapon not owned by client.
 */
native void SDKHooks_DropWeapon(int client, int weapon, const float vecTarget[3]=NULL_VECTOR,
		const float vecVelocity[3]=NULL_VECTOR);

/**
 * Do not edit below this line!
 */
public Extension __ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
#if defined AUTOLOAD_EXTENSIONS
	autoload = 1,
#else
	autoload = 0,
#endif
#if defined REQUIRE_EXTENSIONS
	required = 1,
#else
	required = 0,
#endif
};
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */
 
#if defined _string_included
 #endinput
#endif
#define _string_included

/**
 * @global Unless otherwise noted, all string functions which take in a 
 * writable buffer and maximum length should have the null terminator INCLUDED
 * in the length.  This means that this is valid: 
 * strcopy(string, sizeof(string), ...)
 */
 
/**
 * Calculates the length of a string.
 *
 * @param str           String to check.
 * @return              Number of valid character bytes in the string.
 */
native int strlen(const char[] str);

/**
 * Tests whether a string is found inside another string.
 *
 * @param str           String to search in.
 * @param substr        Substring to find inside the original string.
 * @param caseSensitive If true (default), search is case sensitive.
 *                      If false, search is case insensitive.
 * @return              -1 on failure (no match found). Any other value
 *                      indicates a position in the string where the match starts.
 */
native int StrContains(const char[] str, const char[] substr, bool caseSensitive=true);

/**
 * Compares two strings lexographically.
 *
 * @param str1          First string (left).
 * @param str2          Second string (right).
 * @param caseSensitive If true (default), comparison is case sensitive.
 *                      If false, comparison is case insensitive.
 * @return              -1 if str1 < str2
 *                      0 if str1 == str2
 *                      1 if str1 > str2
 */
native int strcmp(const char[] str1, const char[] str2, bool caseSensitive=true);

/**
 * Compares two strings parts lexographically.
 *
 * @param str1          First string (left).
 * @param str2          Second string (right).
 * @param num           Number of characters to compare.
 * @param caseSensitive If true (default), comparison is case sensitive.
 *                      If false, comparison is case insensitive.
 * @return              -1 if str1 < str2
 *                      0 if str1 == str2
 *                      1 if str1 > str2
 */
native int strncmp(const char[] str1, const char[] str2, int num, bool caseSensitive=true);

/**
 * Backwards compatible stock - StrCompare is now strcmp
 * @deprecated          Renamed to strcmp
 */
#pragma deprecated Use strcmp() instead
stock int StrCompare(const char[] str1, const char[] str2, bool caseSensitive=true)
{
	return strcmp(str1, str2, caseSensitive);
}

/**
 * Returns whether two strings are equal.
 *
 * @param str1          First string (left).
 * @param str2          Second string (right).
 * @param caseSensitive If true (default), comparison is case sensitive.
 *                      If false, comparison is case insensitive.
 * @return              True if equal, false otherwise.
 */
stock bool StrEqual(const char[] str1, const char[] str2, bool caseSensitive=true)
{
	return (strcmp(str1, str2, caseSensitive) == 0);
}

/**
 * Copies one string to another string.
 * @note If the destination buffer is too small to hold the source string, the 
 *       destination will be truncated.
 *
 * @param dest          Destination string buffer to copy to.
 * @param destLen       Destination buffer length (includes null terminator).
 * @param source        Source string buffer to copy from.
 * @return              Number of cells written.
 */
native int strcopy(char[] dest, int destLen, const char[] source);

/**
 * Backwards compatibility stock - use strcopy
 * @deprecated          Renamed to strcopy
 */
#pragma deprecated Use strcopy() instead
stock int StrCopy(char[] dest, int destLen, const char[] source)
{
	return strcopy(dest, destLen, source);
}

/**
 * Formats a string according to the SourceMod format rules (see documentation).
 *
 * @param buffer        Destination string buffer.
 * @param maxlength     Maximum length of output string buffer.
 * @param format        Formatting rules.
 * @param ...           Variable number of format parameters.
 * @return              Number of cells written.
 */
native int Format(char[] buffer, int maxlength, const char[] format, any ...);

/**
 * Formats a string according to the SourceMod format rules (see documentation).
 * @note This is the same as Format(), except none of the input buffers can 
 *       overlap the same memory as the output buffer.  Since this security 
 *       check is removed, it is slightly faster.
 *
 * @param buffer        Destination string buffer.
 * @param maxlength     Maximum length of output string buffer.
 * @param format        Formatting rules.
 * @param ...           Variable number of format parameters.
 * @return              Number of cells written.
 */
native int FormatEx(char[] buffer, int maxlength, const char[] format, any ...);

/**
 * Formats a string according to the SourceMod format rules (see documentation).
 * @note This is the same as Format(), except it grabs parameters from a 
 *       parent parameter stack, rather than a local.  This is useful for 
 *       implementing your own variable argument functions.
 *
 * @param buffer        Destination string buffer.
 * @param maxlength     Maximum length of output string buffer.
 * @param format        Formatting rules.
 * @param varpos        Argument number which contains the '...' symbol.
 *                      Note: Arguments start at 1.
 * @return              Number of bytes written.
 */
native int VFormat(char[] buffer, int maxlength, const char[] format, int varpos);

/**
 * Converts a string to an integer.
 *
 * @param str           String to convert.
 * @param nBase         Numerical base to use.  10 is default.
 * @return              Integer conversion of string, or 0 on failure.
 */
native int StringToInt(const char[] str, int nBase=10);

/**
 * Converts a string to an integer with some more options.
 *
 * @param str           String to convert.
 * @param result        Variable to store the result in.
 * @param nBase         Numerical base to use.  10 is default.
 * @return              Number of characters consumed.
 */
native int StringToIntEx(const char[] str, int &result, int nBase=10);

/**
 * Converts an integer to a string.
 *
 * @param num           Integer to convert.
 * @param str           Buffer to store string in.
 * @param maxlength     Maximum length of string buffer.
 * @return              Number of cells written to buffer.
 */
native int IntToString(int num, char[] str, int maxlength);

/** 
 * Converts a string to a floating point number.
 *
 * @param str           String to convert to a float.
 * @return              Floating point result, or 0.0 on error.
 */
native float StringToFloat(const char[] str);

/** 
 * Converts a string to a floating point number with some more options.
 *
 * @param str           String to convert to a float.
 * @param result        Variable to store result in.
 * @return              Number of characters consumed.
 */
native int StringToFloatEx(const char[] str, float &result);

/**
 * Converts a floating point number to a string.
 *
 * @param num           Floating point number to convert.
 * @param str           Buffer to store string in.
 * @param maxlength     Maximum length of string buffer.
 * @return              Number of cells written to buffer.
 */
native int FloatToString(float num, char[] str, int maxlength);

/**
 * Finds the first "argument" in a string; either a set of space
 * terminated characters, or a fully quoted string.  After the 
 * argument is found, whitespace is read until the next portion
 * of the string is reached.  If nothing remains, -1 is returned.
 * Otherwise, the index to the first character is returned.
 *
 * @param source        Source input string.
 * @param arg           Stores argument read from string.
 * @param argLen        Maximum length of argument buffer.
 * @return              Index to next piece of string, or -1 if none.
 */
native int BreakString(const char[] source, char[] arg, int argLen);

/**
 * Backwards compatibility stock - use BreakString
 * @deprecated          Renamed to BreakString.
 */
#pragma deprecated Use BreakString() instead
stock int StrBreak(const char[] source, char[] arg, int argLen)
{
	return BreakString(source, arg, argLen);
}

/**
 * Removes whitespace characters from the beginning and end of a string.
 *
 * @param str           The string to trim.
 * @return              Number of bytes written (UTF-8 safe).
 */
native int TrimString(char[] str);

/**
 * Returns text in a string up until a certain character sequence is reached.
 *
 * @param source        Source input string.
 * @param split         A string which specifies a search point to break at.
 * @param part          Buffer to store string part.
 * @param partLen       Maximum length of the string part buffer.
 * @return              -1 if no match was found; otherwise, an index into source
 *                      marking the first index after the searched text.  The
 *                      index is always relative to the start of the input string.
 */
native int SplitString(const char[] source, const char[] split, char[] part, int partLen);

/**
 * Given a string, replaces all occurrences of a search string with a 
 * replacement string.
 *
 * @param text          String to perform search and replacements on.
 * @param maxlength     Maximum length of the string buffer.
 * @param search        String to search for.
 * @param replace       String to replace the search string with.
 * @param caseSensitive If true (default), search is case sensitive.
 * @return              Number of replacements that were performed.
 */
native int ReplaceString(char[] text, int maxlength, const char[] search, const char[] replace, bool caseSensitive=true);

/**
 * Given a string, replaces the first occurrence of a search string with a 
 * replacement string.
 *
 * @param text          String to perform search and replacements on.
 * @param maxlength     Maximum length of the string buffer.
 * @param search        String to search for.
 * @param replace       String to replace the search string with.
 * @param searchLen     If higher than -1, its value will be used instead of
 *                      a strlen() call on the search parameter.
 * @param replaceLen    If higher than -1, its value will be used instead of
 *                      a strlen() call on the replace parameter.
 * @param caseSensitive If true (default), search is case sensitive.
 * @return              Index into the buffer (relative to the start) from where
 *                      the last replacement ended, or -1 if no replacements were
 *                      made.
 */
native int ReplaceStringEx(char[] text, int maxlength, const char[] search, const char[] replace, int searchLen=-1, int replaceLen=-1, bool caseSensitive=true);

/** 
 * Returns the number of bytes a character is using.  This is
 * for multi-byte characters (UTF-8).  For normal ASCII characters,
 * this will return 1.
 *
 * @param source        Source input string.
 * @return              Number of bytes the current character uses.
 */
native int GetCharBytes(const char[] source);

/**
 * Returns whether a character is an ASCII alphabet character.
 *
 * @note Multi-byte characters will always return false.
 *
 * @param chr           Character to test.
 * @return              True if character is alphabetical, otherwise false.
 */
native bool IsCharAlpha(int chr);

/**
 * Returns whether a character is numeric.
 *
 * @note Multi-byte characters will always return false.
 *
 * @param chr           Character to test.
 * @return              True if character is numeric, otherwise false.
 */
native bool IsCharNumeric(int chr);

/**
 * Returns whether a character is whitespace.
 *
 * @note Multi-byte characters will always return false.
 *
 * @param chr           Character to test.
 * @return              True if character is whitespace, otherwise false.
 */
native bool IsCharSpace(int chr);

/**
 * Returns if a character is multi-byte or not.
 *
 * @param chr           Character to test.
 * @return              0 for a normal 7-bit ASCII character,
 *                      otherwise number of bytes in multi-byte character.
 */
native int IsCharMB(int chr);

/**
 * Returns whether an alphabetic character is uppercase.
 *
 * @note Multi-byte characters will always return false.
 *
 * @param chr           Character to test.
 * @return              True if character is uppercase, otherwise false.
 */
native bool IsCharUpper(int chr);

/**
 * Returns whether an alphabetic character is lowercase.
 *
 * @note Multi-byte characters will always return false.
 *
 * @param chr           Character to test.
 * @return              True if character is lowercase, otherwise false.
 */
native bool IsCharLower(int chr);

/**
 * Strips a quote pair off a string if it exists.  That is, the following 
 * replace rule is applied once:  ^"(.*)"$ -> ^\1$
 *
 * Note that the leading and trailing quotes will only be removed if both 
 * exist.  Otherwise, the string is left unmodified.  This function should 
 * be considered O(k) (all characters get shifted down).
 *
 * @param text          String to modify (in place).
 * @return              True if string was modified, false if there was no 
 *                      set of quotes.
 */
native bool StripQuotes(char[] text);

/**
 * Converts a lowercase character to its uppercase counterpart.
 *
 * @param chr           Character to convert.
 * @return              Uppercase character on success, 
 *                      no change on failure.
 */
stock int CharToUpper(int chr)
{
	if (IsCharLower(chr))
	{
		return (chr & ~(1<<5));
	}

	return chr;
}

/**
 * Converts an uppercase character to its lowercase counterpart.
 *
 * @param chr           Character to convert.
 * @return              Lowercase character on success, 
 *                      no change on failure.
 */
stock int CharToLower(int chr)
{
	if (IsCharUpper(chr))
	{
		return (chr | (1<<5));
	}
	
	return chr;
}

/**
 * Finds the first occurrence of a character in a string.
 *
 * @param str           String.
 * @param c             Character to search for.
 * @param reverse       False (default) to search forward, true to search 
 *                      backward.
 * @return              The index of the first occurrence of the character 
 *                      in the string, or -1 if the character was not found.
 */
stock int FindCharInString(const char[] str, char c, bool reverse = false)
{
	int len = strlen(str);
	
	if (!reverse)
	{
		for (int i = 0; i < len; i++)
		{
			if (str[i] == c)
			{
				return i;
			}
		}
	}
	else
	{
		for (int i = len - 1; i >= 0; i--)
		{
			if (str[i] == c)
			{
				return i;
			}
		}
	}

	return -1;
}

/**
 * Concatenates one string onto another.
 *
 * @param buffer        String to append to.
 * @param maxlength     Maximum length of entire buffer.
 * @param source        Source string to concatenate.
 * @return              Number of bytes written.
 */
stock int StrCat(char[] buffer, int maxlength, const char[] source)
{
	int len = strlen(buffer);
	if (len >= maxlength)
	{
		return 0;
	}
	
	return Format(buffer[len], maxlength-len, "%s", source);
}

/**
 * Breaks a string into pieces and stores each piece into an array of buffers.
 *
 * @param text              The string to split.
 * @param split             The string to use as a split delimiter.
 * @param buffers           An array of string buffers (2D array).
 * @param maxStrings        Number of string buffers (first dimension size).
 * @param maxStringLength   Maximum length of each string buffer.
 * @param copyRemainder     False (default) discard excess pieces, true to ignore
 *                          delimiters after last piece.
 * @return                  Number of strings retrieved.
 */
stock int ExplodeString(const char[] text, const char[] split, char[][] buffers, int maxStrings,
                    int maxStringLength, bool copyRemainder = false)
{
	int reloc_idx, idx, total;

	if (maxStrings < 1 || !split[0])
	{
		return 0;
	}

	while ((idx = SplitString(text[reloc_idx], split, buffers[total], maxStringLength)) != -1)
	{
		reloc_idx += idx;
		if (++total == maxStrings)
		{
			if (copyRemainder)
			{
				strcopy(buffers[total-1], maxStringLength, text[reloc_idx-idx]);
			}
			return total;
		}
	}

	strcopy(buffers[total++], maxStringLength, text[reloc_idx]);

	return total;
}

/**
 * Joins an array of strings into one string, with a "join" string inserted in
 * between each given string.  This function complements ExplodeString.
 *
 * @param strings       An array of strings.
 * @param numStrings    Number of strings in the array.
 * @param join          The join string to insert between each string.
 * @param buffer        Output buffer to write the joined string to.
 * @param maxLength     Maximum length of the output buffer.
 * @return              Number of bytes written to the output buffer.
 */
stock int ImplodeStrings(const char[][] strings, int numStrings, const char[] join, char[] buffer, int maxLength)
{
	int total, length, part_length;
	int join_length = strlen(join);
	for (int i=0; i<numStrings; i++)
	{
		length = strcopy(buffer[total], maxLength-total, strings[i]);
		total += length;
		if (length < part_length)
		{
			break;
		}
		if (i != numStrings - 1)
		{
			length = strcopy(buffer[total], maxLength-total, join);
			total += length;
			if (length < join_length)
			{
				break;
			}
		}
	}
	return total;
}
/**
 * vim: set ts=4 sw=4 tw=99 noet:
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _topmenus_included
 #endinput
#endif
#define _topmenus_included

#include <menus>

/**
 * Actions a top menu will take on an topobj.
 */
enum TopMenuAction
{
	/**
	 * An option is being drawn for a menu (or for sorting purposes).
	 *
	 * INPUT : TopMenu Handle, topobj ID, client index.
	 * OUTPUT: Buffer for rendering, maxlength of buffer.
	 */
	TopMenuAction_DisplayOption = 0,

	/**
	 * The title of a menu is being drawn for a given topobj.
	 *
	 * Note: The Object ID will be INVALID_TOPMENUOBJECT if drawing the
	 * root title.  Otherwise, the Object ID is a category.
	 *
	 * INPUT : TopMenu Handle, topobj ID, client index.
	 * OUTPUT: Buffer for rendering, maxlength of buffer.
	 */
	TopMenuAction_DisplayTitle = 1,

	/**
	 * A menu option has been selected.
	 *
	 * The Object ID will always be an item (not a category).
	 *
	 * INPUT : TopMenu Handle, topobj ID, client index.
	 */
	TopMenuAction_SelectOption = 2,

	/**
	 * A menu option is being drawn and its flags can be overridden.
	 *
	 * INPUT : TopMenu Handle, topobj ID, client index.
	 * OUTPUT: The first byte of the 'buffer' string should be set
	 *                      to the desired flags.  By default, it will contain
	 *                      ITEMDRAW_DEFAULT.
	 */
	 TopMenuAction_DrawOption = 3,

	/**
	 * Called when an topobj is being removed from the menu.
	 * This can be used to clean up data stored in the info string.
	 *
	 * INPUT : TopMenu Handle, topobj ID.
	 */
	 TopMenuAction_RemoveObject = 4
};

/**
 * Top menu topobj types.
 */
enum TopMenuObjectType
{
	TopMenuObject_Category = 0,         /**< Category (sub-menu branching from root) */
	TopMenuObject_Item = 1              /**< Item on a sub-menu */
};

/**
 * Top menu starting positions for display.
 */
enum TopMenuPosition
{
	TopMenuPosition_Start = 0,          /**< Start/root of the menu */
	TopMenuPosition_LastRoot = 1,       /**< Last position in the root menu */
	TopMenuPosition_LastCategory = 3    /**< Last position in their last category */
};

/**
 * Top menu topobj tag for type checking.
 */
enum TopMenuObject
{
	INVALID_TOPMENUOBJECT = 0
};

/**
 * TopMenu callback prototype.
 *
 * @param topmenu       Handle to the TopMenu.
 * @param action        TopMenuAction being performed.
 * @param topobj_id     The topobj ID (if used).
 * @param param         Extra parameter (if used).
 * @param buffer        Output buffer (if used).
 * @param maxlength     Output buffer (if used).
 */
typedef TopMenuHandler = function void (
  TopMenu topmenu,
  TopMenuAction action,
  TopMenuObject topobj_id,
  int param,
  char[] buffer,
  int maxlength
);

// TopMenu objects are used for constructing multi-layer menus. Currently, they
// support at most two levels. The first level of items are called "categories".
methodmap TopMenu < Handle
{
	// Creates a new TopMenu.
	//
	// @param handler       Handler to use for drawing the root title.
	// @return              A new TopMenu.
	public native TopMenu(TopMenuHandler handler);

	// Returns a TopMenu handle from a generic handle. If the given handle is
	// a TopMenu, the handle is simply casted back. Otherwise, an error is
	// raised.
	public static native TopMenu FromHandle(Handle handle);

	// Re-sorts the items in a TopMenu via a configuration file.
	//
	// The format of the configuration file should be a Valve Key-Values
	// formatted file that SourceMod can parse.  There should be one root
	// section, and one sub-section for each category.  Each sub-section's
	// name should match the category name.
	//
	// Each sub-section may only contain key/value pairs in the form of:
	// key: "item"
	// value: Name of the item as passed to AddToTopMenu().
	//
	// The TopMenu will draw items in the order declared in the configuration
	// file.  If items do not appear in the configuration file, they are sorted
	// per-player based on how the handler function renders for that player.
	// These items appear after the configuration sorted items.
	//
	// @param topmenu      TopMenu Handle.
	// @param file         File path.
	// @param error        Error buffer.
	// @param maxlength    Maximum size of the error buffer. Error buffer
	//                     will be filled with a zero-terminated string if
	//                     false is returned.
	// @return              True on success, false on failure.
	public native bool LoadConfig(const char[] file, char[] error, int maxlength);

	// Adds a category to a TopMenu.
	//
	// @param name         Object name (MUST be unique).
	// @param handler      Handler for topobj.
	// @param cmdname      Command name (for access overrides).
	// @param flags        Default access flags.
	// @param info_string  Arbitrary storage (max 255 bytes).
	// @return              A new TopMenuObject ID, or INVALID_TOPMENUOBJECT on failure.
	public native TopMenuObject AddCategory(const char[] name, TopMenuHandler handler,
	                                        const char[] cmdname = "", int flags = 0,
	                                        const char[] info_string = "");

	// Adds an item to a TopMenu category.
	//
	// @param name         Object name (MUST be unique).
	// @param handler      Handler for topobj.
	// @param category     The object of the parent category for the item.
	// @param cmdname      Command name (for access overrides).
	// @param flags        Default access flags.
	// @param info_string  Arbitrary storage (max 255 bytes).
	// @return              A new TopMenuObject ID, or INVALID_TOPMENUOBJECT on failure.
	public native TopMenuObject AddItem(const char[] name, TopMenuHandler handler,
	                                    TopMenuObject parent, const char[] cmdname = "",
	                                    int flags = 0, const char[] info_string = "");

	// Retrieves the info string of a top menu item.
	//
	// @param parent       TopMenuObject ID.
	// @param buffer       Buffer to store info string.
	// @param maxlength    Maximum size of info string.
	// @return              Number of bytes written, not including the  null terminator.
	public native int GetInfoString(TopMenuObject parent, char[] buffer, int maxlength);

	// Retrieves the name string of a top menu item.
	//
	// @param topobj       TopMenuObject ID.
	// @param buffer       Buffer to store info string.
	// @param maxlength    Maximum size of info string.
	// @return              Number of bytes written, not including the null terminator.
	public native int GetObjName(TopMenuObject topobj, char[] buffer, int maxlength);

	// Removes an topobj from a TopMenu.
	//
	// Plugins' topobjs are automatically removed all TopMenus when the given
	// plugin unloads or pauses.  In the case of unpausing, all items are restored.
	//
	// @param topobj       TopMenuObject ID.
	public native void Remove(TopMenuObject topobj);

	// Displays a TopMenu to a client.
	//
	// @param client       Client index.
	// @param position     Position to display from.
	// @return              True on success, false on failure.
	public native bool Display(int client, TopMenuPosition position);

	// Displays a TopMenu category to a client.
	//
	// @param category     Category topobj id.
	// @param client       Client index.
	// @return              True on success, false on failure.
	public native bool DisplayCategory(TopMenuObject category, int client);

	// Finds a category's topobj ID in a TopMenu.
	//
	// @param name         Object's unique name.
	// @return              TopMenuObject ID on success, or
	//                     INVALID_TOPMENUOBJECT on failure.
	public native TopMenuObject FindCategory(const char[] name);

	// Set the menu title caching behavior of the TopMenu. By default titles
	// are cached to reduce overhead. If you need dynamic menu titles which
	// change each time the menu is displayed to a user, set this to false.
	property bool CacheTitles {
		public native set(bool value);
	}
};

/**
 * Creates a TopMenu.
 *
 * @param handler       Handler to use for drawing the root title.
 * @return              A new TopMenu Handle, or INVALID_HANDLE on failure.
 */
native TopMenu CreateTopMenu(TopMenuHandler handler);

/**
 * Re-sorts the items in a TopMenu via a configuration file.
 *
 * The format of the configuration file should be a Valve Key-Values
 * formatted file that SourceMod can parse.  There should be one root
 * section, and one sub-section for each category.  Each sub-section's
 * name should match the category name.
 *
 * Each sub-section may only contain key/value pairs in the form of:
 * key: "item"
 * value: Name of the item as passed to AddToTopMenu().
 *
 * The TopMenu will draw items in the order declared in the configuration
 * file.  If items do not appear in the configuration file, they are sorted
 * per-player based on how the handler function renders for that player.
 * These items appear after the configuration sorted items.
 *
 * @param topmenu       TopMenu Handle.
 * @param file          File path.
 * @param error         Error buffer.
 * @param maxlength     Maximum size of the error buffer.
 *                      Error buffer will be filled with a
 *                      zero-terminated string if false is
 *                      returned.
 * @return              True on success, false on failure.
 * @error               Invalid TopMenu Handle.
 */
native bool LoadTopMenuConfig(Handle topmenu, const char[] file, char[] error, int maxlength);

/**
 * Adds an topobj to a TopMenu.
 *
 * @param topmenu       TopMenu Handle.
 * @param name          Object name (MUST be unique).
 * @param type          Object type.
 * @param handler       Handler for topobj.
 * @param parent        Parent topobj ID, or INVALID_TOPMENUOBJECT for none.
 *                      Items must have a category parent.
 *                      Categories must not have a parent.
 * @param cmdname       Command name (for access overrides).
 * @param flags         Default access flags.
 * @param info_string   Arbitrary storage (max 255 bytes).
 * @return              A new TopMenuObject ID, or INVALID_TOPMENUOBJECT on
 *                      failure.
 * @error               Invalid TopMenu Handle.
 */
native TopMenuObject AddToTopMenu(Handle topmenu,
								  const char[] name,
								  TopMenuObjectType type,
								  TopMenuHandler handler,
								  TopMenuObject parent,
								  const char[] cmdname="",
								  int flags=0,
								  const char[] info_string="");

/**
 * Retrieves the info string of a top menu item.
 *
 * @param topmenu       TopMenu Handle.
 * @param parent        TopMenuObject ID.
 * @param buffer        Buffer to store info string.
 * @param maxlength     Maximum size of info string.
 * @return              Number of bytes written, not including the
 *                      null terminator.
 * @error               Invalid TopMenu Handle or TopMenuObject ID.
 */
native int GetTopMenuInfoString(Handle topmenu, TopMenuObject parent, char[] buffer, int maxlength);

/**
 * Retrieves the name string of a top menu item.
 *
 * @param topmenu       TopMenu Handle.
 * @param topobj        TopMenuObject ID.
 * @param buffer        Buffer to store info string.
 * @param maxlength     Maximum size of info string.
 * @return              Number of bytes written, not including the
 *                      null terminator.
 * @error               Invalid TopMenu Handle or TopMenuObject ID.
 */
native int GetTopMenuObjName(Handle topmenu, TopMenuObject topobj, char[] buffer, int maxlength);

/**
 * Removes an topobj from a TopMenu.
 *
 * Plugins' topobjs are automatically removed all TopMenus when the given
 * plugin unloads or pauses.  In the case of unpausing, all items are restored.
 *
 * @param topmenu       TopMenu Handle.
 * @param topobj        TopMenuObject ID.
 * @error               Invalid TopMenu Handle.
 */
native void RemoveFromTopMenu(Handle topmenu, TopMenuObject topobj);

/**
 * Displays a TopMenu to a client.
 *
 * @param topmenu       TopMenu Handle.
 * @param client        Client index.
 * @param position      Position to display from.
 * @return              True on success, false on failure.
 * @error               Invalid TopMenu Handle or client not in game.
 */
native bool DisplayTopMenu(Handle topmenu, int client, TopMenuPosition position);

/**
 * Displays a TopMenu category to a client.
 *
 * @param topmenu       TopMenu Handle.
 * @param category      Category topobj id.
 * @param client        Client index.
 * @return              True on success, false on failure.
 * @error               Invalid TopMenu Handle or client not in game.
 */
native bool DisplayTopMenuCategory(Handle topmenu, TopMenuObject category, int client);

/**
 * Finds a category's topobj ID in a TopMenu.
 *
 * @param topmenu       TopMenu Handle.
 * @param name          Object's unique name.
 * @return              TopMenuObject ID on success, or
 *                      INVALID_TOPMENUOBJECT on failure.
 * @error               Invalid TopMenu Handle.
 */
native TopMenuObject FindTopMenuCategory(Handle topmenu, const char[] name);

/**
 * Change the menu title caching behavior of the TopMenu. By default the
 * titles are cached to reduce overhead. If you need dynamic menu titles, which
 * can change everytime the menu is displayed to a user, set this to false.
 *
 * @param topmenu       TopMenu Handle.
 * @param cache_titles  Cache the menu titles and don't call the handler with
 *                      TopMenuAction_DisplayTitle everytime the menu is drawn?
 * @error               Invalid TopMenu Handle
 */
native void SetTopMenuTitleCaching(Handle topmenu, bool cache_titles);


/**
 * Do not edit below this line!
 */
public Extension __ext_topmenus =
{
	name = "TopMenus",
	file = "topmenus.ext",
#if defined AUTOLOAD_EXTENSIONS
	autoload = 1,
#else
	autoload = 0,
#endif
#if defined REQUIRE_EXTENSIONS
	required = 1,
#else
	required = 0,
#endif
};

#if !defined REQUIRE_EXTENSIONS
public void __ext_topmenus_SetNTVOptional()
{
	MarkNativeAsOptional("CreateTopMenu");
	MarkNativeAsOptional("LoadTopMenuConfig");
	MarkNativeAsOptional("AddToTopMenu");
	MarkNativeAsOptional("RemoveFromTopMenu");
	MarkNativeAsOptional("DisplayTopMenu");
	MarkNativeAsOptional("DisplayTopMenuCategory");
	MarkNativeAsOptional("FindTopMenuCategory");
	MarkNativeAsOptional("SetTopMenuTitleCaching");
	MarkNativeAsOptional("TopMenu.TopMenu");
	MarkNativeAsOptional("TopMenu.FromHandle");
	MarkNativeAsOptional("TopMenu.LoadConfig");
	MarkNativeAsOptional("TopMenu.AddCategory");
	MarkNativeAsOptional("TopMenu.AddItem");
	MarkNativeAsOptional("TopMenu.GetInfoString");
	MarkNativeAsOptional("TopMenu.GetObjName");
	MarkNativeAsOptional("TopMenu.Remove");
	MarkNativeAsOptional("TopMenu.Display");
	MarkNativeAsOptional("TopMenu.DisplayCategory");
	MarkNativeAsOptional("TopMenu.FindCategory");
	MarkNativeAsOptional("TopMenu.CacheTitles.set");
}
#endif
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _sdktools_stringtables_included
 #endinput
#endif
#define _sdktools_stringtables_included

#define INVALID_STRING_TABLE -1     /**< An invalid string table index */
#define INVALID_STRING_INDEX -1     /**< An invalid string index in a table */

/**
 * Searches for a string table.
 *
 * @param name          Name of string table to find.
 * @return              A string table index number if found, INVALID_STRING_TABLE otherwise.
 */
native int FindStringTable(const char[] name);

/**
 * Returns the number of string tables that currently exist.
 *
 * @return              Number of string tables that currently exist.
 */
native int GetNumStringTables();

/**
 * Returns the number of strings that currently exist in a given string table.
 *
 * @param tableidx      A string table index.
 * @return              Number of strings that currently exist.
 * @error               Invalid string table index.
 */
native int GetStringTableNumStrings(int tableidx);

/**
 * Returns the maximum number of strings that are allowed in a given string table.
 *
 * @param tableidx      A string table index.
 * @return              Maximum number of strings allowed.
 * @error               Invalid string table index.
 */
native int GetStringTableMaxStrings(int tableidx);

/**
 * Retrieves the name of a string table.
 *
 * @param tableidx      A string table index.
 * @param name          Buffer to store the name of the string table.
 * @param maxlength     Maximum length of string buffer.
 * @return              Number of bytes written to the buffer (UTF-8 safe).
 * @error               Invalid string table index.
 */
native int GetStringTableName(int tableidx, char[] name, int maxlength);

/**
 * Searches for the index of a given string in a string table.
 *
 * @param tableidx      A string table index.
 * @param str           String to find.
 * @return              String index if found, INVALID_STRING_INDEX otherwise.
 * @error               Invalid string table index.
 */
native int FindStringIndex(int tableidx, const char[] str);

/**
 * Retrieves the string at a given index of a string table.
 *
 * @param tableidx      A string table index.
 * @param stringidx     A string index.
 * @param str           Buffer to store the string value.
 * @param maxlength     Maximum length of string buffer.
 * @return              Number of bytes written to the buffer (UTF-8 safe).
 * @error               Invalid string table index or string index.
 */
native int ReadStringTable(int tableidx, int stringidx, char[] str, int maxlength);

/**
 * Returns the length of the user data associated with a given string index.
 *
 * @param tableidx      A string table index.
 * @param stringidx     A string index.
 * @return              Length of user data. This will be 0 if there is no user data.
 * @error               Invalid string table index or string index.
 */
native int GetStringTableDataLength(int tableidx, int stringidx);

/**
 * Retrieves the user data associated with a given string index.
 *
 * @param tableidx      A string table index.
 * @param stringidx     A string index.
 * @param userdata      Buffer to store the user data. This will be set to "" if there is no user data.
 * @param maxlength     Maximum length of string buffer.
 * @return              Number of bytes written to the buffer (UTF-8 safe).
 * @error               Invalid string table index or string index.
 */
native int GetStringTableData(int tableidx, int stringidx, char[] userdata, int maxlength);

/**
 * Sets the user data associated with a given string index.
 *
 * @param tableidx      A string table index.
 * @param stringidx     A string index.
 * @param userdata      User data string that will be set.
 * @param length        Length of user data string. This should include the null terminator.
 * @return              Number of bytes written to the buffer (UTF-8 safe).
 * @error               Invalid string table index or string index.
 */
native int SetStringTableData(int tableidx, int stringidx, const char[] userdata, int length);

/**
 * Adds a string to a given string table.
 *
 * @param tableidx      A string table index.
 * @param str           String to add.
 * @param userdata      An optional user data string.
 * @param length        Length of user data string. This should include the null terminator.
 *                      If set to -1, then user data will be not be altered if the specified string
 *                      already exists in the string table.
 */
native void AddToStringTable(int tableidx, const char[] str, const char[] userdata="", int length=-1);

/**
 * Locks or unlocks the network string tables.
 *
 * @param lock          Determines whether network string tables should be locked.
 *                      True means the tables should be locked for writing; false means unlocked.
 * @return              Previous lock state.
 */
native bool LockStringTables(bool lock);

/**
 * Adds a file to the downloadables network string table.
 * This forces a client to download the file if they do not already have it.
 *
 * @param filename      File that will be added to downloadables table.
 */
stock void AddFileToDownloadsTable(const char[] filename)
{
	static int table = INVALID_STRING_TABLE;

	if (table == INVALID_STRING_TABLE)
	{
		table = FindStringTable("downloadables");
	}

	bool save = LockStringTables(false);
	AddToStringTable(table, filename);
	LockStringTables(save);
}
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2014 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */
#if defined _mapchooser_included_
 #endinput
#endif
#define _mapchooser_included_

enum NominateResult
{
	Nominate_Added,         /** The map was added to the nominate list */
	Nominate_Replaced,      /** A clients existing nomination was replaced */
	Nominate_AlreadyInVote, /** Specified map was already in the vote */
	Nominate_InvalidMap,    /** Mapname specified wasn't a valid map */
	Nominate_VoteFull       /** This will only occur if force was set to false */
};

enum MapChange
{
	MapChange_Instant,      /** Change map as soon as the voting results have come in */
	MapChange_RoundEnd,     /** Change map at the end of the round */
	MapChange_MapEnd        /** Change the sm_nextmap cvar */
};

/**
 * Attempt to add a map to the mapchooser map list.
 *
 * @param map           Map to add.
 * @param force         Should we force the map in even if it requires overwriting an existing nomination?
 * @param owner         Client index of the nominator. If the client disconnects the nomination will be removed.
 *                      Use 0 for constant nominations
 * @return              Nominate Result of the outcome
 */
native NominateResult NominateMap(const char[] map, bool force, int owner);

/**
 * Attempt to remove a map from the mapchooser map list.
 *
 * @param map           Map to remove.
 * @return              True if the nomination was found and removed, or false if the nomination was not found.
 */
native bool RemoveNominationByMap(const char[] map);

/**
 * Attempt to remove a map from the mapchooser map list.
 *
 * @param owner         Client index of the nominator.
 * @return              True if the nomination was found and removed, or false if the nomination was not found.
 */
native bool RemoveNominationByOwner(int owner);

/**
 * Gets the current list of excluded maps.
 *
 * @param array         An ADT array handle to add the map strings to.
 */
native void GetExcludeMapList(ArrayList array);

/**
 * Gets the current list of nominated maps.
 *
 * @param maparray      An ADT array handle to add the map strings to.
 * @param ownerarray    An optional ADT array handle to add the nominator client indexes to.
 */
native void GetNominatedMapList(ArrayList maparray, ArrayList ownerarray = null);

/**
 * Checks if MapChooser will allow a vote
 *
 * @return              True if a vote can be held, or false if mapchooser is already holding a vote.
 */
native bool CanMapChooserStartVote();

/**
 * Initiates a MapChooser map vote
 *
 * Note: If no input array is specified mapchooser will use its internal list. This includes
 * any nominations and excluded maps (as per mapchoosers convars).
 *
 * @param when          MapChange consant of when the resulting mapchange should occur.
 * @param inputarray    ADT array list of maps to add to the vote.
 */
native void InitiateMapChooserVote(MapChange when, ArrayList inputarray=null);

/**
 * Checks if MapChooser's end of map vote has completed.
 *
 * @return              True if complete, false otherwise.
 */
native bool HasEndOfMapVoteFinished();

/**
 * Checks if MapChooser is set to run an end of map vote.
 *
 * @return              True if enabled, false otherwise.
 */
native bool EndOfMapVoteEnabled();

/**
 * Called when mapchooser removes a nomination from its list.
 * Nominations cleared on map start will not trigger this forward
 */
forward void OnNominationRemoved(const char[] map, int owner);

/**
 * Called when mapchooser starts a Map Vote.
 */
forward void OnMapVoteStarted();

public SharedPlugin __pl_mapchooser =
{
	name = "mapchooser",
	file = "mapchooser.smx",
#if defined REQUIRE_PLUGIN
	required = 1,
#else
	required = 0,
#endif
};

public void __pl_mapchooser_SetNTVOptional()
{
	MarkNativeAsOptional("NominateMap");
	MarkNativeAsOptional("RemoveNominationByMap");
	MarkNativeAsOptional("RemoveNominationByOwner");
	MarkNativeAsOptional("GetExcludeMapList");
	MarkNativeAsOptional("GetNominatedMapList");
	MarkNativeAsOptional("CanMapChooserStartVote");
	MarkNativeAsOptional("InitiateMapChooserVote");
	MarkNativeAsOptional("HasEndOfMapVoteFinished");
	MarkNativeAsOptional("EndOfMapVoteEnabled");
}
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _admin_included
 #endinput
#endif
#define _admin_included

/**
 * Access levels (flags) for admins.
 */
enum AdminFlag
{
	Admin_Reservation = 0,  /**< Reserved slot */
	Admin_Generic,          /**< Generic admin abilities */
	Admin_Kick,             /**< Kick another user */
	Admin_Ban,              /**< Ban another user */
	Admin_Unban,            /**< Unban another user */
	Admin_Slay,             /**< Slay/kill/damage another user */
	Admin_Changemap,        /**< Change the map */
	Admin_Convars,          /**< Change basic convars */
	Admin_Config,           /**< Change configuration */
	Admin_Chat,             /**< Special chat privileges */
	Admin_Vote,             /**< Special vote privileges */
	Admin_Password,         /**< Set a server password */
	Admin_RCON,             /**< Use RCON */
	Admin_Cheats,           /**< Change sv_cheats and use its commands */
	Admin_Root,             /**< All access by default */
	Admin_Custom1,          /**< First custom flag type */
	Admin_Custom2,          /**< Second custom flag type */
	Admin_Custom3,          /**< Third custom flag type */
	Admin_Custom4,          /**< Fourth custom flag type */
	Admin_Custom5,          /**< Fifth custom flag type */
	Admin_Custom6           /**< Sixth custom flag type */
};

#define AdminFlags_TOTAL   21       /**< Total number of admin flags */

/**
 * @section Bitwise values definitions for admin flags.
 */
#define ADMFLAG_RESERVATION         (1<<0)      /**< Convenience macro for Admin_Reservation as a FlagBit */
#define ADMFLAG_GENERIC             (1<<1)      /**< Convenience macro for Admin_Generic as a FlagBit */
#define ADMFLAG_KICK                (1<<2)      /**< Convenience macro for Admin_Kick as a FlagBit */
#define ADMFLAG_BAN                 (1<<3)      /**< Convenience macro for Admin_Ban as a FlagBit */
#define ADMFLAG_UNBAN               (1<<4)      /**< Convenience macro for Admin_Unban as a FlagBit */
#define ADMFLAG_SLAY                (1<<5)      /**< Convenience macro for Admin_Slay as a FlagBit */
#define ADMFLAG_CHANGEMAP           (1<<6)      /**< Convenience macro for Admin_Changemap as a FlagBit */
#define ADMFLAG_CONVARS             (1<<7)      /**< Convenience macro for Admin_Convars as a FlagBit */
#define ADMFLAG_CONFIG              (1<<8)      /**< Convenience macro for Admin_Config as a FlagBit */
#define ADMFLAG_CHAT                (1<<9)      /**< Convenience macro for Admin_Chat as a FlagBit */
#define ADMFLAG_VOTE                (1<<10)     /**< Convenience macro for Admin_Vote as a FlagBit */
#define ADMFLAG_PASSWORD            (1<<11)     /**< Convenience macro for Admin_Password as a FlagBit */
#define ADMFLAG_RCON                (1<<12)     /**< Convenience macro for Admin_RCON as a FlagBit */
#define ADMFLAG_CHEATS              (1<<13)     /**< Convenience macro for Admin_Cheats as a FlagBit */
#define ADMFLAG_ROOT                (1<<14)     /**< Convenience macro for Admin_Root as a FlagBit */
#define ADMFLAG_CUSTOM1             (1<<15)     /**< Convenience macro for Admin_Custom1 as a FlagBit */
#define ADMFLAG_CUSTOM2             (1<<16)     /**< Convenience macro for Admin_Custom2 as a FlagBit */
#define ADMFLAG_CUSTOM3             (1<<17)     /**< Convenience macro for Admin_Custom3 as a FlagBit */
#define ADMFLAG_CUSTOM4             (1<<18)     /**< Convenience macro for Admin_Custom4 as a FlagBit */
#define ADMFLAG_CUSTOM5             (1<<19)     /**< Convenience macro for Admin_Custom5 as a FlagBit */
#define ADMFLAG_CUSTOM6             (1<<20)     /**< Convenience macro for Admin_Custom6 as a FlagBit */

/**
 * @endsection
 */

/**
 * @section Hardcoded authentication methods
 */
#define AUTHMETHOD_STEAM            "steam"     /**< SteamID based authentication */
#define AUTHMETHOD_IP               "ip"        /**< IP based authentication */
#define AUTHMETHOD_NAME             "name"      /**< Name based authentication */

/**
 * @endsection
 */

/**
 * Access override types.
 */
enum OverrideType
{
	Override_Command = 1,   /**< Command */
	Override_CommandGroup   /**< Command group */
};

/**
 * Access override rules.
 */
enum OverrideRule
{
	Command_Deny = 0,
	Command_Allow = 1
};

/**
 * DEPRECATED, do not use.
 */
enum ImmunityType
{
	Immunity_Default = 1,   /**< Deprecated. */
	Immunity_Global         /**< Deprecated. */
};

/**
 * Identifies a unique entry in the group permissions cache.  These are not Handles.
 */
enum GroupId
{
	INVALID_GROUP_ID = -1   /**< An invalid/non-existent group */
};

/**
 * Identifies a unique entry in the admin permissions cache.  These are not Handles.
 */
enum AdminId
{
	INVALID_ADMIN_ID = -1   /**< An invalid/non-existent admin */
};

/**
 * Methods of computing access permissions.
 */
enum AdmAccessMode
{
	Access_Real,        /**< Access the user has inherently */
	Access_Effective    /**< Access the user has from their groups */
};

/**
 * Represents the various cache regions.
 */
enum AdminCachePart
{
	AdminCache_Overrides = 0,       /**< Global overrides */
	AdminCache_Groups = 1,          /**< All groups (automatically invalidates admins too) */
	AdminCache_Admins = 2           /**< All admins */
};

methodmap AdminId {
	// Retrieves an admin's user name as made with CreateAdmin().
	//
	// @note This function can return UTF-8 strings, and will safely chop UTF-8 strings.
	//
	// @param name          String buffer to store name.
	// @param maxlength     Maximum size of string buffer.
	// @return              Number of bytes written.
	public native void GetUsername(char[] name, int maxlength);

	// Binds an admin to an identity for fast lookup later on.  The bind must be unique.
	//
	// @param authMethod    Auth method to use, predefined or from RegisterAuthIdentType().
	// @param ident         String containing the arbitrary, unique identity.
	// @return              True on success, false if the auth method was not found,
	//                      ident was already taken, or ident invalid for auth method.
	public native bool BindIdentity(const char[] authMethod, const char[] ident);

	// Sets whether or not a flag is enabled on an admin.
	//
	// @param flag          Admin flag to use.
	// @param enabled       True to enable, false to disable.
	public native void SetFlag(AdminFlag flag, bool enabled);

	// Returns whether or not a flag is enabled on an admin.
	//
	// @param flag          Admin flag to use.
	// @param mode          Access mode to check.
	// @return              True if enabled, false otherwise.
	public native bool HasFlag(AdminFlag flag, AdmAccessMode mode=Access_Effective);

	// Returns the bitstring of access flags on an admin.
	//
	// @param mode          Access mode to use.
	// @return              A bitstring containing which flags are enabled.
	public native int GetFlags(AdmAccessMode mode);

	// Adds a group to an admin's inherited group list.  Any flags the group has
	// will be added to the admin's effective flags.
	//
	// @param gid           GroupId index of the group.
	// @return              True on success, false on invalid input or duplicate membership.
	public native bool InheritGroup(GroupId gid);

	// Returns group information from an admin.
	//
	// @param index         Group number to retrieve, from 0 to N-1, where N
	//                      is the value of the GroupCount property.
	// @param name          Buffer to store the group's name.
	//                      Note: This will safely chop UTF-8 strings.
	// @param maxlength     Maximum size of the output name buffer.
	// @return              A GroupId index and a name pointer, or
	//                      INVALID_GROUP_ID and NULL if an error occurred.
	public native GroupId GetGroup(int index, char[] name, int maxlength);

	// Sets a password on an admin.
	//
	// @param password      String containing the password.
	public native void SetPassword(const char[] password);

	// Gets an admin's password.
	//
	// @param buffer        Optional buffer to store the admin's password.
	// @param maxlength     Maximum size of the output name buffer.
	//                      Note: This will safely chop UTF-8 strings.
	// @return              True if there was a password set, false otherwise.
	public native bool GetPassword(char[] buffer="", int maxlength=0);

	// Tests whether one admin can target another.
	//
	// The heuristics for this check are as follows:
	// 0. If the targeting AdminId is INVALID_ADMIN_ID, targeting fails.
	// 1. If the targeted AdminId is INVALID_ADMIN_ID, targeting succeeds.
	// 2. If the targeted AdminId is the same as the targeting AdminId,
	//    (self) targeting succeeds.
	// 3. If the targeting admin is root, targeting succeeds.
	// 4. If the targeted admin has access higher (as interpreted by
	//    (sm_immunity_mode) than the targeting admin, then targeting fails.
	// 5. If the targeted admin has specific immunity from the
	//    targeting admin via group immunities, targeting fails.
	// 6. Targeting succeeds.
	//
	// @param target        Target admin (may be INVALID_ADMIN_ID).
	// @return              True if targetable, false if immune.
	public native bool CanTarget(AdminId other);

	// The number of groups of which this admin is a member.
	property int GroupCount {
		public native get();
	}

	// Immunity level used for targetting.
	property int ImmunityLevel {
		public native get();
		public native set(int level);
	}
}

methodmap GroupId {
	// Gets whether or not a flag is enabled on a group's flag set.
	//
	// @param flag          Admin flag to retrieve.
	// @return              True if enabled, false otherwise,
	public native bool HasFlag(AdminFlag flag);

	// Adds or removes a flag from a group's flag set.
	//
	// @param flag          Admin flag to toggle.
	// @param enabled       True to set the flag, false to unset/disable.
	public native void SetFlag(AdminFlag flag, bool enabled);

	// Returns the flag set that is added to users from this group.
	//
	// @return              Bitstring containing the flags enabled.
	public native int GetFlags();

	// Returns a group that this group is immune to given an index.
	//
	// @param number        Index from 0 to N-1, from GroupImmunitiesCount.
	// @return              GroupId that this group is immune to, or INVALID_GROUP_ID on failure.
	public native GroupId GetGroupImmunity(int index);

	// Adds immunity to a specific group.
	//
	// @param other         Group id to receive immunity to.
	public native void AddGroupImmunity(GroupId other);

	// Retrieves a group-specific command override.
	//
	// @param name          String containing command name (case sensitive).
	// @param type          Override type (specific command or group).
	// @param rule          Optional pointer to store allow/deny setting.
	// @return              True if an override exists, false otherwise.
	public native bool GetCommandOverride(const char[] name, OverrideType type, OverrideRule &rule);

	// Adds a group-specific override type.
	//
	// @param name          String containing command name (case sensitive).
	// @param type          Override type (specific command or group).
	// @param rule          Override allow/deny setting.
	public native void AddCommandOverride(const char[] name, OverrideType type, OverrideRule rule);

	// Number of specific group immunities
	property int GroupImmunitiesCount {
		public native get();
	}

	// Immunity level used for targetting.
	property int ImmunityLevel {
		public native get();
		public native set(int level);
	}
}

/**
 * Called when part of the cache needs to be rebuilt.
 *
 * @param part          Part of the admin cache to rebuild.
 */
forward void OnRebuildAdminCache(AdminCachePart part);

/**
 * Tells the admin system to dump a portion of the cache.
 *
 * @param part          Part of the cache to dump.  Specifying groups also dumps admins.
 * @param rebuild       If true, the rebuild forwards will fire.
 */
native void DumpAdminCache(AdminCachePart part, bool rebuild);

/**
 * Adds a global command flag override.  Any command registered with this name
 * will assume the new flag.  This is applied retroactively as well.
 *
 * @param cmd           String containing command name (case sensitive).
 * @param type          Override type (specific command or group).
 * @param flags         New admin flag.
 */
native void AddCommandOverride(const char[] cmd, OverrideType type, int flags);

/**
 * Returns a command override.
 *
 * @param cmd           String containing command name (case sensitive).
 * @param type          Override type (specific command or group).
 * @param flags         By-reference cell to store the flag (undefined if not found).
 * @return              True if there is an override, false otherwise.
 */
native bool GetCommandOverride(const char[] cmd, OverrideType type, int &flags);

/**
 * Unsets a command override.
 *
 * @param cmd           String containing command name (case sensitive).
 * @param type          Override type (specific command or group).
 */
native void UnsetCommandOverride(const char[] cmd, OverrideType type);

/**
 * Adds a new group.  Name must be unique.
 *
 * @param group_name    String containing the group name.
 * @return              A new group id, INVALID_GROUP_ID if it already exists.
 */
native GroupId CreateAdmGroup(const char[] group_name);

/**
 * Finds a group by name.
 *
 * @param group_name    String containing the group name.
 * @return              A group id, or INVALID_GROUP_ID if not found.
 */
native GroupId FindAdmGroup(const char[] group_name);

/**
 * Adds or removes a flag from a group's flag set.
 * @note These are called "add flags" because they add to a user's flags.
 *
 * @param id            Group id.
 * @param flag          Admin flag to toggle.
 * @param enabled       True to set the flag, false to unset/disable.
 */
native void SetAdmGroupAddFlag(GroupId id, AdminFlag flag, bool enabled);

/**
 * Gets the set value of an add flag on a group's flag set.
 * @note These are called "add flags" because they add to a user's flags.
 *
 * @param id            Group id.
 * @param flag          Admin flag to retrieve.
 * @return              True if enabled, false otherwise,
 */
native bool GetAdmGroupAddFlag(GroupId id, AdminFlag flag);

/**
 * Returns the flag set that is added to a user from their group.
 * @note These are called "add flags" because they add to a user's flags.
 *
 * @param id            GroupId of the group.
 * @return              Bitstring containing the flags enabled.
 */
native int GetAdmGroupAddFlags(GroupId id);

/**
 * @deprecated          Functionality removed.
 */
#pragma deprecated Use SetAdmGroupImmunityLevel() instead.
native void SetAdmGroupImmunity(GroupId id, ImmunityType type, bool enabled);

/**
 * @deprecated          Functionality removed.
 */
#pragma deprecated Use GetAdmGroupImmunityLevel() instead.
native bool GetAdmGroupImmunity(GroupId id, ImmunityType type);

/**
 * Adds immunity to a specific group.
 *
 * @param id            Group id.
 * @param other_id      Group id to receive immunity to.
 */
native void SetAdmGroupImmuneFrom(GroupId id, GroupId other_id);

/**
 * Returns the number of specific group immunities.
 *
 * @param id            Group id.
 * @return              Number of group immunities.
 */
native int GetAdmGroupImmuneCount(GroupId id);

/**
 * Returns a group that this group is immune to given an index.
 *
 * @param id            Group id.
 * @param number        Index from 0 to N-1, from GetAdmGroupImmuneCount().
 * @return              GroupId that this group is immune to, or INVALID_GROUP_ID on failure.
 */
native GroupId GetAdmGroupImmuneFrom(GroupId id, int number);

/**
 * Adds a group-specific override type.
 *
 * @param id            Group id.
 * @param name          String containing command name (case sensitive).
 * @param type          Override type (specific command or group).
 * @param rule          Override allow/deny setting.
 */
native void AddAdmGroupCmdOverride(GroupId id, const char[] name, OverrideType type, OverrideRule rule);

/**
 * Retrieves a group-specific command override.
 *
 * @param id            Group id.
 * @param name          String containing command name (case sensitive).
 * @param type          Override type (specific command or group).
 * @param rule          Optional pointer to store allow/deny setting.
 * @return              True if an override exists, false otherwise.
 */
native bool GetAdmGroupCmdOverride(GroupId id, const char[] name, OverrideType type, OverrideRule &rule);

/**
 * Registers an authentication identity type.  You normally never need to call this except for
 * very specific systems.
 *
 * @param name          Codename to use for your authentication type.
 */
native void RegisterAuthIdentType(const char[] name);

/**
 * Creates a new admin entry in the permissions cache and returns the generated AdminId index.
 *
 * @param name          Name for this entry (does not have to be unique).
 *                      Specify an empty string for an anonymous admin.
 * @return              New AdminId index or INVALID_ADMIN_ID if name is empty
 */
native AdminId CreateAdmin(const char[] name="");

/**
 * Retrieves an admin's user name as made with CreateAdmin().
 *
 * @note This function can return UTF-8 strings, and will safely chop UTF-8 strings.
 *
 * @param id            AdminId of the admin.
 * @param name          String buffer to store name.
 * @param maxlength     Maximum size of string buffer.
 * @return              Number of bytes written.
 */
native int GetAdminUsername(AdminId id, char[] name, int maxlength);

/**
 * Binds an admin to an identity for fast lookup later on.  The bind must be unique.
 *
 * @param id            AdminId of the admin.
 * @param auth          Auth method to use, predefined or from RegisterAuthIdentType().
 * @param ident         String containing the arbitrary, unique identity.
 * @return              True on success, false if the auth method was not found,
 *                      ident was already taken, or ident invalid for auth method.
 */
native bool BindAdminIdentity(AdminId id, const char[] auth, const char[] ident);

/**
 * Sets whether or not a flag is enabled on an admin.
 *
 * @param id            AdminId index of the admin.
 * @param flag          Admin flag to use.
 * @param enabled       True to enable, false to disable.
 */
native void SetAdminFlag(AdminId id, AdminFlag flag, bool enabled);

/**
 * Returns whether or not a flag is enabled on an admin.
 *
 * @param id            AdminId index of the admin.
 * @param flag          Admin flag to use.
 * @param mode          Access mode to check.
 * @return              True if enabled, false otherwise.
 */
native bool GetAdminFlag(AdminId id, AdminFlag flag, AdmAccessMode mode=Access_Effective);

/**
 * Returns the bitstring of access flags on an admin.
 *
 * @param id            AdminId index of the admin.
 * @param mode          Access mode to use.
 * @return              A bitstring containing which flags are enabled.
 */
native int GetAdminFlags(AdminId id, AdmAccessMode mode);

/**
 * Adds a group to an admin's inherited group list.  Any flags the group has
 * will be added to the admin's effective flags.
 *
 * @param id            AdminId index of the admin.
 * @param gid           GroupId index of the group.
 * @return              True on success, false on invalid input or duplicate membership.
 */
native bool AdminInheritGroup(AdminId id, GroupId gid);

/**
 * Returns the number of groups this admin is a member of.
 *
 * @param id            AdminId index of the admin.
 * @return              Number of groups this admin is a member of.
 */
native int GetAdminGroupCount(AdminId id);

/**
 * Returns group information from an admin.
 *
 * @param id            AdminId index of the admin.
 * @param index         Group number to retrieve, from 0 to N-1, where N
 *                      is the value of GetAdminGroupCount(id).
 * @param name          Buffer to store the group's name.
 *                      Note: This will safely chop UTF-8 strings.
 * @param maxlength     Maximum size of the output name buffer.
 * @return              A GroupId index and a name pointer, or
 *                      INVALID_GROUP_ID and NULL if an error occurred.
 */
native GroupId GetAdminGroup(AdminId id, int index, char[] name, int maxlength);

/**
 * Sets a password on an admin.
 *
 * @param id            AdminId index of the admin.
 * @param password      String containing the password.
 */
native void SetAdminPassword(AdminId id, const char[] password);

/**
 * Gets an admin's password.
 *
 * @param id            AdminId index of the admin.
 * @param buffer        Optional buffer to store the admin's password.
 * @param maxlength     Maximum size of the output name buffer.
 *                      Note: This will safely chop UTF-8 strings.
 * @return              True if there was a password set, false otherwise.
 */
native bool GetAdminPassword(AdminId id, char[] buffer="", int maxlength=0);

/**
 * Attempts to find an admin by an auth method and an identity.
 *
 * @param auth          Auth method to try.
 * @param identity      Identity string to look up.
 * @return              An AdminId index if found, INVALID_ADMIN_ID otherwise.
 */
native AdminId FindAdminByIdentity(const char[] auth, const char[] identity);

/**
 * Removes an admin entry from the cache.
 *
 * @note This will remove any bindings to a specific user.
 *
 * @param id            AdminId index to remove/invalidate.
 * @return              True on success, false otherwise.
 */
native bool RemoveAdmin(AdminId id);

/**
 * Converts a flag bit string to a bit array.
 *
 * @param bits          Bit string containing the flags.
 * @param array         Array to write the flags to.  Enabled flags will be 'true'.
 * @param maxSize       Maximum number of flags the array can store.
 * @return              Number of flags written.
 */
native int FlagBitsToBitArray(int bits, bool[] array, int maxSize);

/**
 * Converts a flag array to a bit string.
 *
 * @param array         Array containing true or false for each AdminFlag.
 * @param maxSize       Maximum size of the flag array.
 * @return              A bit string composed of the array bits.
 */
native int FlagBitArrayToBits(const bool[] array, int maxSize);

/**
 * Converts an array of flags to bits.
 *
 * @param array         Array containing flags that are enabled.
 * @param numFlags      Number of flags in the array.
 * @return              A bit string composed of the array flags.
 */
native int FlagArrayToBits(const AdminFlag[] array, int numFlags);

/**
 * Converts a bit string to an array of flags.
 *
 * @param bits          Bit string containing the flags.
 * @param array         Output array to write flags.
 * @param maxSize       Maximum size of the flag array.
 * @return              Number of flags written.
 */
native int FlagBitsToArray(int bits, AdminFlag[] array, int maxSize);

/**
 * Finds a flag by its string name.
 *
 * @param name          Flag name (like "kick"), case sensitive.
 * @param flag          Variable to store flag in.
 * @return              True on success, false if not found.
 */
native bool FindFlagByName(const char[] name, AdminFlag &flag);

/**
 * Finds a flag by a given character.
 *
 * @param c             Flag ASCII character/token.
 * @param flag          Variable to store flag in.
 * @return              True on success, false if not found.
 */
native bool FindFlagByChar(int c, AdminFlag &flag);

/**
 * Finds the flag char for a given admin flag.
 *
 * @param flag          Flag to look up.
 * @param c             Variable to store flag char.
 * @return              True on success, false if not found.
 */
native bool FindFlagChar(AdminFlag flag, int &c);

/**
 * Converts a string of flag characters to a bit string.
 *
 * @param flags         Flag ASCII string.
 * @param numchars      Optional variable to store the number of bytes read.
 * @return              Bit string of ADMFLAG values.
 */
native int ReadFlagString(const char[] flags, int &numchars=0);

/**
 * Tests whether one admin can target another.
 *
 * The heuristics for this check are as follows:
 * 0. If the targeting AdminId is INVALID_ADMIN_ID, targeting fails.
 * 1. If the targeted AdminId is INVALID_ADMIN_ID, targeting succeeds.
 * 2. If the targeted AdminId is the same as the targeting AdminId,
 *    (self) targeting succeeds.
 * 3. If the targeting admin is root, targeting succeeds.
 * 4. If the targeted admin has access higher (as interpreted by
 *    (sm_immunity_mode) than the targeting admin, then targeting fails.
 * 5. If the targeted admin has specific immunity from the
 *    targeting admin via group immunities, targeting fails.
 * 6. Targeting succeeds.
 *
 * @param admin         Admin doing the targetting (may be INVALID_ADMIN_ID).
 * @param target        Target admin (may be INVALID_ADMIN_ID).
 * @return              True if targetable, false if immune.
 */
native bool CanAdminTarget(AdminId admin, AdminId target);

/**
 * Creates an admin auth method.  This does not need to be called more than once
 * per method, ever.
 *
 * @param method        Name of the authentication method.
 * @return              True on success, false on failure.
 */
native bool CreateAuthMethod(const char[] method);

/**
 * Sets a group's immunity level.
 *
 * @param gid           Group Id.
 * @param level         Immunity level value.
 * @return              Old immunity level value.
 */
native int SetAdmGroupImmunityLevel(GroupId gid, int level);

/**
 * Gets a group's immunity level (defaults to 0).
 *
 * @param gid           Group Id.
 * @return              Immunity level value.
 */
native int GetAdmGroupImmunityLevel(GroupId gid);

/**
 * Sets an admin's immunity level.
 *
 * @param id            Admin Id.
 * @param level         Immunity level value.
 * @return              Old immunity level value.
 */
native int SetAdminImmunityLevel(AdminId id, int level);

/**
 * Gets an admin's immunity level.
 *
 * @param id            Admin Id.
 * @return              Immunity level value.
 */
native int GetAdminImmunityLevel(AdminId id);

/**
 * Converts a flag to its single bit.
 *
 * @param flag          Flag to convert.
 * @return              Bit representation of the flag.
 */
stock int FlagToBit(AdminFlag flag)
{
	return (1 << view_as<int>(flag));
}

/**
 * Converts a bit to an AdminFlag.
 *
 * @param bit           Bit to convert.
 * @param flag          Stores the converted flag by reference.
 * @return              True on success, false otherwise.
 */
stock bool BitToFlag(int bit, AdminFlag &flag)
{
	AdminFlag array[1];

	if (FlagBitsToArray(bit, array, 1))
	{
		flag = array[0];
		return true;
	}

	return false;
}
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _timers_included
 #endinput
#endif
#define _timers_included

#include <datapack>

#define TIMER_REPEAT            (1<<0)      /**< Timer will repeat until it returns Plugin_Stop */
#define TIMER_FLAG_NO_MAPCHANGE (1<<1)      /**< Timer will not carry over mapchanges */
#define TIMER_HNDL_CLOSE        (1<<9)      /**< Deprecated define, replaced by below */
#define TIMER_DATA_HNDL_CLOSE   (1<<9)      /**< Timer will automatically call CloseHandle() on its data when finished */

/**
 * Any of the following prototypes will work for a timed function.
 */
typeset Timer
{
	/**
	 * Called when the timer interval has elapsed.
	 *
	 * @param timer         Handle to the timer object.
	 * @param hndl          Handle passed to CreateTimer() when timer was created.
	 * @return              Plugin_Stop to stop a repeating timer, any other value for
	 *                      default behavior.
	 */
	function Action(Handle timer, Handle hndl);

	/**
	 * Called when the timer interval has elapsed.
	 *
	 * @param timer         Handle to the timer object.
	 * @param data          Data passed to CreateTimer() when timer was created.
	 * @return              Plugin_Stop to stop a repeating timer, any other value for
	 *                      default behavior.
	 */
	function Action(Handle timer, any data);

	/**
	 * Called when the timer interval has elapsed.
	 *
	 * @param timer         Handle to the timer object.
	 * @return              Plugin_Stop to stop a repeating timer, any other value for
	 *                      default behavior.
	 */
	function Action(Handle timer);
};

/**
 * Creates a basic timer.  Calling CloseHandle() on a timer will end the timer.
 *
 * @param interval      Interval from the current game time to execute the given function.
 * @param func          Function to execute once the given interval has elapsed.
 * @param data          Handle or value to pass through to the timer callback function.
 * @param flags         Flags to set (such as repeatability or auto-Handle closing).
 * @return              Handle to the timer object.  You do not need to call CloseHandle().
 *                      If the timer could not be created, INVALID_HANDLE will be returned.
 */
native Handle CreateTimer(float interval, Timer func, any data=INVALID_HANDLE, int flags=0);

/**
 * Kills a timer.  Use this instead of CloseHandle() if you need more options.
 *
 * @param timer         Timer Handle to kill.
 * @param autoClose     If autoClose is true, the data that was passed to CreateTimer() will
 *                      be closed as a handle if TIMER_DATA_HNDL_CLOSE was not specified.
 * @error               Invalid handles will cause a run time error.
 */
native void KillTimer(Handle timer, bool autoClose=false);

/**
 * Manually triggers a timer so its function will be called.
 *
 * @param timer         Timer Handle to trigger.
 * @param reset         If reset is true, the elapsed time counter is reset
 *                      so the full interval must pass again.
 */
native void TriggerTimer(Handle timer, bool reset=false);

/**
 * Returns the simulated game time.
 *
 * This time is internally maintained by SourceMod and is based on the game
 * tick count and tick rate.  Unlike GetGameTime(), it will increment past
 * map changes and while no players are connected.  Unlike GetEngineTime(),
 * it will not increment based on the system clock (i.e. it is still bound
 * to the ticking process).
 *
 * @return              Time based on the game tick count.
 */
native float GetTickedTime();

/**
 * Returns an estimate of the time left before the map ends.  If the server
 * has not processed any frames yet (i.e. no players have joined the map yet),
 * then the time left returned will always be infinite.
 *
 * @param timeleft      Variable to store the time, in seconds.  If the
 *                      value is less than 0, the time limit is infinite.
 * @return              True if the operation is supported, false otherwise.
 */
native bool GetMapTimeLeft(int &timeleft);

/**
 * Retrieves the current map time limit.  If the server has not processed any
 * frames yet (i.e. no players have joined the map yet), then the time limit
 * returned will always be 0.
 *
 * @param time          Set to the number of total seconds in the map time
 *                      limit, or 0 if there is no time limit set.
 * @return              True on success, false if operation is not supported.
 */
native bool GetMapTimeLimit(int &time);

/**
 * Extends the map time limit in a way that will notify all plugins.
 *
 * @param time          Number of seconds to extend map time limit by.
 *                      The number can be negative to decrease the time limit.
 *                      If 0, the map will be set to have no time limit.
 * @return              True on success, false if operation is not supported.
 */
native bool ExtendMapTimeLimit(int time);

/**
 * Returns the number of seconds in between game server ticks.
 *
 * Note: A tick, in this context, is a frame.
 *
 * @return              Number of seconds in between ticks.
 */
native float GetTickInterval();

/**
 * Notification that the map's time left has changed via a change in the time
 * limit or a change in the game rules (such as mp_restartgame).  This is useful
 * for plugins trying to create timers based on the time left in the map.
 *
 * Calling ExtendMapTimeLimit() from here, without proper precaution, will
 * cause infinite recursion.
 *
 * If the operation is not supported, this will never be called.

 * If the server has not yet processed any frames (i.e. no players have joined
 * the map yet), then this will be called once the server begins ticking, even
 * if there is no time limit set.
 */
forward void OnMapTimeLeftChanged();

/**
 * Returns whether or not the server is processing frames or not.
 *
 * The server does not process frames until at least one client joins the game.
 * Once the first player has in, even if that player, leaves, the server's
 * timers and entities will work.
 *
 * @return              True if the server is ticking, false otherwise.
 */
native bool IsServerProcessing();

/**
 * Creates a timer associated with a new datapack, and returns the datapack.
 * @note The datapack is automatically freed when the timer ends.
 * @note The position of the datapack is not reset or changed for the timer function.
 *
 * @param interval      Interval from the current game time to execute the given function.
 * @param func          Function to execute once the given interval has elapsed.
 * @param datapack      The newly created datapack is passed though this by-reference
 *                      parameter to the timer callback function.
 * @param flags         Timer flags.
 * @return              Handle to the timer object.  You do not need to call CloseHandle().
 */
stock Handle CreateDataTimer(float interval, Timer func, Handle &datapack, int flags=0)
{
	datapack = new DataPack();
	flags |= TIMER_DATA_HNDL_CLOSE;
	return CreateTimer(interval, func, datapack, flags);
}
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _tf2_included
 #endinput
#endif
#define _tf2_included

#define TF_STUNFLAG_SLOWDOWN        (1 << 0)    /**< activates slowdown modifier */
#define TF_STUNFLAG_BONKSTUCK       (1 << 1)    /**< bonk sound, stuck */
#define TF_STUNFLAG_LIMITMOVEMENT   (1 << 2)    /**< disable forward/backward movement */
#define TF_STUNFLAG_CHEERSOUND      (1 << 3)    /**< cheering sound */
#define TF_STUNFLAG_NOSOUNDOREFFECT (1 << 5)    /**< no sound or particle */
#define TF_STUNFLAG_THIRDPERSON     (1 << 6)    /**< panic animation */
#define TF_STUNFLAG_GHOSTEFFECT     (1 << 7)    /**< ghost particles */
#define TF_STUNFLAG_SOUND           (1 << 8)    /**< sound */

#define TF_STUNFLAGS_LOSERSTATE     TF_STUNFLAG_SLOWDOWN|TF_STUNFLAG_NOSOUNDOREFFECT|TF_STUNFLAG_THIRDPERSON
#define TF_STUNFLAGS_GHOSTSCARE     TF_STUNFLAG_GHOSTEFFECT|TF_STUNFLAG_THIRDPERSON
#define TF_STUNFLAGS_SMALLBONK      TF_STUNFLAG_THIRDPERSON|TF_STUNFLAG_SLOWDOWN
#define TF_STUNFLAGS_NORMALBONK     TF_STUNFLAG_BONKSTUCK
#define TF_STUNFLAGS_BIGBONK        TF_STUNFLAG_CHEERSOUND|TF_STUNFLAG_BONKSTUCK

enum TFClassType
{
	TFClass_Unknown = 0,
	TFClass_Scout,
	TFClass_Sniper,
	TFClass_Soldier,
	TFClass_DemoMan,
	TFClass_Medic,
	TFClass_Heavy,
	TFClass_Pyro,
	TFClass_Spy,
	TFClass_Engineer
};

enum TFTeam
{
	TFTeam_Unassigned = 0,
	TFTeam_Spectator = 1,
	TFTeam_Red = 2,
	TFTeam_Blue = 3
};

enum TFCond
{
	TFCond_Slowed = 0, //0: Revving Minigun, Sniper Rifle. Gives zoomed/revved pose
	TFCond_Zoomed, //1: Sniper Rifle zooming
	TFCond_Disguising, //2: Disguise smoke
	TFCond_Disguised, //3: Disguise
	TFCond_Cloaked, //4: Cloak effect
	TFCond_Ubercharged, //5: Invulnerability, removed when being healed or by another Uber effect
	TFCond_TeleportedGlow, //6: Teleport trail effect
	TFCond_Taunting, //7: Used for taunting, can remove to stop taunting
	TFCond_UberchargeFading, //8: Invulnerability expiration effect
	TFCond_Unknown1, //9
	TFCond_CloakFlicker = 9, //9: Cloak flickering effect
	TFCond_Teleporting, //10: Used for teleporting, does nothing applying
	TFCond_Kritzkrieged, //11: Crit boost, removed when being healed or another Uber effect
	TFCond_Unknown2, //12
	TFCond_TmpDamageBonus = 12, //12: Temporary damage buff, something along with attribute 19
	TFCond_DeadRingered, //13: Dead Ringer damage resistance, gives TFCond_Cloaked
	TFCond_Bonked, //14: Bonk! Atomic Punch effect
	TFCond_Dazed, //15: Slow effect, can remove to remove stun effects
	TFCond_Buffed, //16: Buff Banner mini-crits, icon, and glow
	TFCond_Charging, //17: Forced forward, charge effect
	TFCond_DemoBuff, //18: Eyelander eye glow
	TFCond_CritCola, //19: Mini-crit effect
	TFCond_InHealRadius, //20: Ring effect, rings disappear after a taunt ends
	TFCond_Healing, //21: Used for healing, does nothing applying
	TFCond_OnFire, //22: Ignite sound and vocals, can remove to remove afterburn
	TFCond_Overhealed, //23: Used for overheal, does nothing applying
	TFCond_Jarated, //24: Jarate effect
	TFCond_Bleeding, //25: Bleed effect
	TFCond_DefenseBuffed, //26: Battalion's Backup's defense, icon, and glow
	TFCond_Milked, //27: Mad Milk effect
	TFCond_MegaHeal, //28: Quick-Fix Ubercharge's knockback/stun immunity and visual effect
	TFCond_RegenBuffed, //29: Concheror's speed boost, heal on hit, icon, and glow
	TFCond_MarkedForDeath, //30: Fan o' War marked-for-death effect
	TFCond_NoHealingDamageBuff, //31: Mini-crits, blocks healing, glow, no weapon mini-crit effects
	TFCond_SpeedBuffAlly, //32: Disciplinary Action speed boost
	TFCond_HalloweenCritCandy, //33: Halloween pumpkin crit-boost
	TFCond_CritCanteen, //34: Crit-boost and doubles Sentry Gun fire-rate
	TFCond_CritDemoCharge, //35: Crit glow, adds TFCond_Charging when charge meter is below 75%
	TFCond_CritHype, //36: Soda Popper multi-jump effect
	TFCond_CritOnFirstBlood, //37: Arena first blood crit-boost
	TFCond_CritOnWin, //38: End-of-round crit-boost (May not remove correctly?)
	TFCond_CritOnFlagCapture, //39: Intelligence capture crit-boost
	TFCond_CritOnKill, //40: Crit-boost from crit-on-kill weapons
	TFCond_RestrictToMelee, //41: Prevents switching once melee is out
	TFCond_DefenseBuffNoCritBlock, //42: MvM Bomb Carrier defense buff (TFCond_DefenseBuffed without crit resistance)
	TFCond_Reprogrammed, //43: No longer functions
	TFCond_CritMmmph, //44: Phlogistinator crit-boost
	TFCond_DefenseBuffMmmph, //45: Old Phlogistinator defense buff
	TFCond_FocusBuff, //46: Hitman's Heatmaker no-unscope and faster Sniper charge
	TFCond_DisguiseRemoved, //47: Enforcer damage bonus removed
	TFCond_MarkedForDeathSilent, //48: Marked-for-death without sound effect
	TFCond_DisguisedAsDispenser, //49: Dispenser disguise when crouching, max movement speed, sentries ignore player
	TFCond_Sapped, //50: Sapper sparkle effect in MvM
	TFCond_UberchargedHidden, //51: Out-of-bounds robot invulnerability effect
	TFCond_UberchargedCanteen, //52: Invulnerability effect and Sentry Gun damage resistance
	TFCond_HalloweenBombHead, //53: Bomb head effect (does not explode)
	TFCond_HalloweenThriller, //54: Forced Thriller taunting
	TFCond_RadiusHealOnDamage, //55: Radius healing, adds TFCond_InHealRadius, TFCond_Healing. Removed when a taunt ends, but this condition stays but does nothing
	TFCond_CritOnDamage, //56: Miscellaneous crit-boost
	TFCond_UberchargedOnTakeDamage, //57: Miscellaneous invulnerability
	TFCond_UberBulletResist, //58: Vaccinator Uber bullet resistance
	TFCond_UberBlastResist, //59: Vaccinator Uber blast resistance
	TFCond_UberFireResist, //60: Vaccinator Uber fire resistance
	TFCond_SmallBulletResist, //61: Vaccinator healing bullet resistance
	TFCond_SmallBlastResist, //62: Vaccinator healing blast resistance
	TFCond_SmallFireResist, //63: Vaccinator healing fire resistance
	TFCond_Stealthed, //64: Cloaked until next attack
	TFCond_MedigunDebuff, //65: Unknown
	TFCond_StealthedUserBuffFade, //66: Cloaked, will appear for a few seconds on attack and cloak again
	TFCond_BulletImmune, //67: Full bullet immunity
	TFCond_BlastImmune, //68: Full blast immunity
	TFCond_FireImmune, //69: Full fire immunity
	TFCond_PreventDeath, //70: Survive to 1 health, then the condition is removed
	TFCond_MVMBotRadiowave, //71: Stuns bots and applies radio effect
	TFCond_HalloweenSpeedBoost, //72: Speed boost, non-melee fire rate and reload, infinite air jumps
	TFCond_HalloweenQuickHeal, //73: Healing effect, adds TFCond_Healing along with TFCond_MegaHeal temporarily
	TFCond_HalloweenGiant, //74: Double size, x10 max health increase, ammo regeneration, and forced thirdperson
	TFCond_HalloweenTiny, //75: Half size and increased head size
	TFCond_HalloweenInHell, //76: Applies TFCond_HalloweenGhostMode when the player dies
	TFCond_HalloweenGhostMode, //77: Becomes a ghost unable to attack but can fly
	TFCond_MiniCritOnKill, //78: Mini-crits effect
	TFCond_DodgeChance, //79
	TFCond_ObscuredSmoke = 79, //79: 75% chance to dodge an attack
	TFCond_Parachute, //80: Parachute effect, removed when touching the ground
	TFCond_BlastJumping, //81: Player is blast jumping
	TFCond_HalloweenKart, //82: Player forced into a Halloween kart
	TFCond_HalloweenKartDash, //83: Forced forward if in TFCond_HalloweenKart, zoom in effect, and dash animations
	TFCond_BalloonHead, //84: Big head and lowered gravity
	TFCond_MeleeOnly, //85: Forced melee, along with TFCond_SpeedBuffAlly and TFCond_HalloweenTiny
	TFCond_SwimmingCurse, //86: Swim in the air with Jarate overlay
	TFCond_HalloweenKartNoTurn, //87
	TFCond_FreezeInput = 87, //87: Prevents player from using controls
	TFCond_HalloweenKartCage, //88: Puts a cage around the player if in TFCond_HalloweenKart, otherwise crashes
	TFCond_HasRune, //89: Has a powerup
	TFCond_RuneStrength, //90: Double damage and no damage falloff
	TFCond_RuneHaste, //91: Double fire rate, reload speed, clip and ammo size, and 30% faster movement speed
	TFCond_RuneRegen, //92: Regen ammo, health, and metal
	TFCond_RuneResist, //93: Takes 1/2 damage and critical immunity
	TFCond_RuneVampire, //94: Takes 3/4 damage, gain health on damage, and 40% increase in max health
	TFCond_RuneWarlock, //95: Attacker takes damage and knockback on hitting the player and 50% increase in max health
	TFCond_RunePrecision, //96: Less bullet spread, no damage falloff, 250% faster projectiles, and double damage, faster charge, and faster re-zoom for Sniper Rifles
	TFCond_RuneAgility, //97: Increased movement speed, grappling hook speed, jump height, and instant weapon switch
	TFCond_GrapplingHook, //98: Used when a player fires their grappling hook, no effect applying or removing
	TFCond_GrapplingHookSafeFall, //99: Used when a player is pulled by their grappling hook, no effect applying or removing
	TFCond_GrapplingHookLatched, //100: Used when a player latches onto a wall, no effect applying or removing
	TFCond_GrapplingHookBleeding, //101: Used when a player is hit by attacker's grappling hook
	TFCond_AfterburnImmune, //102: Deadringer afterburn immunity
	TFCond_RuneKnockout, //103: Melee and grappling hook only, increased max health, knockback immunity, x4 more damage against buildings, and knockbacks a powerup off a victim on hit
	TFCond_RuneImbalance, //104: Prevents gaining a crit-boost or Uber powerups
	TFCond_CritRuneTemp, //105: Crit-boost effect
	TFCond_PasstimeInterception, //106: Used when a player intercepts the Jack/Ball
	TFCond_SwimmingNoEffects, //107: Swimming in the air without animations or overlay
	TFCond_EyeaductUnderworld, //108: Refills max health, short Uber, escaped the underworld message on removal
	TFCond_KingRune, //109: Increased max health and applies TFCond_KingAura
	TFCond_PlagueRune, //110: Radius health kit stealing, increased max health, TFCond_Plague on touching a victim
	TFCond_SupernovaRune, //111: Charge meter passively increasing, when charged activiated causes radius Bonk stun
	TFCond_Plague, //112: Plague sound effect and message, blocks King powerup health regen
	TFCond_KingAura, //113: Increased fire rate, reload speed, and health regen to players in a radius
	TFCond_SpawnOutline, //114: Outline and health meter of teammates (and disguised spies)
	TFCond_KnockedIntoAir, //115: Used when a player is airblasted
	TFCond_CompetitiveWinner, //116: Unknown
	TFCond_CompetitiveLoser, //117: Unknown
	TFCond_NoTaunting_DEPRECATED, //118
	TFCond_HealingDebuff = 118, //118: Healing debuff from Medics and dispensers
	TFCond_PasstimePenaltyDebuff, //119: Marked-for-death effect
	TFCond_GrappledToPlayer, //120: Prevents taunting and some Grappling Hook actions
	TFCond_GrappledByPlayer, //121: Unknown
	TFCond_ParachuteDeployed, //122: Parachute deployed, prevents reopening it
	TFCond_Gas, //123: Gas Passer effect
	TFCond_BurningPyro, //124: Dragon's Fury afterburn on Pyros
	TFCond_RocketPack, //125: Thermal Thruster launched effects, prevents reusing
	TFCond_LostFooting, //126: Less ground friction
	TFCond_AirCurrent //127: Reduced air control and friction
};

const float TFCondDuration_Infinite = -1.0;

enum TFHoliday
{
	TFHoliday_Invalid = -1
};

public const TFHoliday TFHoliday_Birthday;
public const TFHoliday TFHoliday_Halloween;
public const TFHoliday TFHoliday_Christmas;
public const TFHoliday TFHoliday_EndOfTheLine;
public const TFHoliday TFHoliday_CommunityUpdate;
public const TFHoliday TFHoliday_ValentinesDay;
public const TFHoliday TFHoliday_MeetThePyro;
public const TFHoliday TFHoliday_FullMoon;
public const TFHoliday TFHoliday_HalloweenOrFullMoon;
public const TFHoliday TFHoliday_HalloweenOrFullMoonOrValentines;
public const TFHoliday TFHoliday_AprilFools;

enum TFObjectType
{
	TFObject_CartDispenser = 0,
	TFObject_Dispenser = 0,
	TFObject_Teleporter = 1,
	TFObject_Sentry = 2,
	TFObject_Sapper = 3
};

enum TFObjectMode
{
	TFObjectMode_None = 0,
	TFObjectMode_Entrance = 0,
	TFObjectMode_Exit = 1
};

/**
 * Sets a client on fire.
 *
 * @note Fire duration is capped to 10 seconds.
 *
 * @param client        Player's index.
 * @param attacker      Attacker's index.
 * @param duration      Duration of fire (in seconds).
 * @error               Invalid client index, client not in game, or no mod support.
 */
native void TF2_IgnitePlayer(int client, int attacker, float duration=10.0);

/**
 * Respawns a client
 *
 * @param client        Player's index.
 * @error               Invalid client index, client not in game, or no mod support.
 */
native void TF2_RespawnPlayer(int client);

/**
 * Regenerates a client's health and ammunition
 *
 * @param client        Player's index.
 * @error               Invalid client index, client not in game, or no mod support.
 */
native void TF2_RegeneratePlayer(int client);

/**
 * Adds a condition to a player
 *
 * @param client        Player's index.
 * @param condition     Integer identifier of condition to apply.
 * @param duration      Duration of condition (does not apply to all conditions).
 *                      Pass TFCondDuration_Infinite to apply until manually removed.
 * @param inflictor     Condition inflictor's index (0 for no inflictor).
 * @error               Invalid client index, client not in game, or no mod support.
 */
native void TF2_AddCondition(int client, TFCond condition, float duration=TFCondDuration_Infinite, int inflictor=0);

/**
 * Removes a condition from a player
 *
 * @param client        Player's index.
 * @param condition     Integer identifier of condition to remove.
 * @error               Invalid client index, client not in game, or no mod support.
 */
native void TF2_RemoveCondition(int client, TFCond condition);

/**
 * Enables/disables PowerPlay mode on a player.
 *
 * @param client        Player's index.
 * @param enabled       Whether to enable or disable PowerPlay on player.
 * @error               Invalid client index, client not in game, or no mod support.
 */
native void TF2_SetPlayerPowerPlay(int client, bool enabled);

/**
 * Disguises a client to the given model and team. Only has an effect on spies.
 *
 * Note: This only starts the disguise process and a delay occurs before the spy is fully disguised
 *
 * @param client        Player's index.
 * @param team          Team to disguise the player as (only TFTeam_Red and TFTeam_Blue have an effect)
 * @param classType     TFClassType class to disguise the player as
 * @param target        Specific target player to disguise as (0 for any)
 * @error               Invalid client index, client not in game, or no mod support.
 */
native void TF2_DisguisePlayer(int client, TFTeam team, TFClassType classType, int target=0);

/**
 * Removes the current disguise from a client. Only has an effect on spies.
 *
 * @param client        Player's index.
 * @error               Invalid client index, client not in game, or no mod support.
 */
native void TF2_RemovePlayerDisguise(int client);

/**
 * Stuns a client
 *
 * @param client        Player's index.
 * @param duration      Duration of stun.
 * @param slowdown      Slowdown percent (as decimal, 0.00-1.00)
 *                      Ignored if TF_STUNFLAG_SLOWDOWN is not set.
 * @param stunflags     Stun flags.
 * @param attacker      Attacker's index (0 is allowed for world).
 */
native void TF2_StunPlayer(int client, float duration, float slowdown=0.0, int stunflags, int attacker=0);

/**
 * Induces the bleed effect on a client
 *
 * @param client        Player's index.
 * @param attacker      Attacker's index.
 * @param duration      Duration of bleeding (in seconds).
 */
native void TF2_MakeBleed(int client, int attacker, float duration);

/**
 * Retrieves the entity index of the CPlayerResource entity
 *
 * @return              The current resource entity index.
 * @deprecated          Use GetPlayerResourceEntity instead
 */
#pragma deprecated Use GetPlayerResourceEntity instead
native int TF2_GetResourceEntity();

/**
 * Finds the TFClassType for a given class name.
 *
 * @param classname     A classname string such as "sniper" or "demoman"
 * @return              A TFClassType constant.
 */
native TFClassType TF2_GetClass(const char[] classname);

/**
 * Called on weapon fire to decide if the current shot should be critical.
 * Return Plugin_Continue to let the original calculation or return a higher
 * action to override the decision with the value of 'result'
 *
 * @note Since critical shots are also calculated client side any changes made with
 *       this will not show for the shooter. Projectile weapons such as the rocketlauncher
 *       and demoman weapons will show a critical bullet but no critical sound effect.
 *       Bullet hits should appear as expected.
 *
 * @param client        Client Index.
 * @param weapon        Weapon entity Index.
 * @param weaponname    Classname of the weapon.
 * @param result        Buffer param for the result of the decision.
 */
forward Action TF2_CalcIsAttackCritical(int client, int weapon, char[] weaponname, bool &result);

/**
 * @deprecated          No longer called. Use TF2_OnIsHolidayActive.
 */
#pragma deprecated No longer called. Use TF2_OnIsHolidayActive.
forward Action TF2_OnGetHoliday(TFHoliday &holiday);

/**
 * Called at various times when the game checks to see if the given holiday is active.
 * Return Plugin_Continue to let the original calculation or return a higher
 * action to override the decision with the value of 'result'
 *
 * @param holiday       Holiday being checked.
 * @param result        Buffer param for the result of the decision.
 * @return              Plugin_Continue for original calculation, higher value to use 'result'.
 */
forward Action TF2_OnIsHolidayActive(TFHoliday holiday, bool &result);

/**
 * Returns whether or not a holiday is active
 *
 * @param holiday       Holiday being checked.
 * @return              Boolean of whether or not the holiday is active.
 */
native bool TF2_IsHolidayActive(TFHoliday holiday);

/**
 * Returns whether or not a client (Player) is in a duel.
 *
 * @param client    Client Index.
 * @return              Boolean of whether or not the client/player is dueling.
 */
native bool TF2_IsPlayerInDuel(int client);

/**
 * Removes an econ wearable (hat, misc, etc) from a player.
 * This also deletes the wearable entity.
 *
 * @param client        Client index.
 * @param wearable      Index of the wearable entity.
 * @error               Invalid client index, client not in game, invalid wearable entity, or no mod support.
*/
native void TF2_RemoveWearable(int client, int wearable);

/**
 * Called after a condition is added to a player
 *
 * @param client        Index of the client to which the condition is being added.
 * @param condition     Condition that is being added.
 */
forward void TF2_OnConditionAdded(int client, TFCond condition);

/**
 * Called after a condition is removed from a player
 *
 * @param client        Index of the client to which the condition is being removed.
 * @param condition     Condition that is being removed.
 */
forward void TF2_OnConditionRemoved(int client, TFCond condition);

/**
 * Called when the server enters the Waiting for Players round state
 */
forward void TF2_OnWaitingForPlayersStart();

/**
 * Called when the server exits the Waiting for Players round state
 */
forward void TF2_OnWaitingForPlayersEnd();

/**
 * Called when a player attempts to use a teleporter to decide if the player should be allowed to teleport.
 * Return Plugin_Continue to let the original calculation or return a higher
 * action to override the decision with the value of 'result'
 *
 * @param client        Client index.
 * @param teleporter    Teleporter entity index.
 * @param result        Buffer param for the result of the decision.
 *                      This is prepopulated with the game's original decision to let a player teleport.
 * @return              Plugin_Continue for original calculation, higher value to use 'result'.
 */
forward Action TF2_OnPlayerTeleport(int client, int teleporter, bool &result);
 
/**
 * Do not edit below this line!
 */
public Extension __ext_tf2 = 
{
	name = "TF2 Tools",
	file = "game.tf2.ext",
	autoload = 0,
#if defined REQUIRE_EXTENSIONS
	required = 1,
#else
	required = 0,
#endif
};

#if !defined REQUIRE_EXTENSIONS
public void __ext_tf2_SetNTVOptional()
{
	MarkNativeAsOptional("TF2_IgnitePlayer");
	MarkNativeAsOptional("TF2_RespawnPlayer");
	MarkNativeAsOptional("TF2_RegeneratePlayer");
	MarkNativeAsOptional("TF2_AddCondition");
	MarkNativeAsOptional("TF2_RemoveCondition");
	MarkNativeAsOptional("TF2_SetPlayerPowerPlay");
	MarkNativeAsOptional("TF2_DisguisePlayer");
	MarkNativeAsOptional("TF2_RemovePlayerDisguise");
	MarkNativeAsOptional("TF2_StunPlayer");
	MarkNativeAsOptional("TF2_MakeBleed");
	MarkNativeAsOptional("TF2_GetResourceEntity");
	MarkNativeAsOptional("TF2_GetClass");
	MarkNativeAsOptional("TF2_IsPlayerInDuel");
	MarkNativeAsOptional("TF2_IsHolidayActive");
	MarkNativeAsOptional("TF2_RemoveWearable");
}
#endif
/**
 * vim: set ts=4 sw=4 tw=99 noet :
 * =============================================================================
 * SourceMod (C)2004-2014 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */
 
#if defined _adt_stack_included
 #endinput
#endif
#define _adt_stack_included

methodmap ArrayStack < Handle
{
	// Creates a stack structure.  A stack is a LIFO (last in, first out) 
	// vector (array) of items.  It has O(1) insertion and O(1) removal.
	//
	// Stacks have two operations: Push (adding an item) and Pop (removes 
	// items in reverse-push order).
	// 
	// The contents of the stack are uniform; i.e. storing a string and then 
	// retrieving it as an integer is NOT the same as StringToInt()!
	//
	// The "blocksize" determines how many cells each slot has; it cannot
	// be changed after creation.
	//
	// @param blocksize    The number of cells each entry in the stack can 
	//                     hold.  For example, 32 cells is equivalent to:
	//                     new Array[X][32]
	public native ArrayStack(int blocksize=1);

	// Pushes a value onto the end of the stack, adding a new index.
	//
	// This may safely be used even if the stack has a blocksize
	// greater than 1.
	//
	// @param value        Value to push.
	public native void Push(any value);

	// Pushes a copy of a string onto the end of a stack, truncating it if it
	// is too big.
	//
	// @param value        String to push.
	public native void PushString(const char[] value);

	// Pushes a copy of an array of cells onto the end of a stack. The cells
	// are pushed as a block (i.e. the entire array takes up one stack slot),
	// rather than pushing each cell individually.
	//
	// @param stack        Stack Handle.
	// @param values       Block of values to copy.
	// @param size         If not set, the number of elements copied from the array
	//                     will be equal to the blocksize.  If set higher than the 
	//                     blocksize, the operation will be truncated.
	public native void PushArray(const any[] values, int size=-1);

	// Pops a cell value from a stack.
	//
	// @param block        Optionally specify which block to read from
	//                     (useful if the blocksize > 0).
	// @param asChar       Optionally read as a byte instead of a cell.
	// @return             True on success, false if the stack is empty.
	// @error              The stack is empty.
	public native any Pop(int block=0, bool asChar=false);

	// Pops a string value from a stack.
	//
	// @param buffer       Buffer to store string.
	// @param maxlength    Maximum size of the buffer.
	// @oaram written      Number of characters written to buffer, not including
	//                     the null terminator.
	// @error              The stack is empty.
	public native void PopString(char[] buffer, int maxlength, int &written = 0);

	// Pops an array of cells from a stack.
	//
	// @param buffer       Buffer to store the array in.
	// @param size         If not set, assumes the buffer size is equal to the
	//                     blocksize.  Otherwise, the size passed is used.
	// @error              The stack is empty.
	public native void PopArray(any[] buffer, int size=-1);

	// Returns true if the stack is empty, false otherwise.
	property bool Empty {
		public native get();
	}
	
	// Retrieve the blocksize the stack was created with.
	property int BlockSize {
		public native get();
	}
};

/**
 * Creates a stack structure.  A stack is a LIFO (last in, first out) 
 * vector (array) of items.  It has O(1) insertion and O(1) removal.
 *
 * Stacks have two operations: Push (adding an item) and Pop (removes 
 * items in reverse-push order).
 * 
 * The contents of the stack are uniform; i.e. storing a string and then 
 * retrieving it as an integer is NOT the same as StringToInt()!
 *
 * The "blocksize" determines how many cells each slot has; it cannot
 * be changed after creation.
 *
 * @param blocksize     The number of cells each entry in the stack can 
 *                      hold.  For example, 32 cells is equivalent to:
 *                      new Array[X][32]
 * @return              New stack Handle.
 */
native ArrayStack CreateStack(int blocksize=1);

/**
 * Pushes a value onto the end of the stack, adding a new index.
 *
 * This may safely be used even if the stack has a blocksize
 * greater than 1.
 *
 * @param stack         Stack Handle.
 * @param value         Value to push.
 * @error               Invalid Handle or out of memory.
 */
native void PushStackCell(Handle stack, any value);

/**
 * Pushes a copy of a string onto the end of a stack, truncating it if it is 
 * too big.
 *
 * @param stack         Stack Handle.
 * @param value         String to push.
 * @error               Invalid Handle or out of memory.
 */
native void PushStackString(Handle stack, const char[] value);

/**
 * Pushes a copy of an array of cells onto the end of a stack.  The cells
 * are pushed as a block (i.e. the entire array takes up one stack slot),
 * rather than pushing each cell individually.
 *
 * @param stack         Stack Handle.
 * @param values        Block of values to copy.
 * @param size          If not set, the number of elements copied from the array
 *                      will be equal to the blocksize.  If set higher than the 
 *                      blocksize, the operation will be truncated.
 * @error               Invalid Handle or out of memory.
 */
native void PushStackArray(Handle stack, const any[] values, int size=-1);

/**
 * Pops a cell value from a stack.
 *
 * @param stack         Stack Handle.
 * @param value         Variable to store the value.
 * @param block         Optionally specify which block to read from
 *                      (useful if the blocksize > 0).
 * @param asChar        Optionally read as a byte instead of a cell.
 * @return              True on success, false if the stack is empty.
 * @error               Invalid Handle.
 */
native bool PopStackCell(Handle stack, any &value, int block=0, bool asChar=false);

/**
 * Pops a string value from a stack.
 *
 * @param stack         Stack Handle.
 * @param buffer        Buffer to store string.
 * @param maxlength     Maximum size of the buffer.
 * @return              True on success, false if the stack is empty.
 * @error               Invalid Handle.
 */
native bool PopStackString(Handle stack, char[] buffer, int maxlength, int &written=0);

/**
 * Pops an array of cells from a stack.
 *
 * @param stack         Stack Handle.
 * @param buffer        Buffer to store the array in.
 * @param size          If not set, assumes the buffer size is equal to the
 *                      blocksize.  Otherwise, the size passed is used.
 * @return              True on success, false if the stack is empty.
 * @error               Invalid Handle.
 */
native bool PopStackArray(Handle stack, any[] buffer, int size=-1);

/**
 * Checks if a stack is empty.
 *
 * @param stack         Stack Handle.
 * @return              True if empty, false if not empty.
 * @error               Invalid Handle.
 */
native bool IsStackEmpty(Handle stack);

/**
 * Pops a value off a stack, ignoring it completely.
 *
 * @param stack         Stack Handle.
 * @return              True if something was popped, false otherwise.
 * @error               Invalid Handle.
 */
stock bool PopStack(Handle stack)
{
	int value;
	return PopStackCell(stack, value);
}

/**
 * Returns the blocksize the stack was created with.
 *
 * @param stack         Stack Handle.
 * @return              The blocksize of the stack.
 * @error               Invalid Handle
 */
native int GetStackBlockSize(Handle stack);
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _vector_included
 #endinput
#endif
#define _vector_included

/**
 * Calculates a vector's length.
 *
 * @param vec           Vector.
 * @param squared       If true, the result will be squared (for optimization).
 * @return              Vector length (magnitude).
 */
native float GetVectorLength(const float vec[3], bool squared=false);

/**
 * Calculates the distance between two vectors.
 *
 * @param vec1          First vector.
 * @param vec2          Second vector.
 * @param squared       If true, the result will be squared (for optimization).
 * @return              Vector distance.
 */
native float GetVectorDistance(const float vec1[3], const float vec2[3], bool squared=false);

/**
 * Calculates the dot product of two vectors.
 *
 * @param vec1          First vector.
 * @param vec2          Second vector.
 * @return              Dot product of the two vectors.
 */
native float GetVectorDotProduct(const float vec1[3], const float vec2[3]);

/**
 * Computes the cross product of two vectors.  Any input array can be the same
 * as the output array.
 *
 * @param vec1          First vector.
 * @param vec2          Second vector.
 * @param result        Resultant vector.
 */
native void GetVectorCrossProduct(const float vec1[3], const float vec2[3], float result[3]);

/**
 * Normalizes a vector.  The input array can be the same as the output array.
 *
 * @param vec           Vector.
 * @param result        Resultant vector.
 * @return              Vector length.
 */
native float NormalizeVector(const float vec[3], float result[3]);

/**
 * Returns vectors in the direction of an angle.
 *
 * @param angle         Angle.
 * @param fwd           Forward vector buffer or NULL_VECTOR.
 * @param right         Right vector buffer or NULL_VECTOR.
 * @param up            Up vector buffer or NULL_VECTOR.
 */
native void GetAngleVectors(const float angle[3], float fwd[3], float right[3], float up[3]);

/**
 * Returns angles from a vector.
 *
 * @param vec           Vector.
 * @param angle         Angle buffer.
 */
native void GetVectorAngles(const float vec[3], float angle[3]);

/**
 * Returns direction vectors from a vector.
 *
 * @param vec           Vector.
 * @param right         Right vector buffer or NULL_VECTOR.
 * @param up            Up vector buffer or NULL_VECTOR.
 */
native void GetVectorVectors(const float vec[3], float right[3], float up[3]);

/**
 * Adds two vectors.  It is safe to use either input buffer as an output
 * buffer.
 *
 * @param vec1          First vector.
 * @param vec2          Second vector.
 * @param result        Result buffer.
 */
stock void AddVectors(const float vec1[3], const float vec2[3], float result[3])
{
	result[0] = vec1[0] + vec2[0];
	result[1] = vec1[1] + vec2[1];
	result[2] = vec1[2] + vec2[2];
}

/**
 * Subtracts a vector from another vector.  It is safe to use either input
 * buffer as an output buffer.
 *
 * @param vec1          First vector.
 * @param vec2          Second vector to subtract from first.
 * @param result        Result buffer.
 */
stock void SubtractVectors(const float vec1[3], const float vec2[3], float result[3])
{
	result[0] = vec1[0] - vec2[0];
	result[1] = vec1[1] - vec2[1];
	result[2] = vec1[2] - vec2[2];
}

/**
 * Scales a vector.
 *
 * @param vec           Vector.
 * @param scale         Scale value.
 */
stock void ScaleVector(float vec[3], float scale)
{
	vec[0] *= scale;
	vec[1] *= scale;
	vec[2] *= scale;
}

/**
 * Negatives a vector.
 *
 * @param vec           Vector.
 */
stock void NegateVector(float vec[3])
{
	vec[0] = -vec[0];
	vec[1] = -vec[1];
	vec[2] = -vec[2];
}

/**
 * Builds a vector from two points by subtracting the points.
 *
 * @param pt1           First point (to be subtracted from the second).
 * @param pt2           Second point.
 * @param output        Output vector buffer.
 */
stock void MakeVectorFromPoints(const float pt1[3], const float pt2[3], float output[3])
{
	output[0] = pt2[0] - pt1[0];
	output[1] = pt2[1] - pt1[1];
	output[2] = pt2[2] - pt1[2];
}
/**
 * vim: set ts=4 sw=4 tw=99 noet:
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _core_included
 #endinput
#endif
#define _core_included

#include <version>

/** If this gets changed, you need to update Core's check. */
#define SOURCEMOD_PLUGINAPI_VERSION     5

struct PlVers
{
	public int version;
	public const char[] filevers;
	public const char[] date;
	public const char[] time;
};

/**
 * Specifies what to do after a hook completes.
 */
enum Action
{
	Plugin_Continue = 0,    /**< Continue with the original action */
	Plugin_Changed = 1,     /**< Inputs or outputs have been overridden with new values */
	Plugin_Handled = 3,     /**< Handle the action at the end (don't call it) */
	Plugin_Stop = 4         /**< Immediately stop the hook chain and handle the original */
};

/**
 * Specifies identity types.
 */
enum Identity
{
	Identity_Core = 0,
	Identity_Extension = 1,
	Identity_Plugin = 2
};

public PlVers __version = 
{
	version = SOURCEMOD_PLUGINAPI_VERSION,
	filevers = SOURCEMOD_VERSION,
	date = __DATE__,
	time = __TIME__
};

/**
 * Plugin status values.
 */
enum PluginStatus
{
	Plugin_Running=0,       /**< Plugin is running */
	/* All states below are "temporarily" unexecutable */
	Plugin_Paused,          /**< Plugin is loaded but paused */
	Plugin_Error,           /**< Plugin is loaded but errored/locked */
	/* All states below do not have all natives */
	Plugin_Loaded,          /**< Plugin has passed loading and can be finalized */
	Plugin_Failed,          /**< Plugin has a fatal failure */
	Plugin_Created,         /**< Plugin is created but not initialized */
	Plugin_Uncompiled,      /**< Plugin is not yet compiled by the JIT */
	Plugin_BadLoad,         /**< Plugin failed to load */
	Plugin_Evicted          /**< Plugin was unloaded due to an error */
};

/**
 * Plugin information properties. Plugins can declare a global variable with
 * their info. Example,
 *
 *   public Plugin myinfo = {
 *   	name = "Admin Help",
 *   	author = "AlliedModders LLC",
 *   	description = "Display command information",
 *   	version = "1.0",
 *   	url = "http://www.sourcemod.net/"
 *   };
 *
 * SourceMod will display this information when a user inspects plugins in the
 * console.
 */
enum PluginInfo
{
	PlInfo_Name,            /**< Plugin name */
	PlInfo_Author,          /**< Plugin author */
	PlInfo_Description,     /**< Plugin description */
	PlInfo_Version,         /**< Plugin version */
	PlInfo_URL              /**< Plugin URL */
};

/**
 * Defines how an extension must expose itself for autoloading.
 */
struct Extension
{
	public const char[] name;   /**< Short name */
	public const char[] file;   /**< Default file name */
	public bool autoload;       /**< Whether or not to auto-load */
	public bool required;       /**< Whether or not to require */
};

/**
 * Defines how a plugin must expose itself for native requiring.
 */
struct SharedPlugin
{
	public const char[] name;   /**< Short name */
	public const char[] file;   /**< File name */
	public bool required;       /**< Whether or not to require */
};

public float NULL_VECTOR[3];        /**< Pass this into certain functions to act as a C++ NULL */
public const char NULL_STRING[1];   /**< pass this into certain functions to act as a C++ NULL */

/**
 * Check if the given vector is the NULL_VECTOR.
 *
 * @param vec     The vector to test.
 * @return        True if NULL_VECTOR, false otherwise.
 */
native bool IsNullVector(const float vec[3]);

/**
 * Check if the given string is the NULL_STRING.
 *
 * @param str     The string to test.
 * @return        True if NULL_STRING, false otherwise.
 */
native bool IsNullString(const char[] str);

/**
 * Horrible compatibility shim.
 */
public Extension __ext_core = 
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};

native int VerifyCoreVersion();

/**
 * Sets a native as optional, such that if it is unloaded, removed,
 * or otherwise non-existent, the plugin will still work.  Calling
 * removed natives results in a run-time error.
 *
 * @param name          Native name.
 */
native void MarkNativeAsOptional(const char[] name);

public void __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");

	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");

	MarkNativeAsOptional("BfWrite.WriteBool");
	MarkNativeAsOptional("BfWrite.WriteByte");
	MarkNativeAsOptional("BfWrite.WriteChar");
	MarkNativeAsOptional("BfWrite.WriteShort");
	MarkNativeAsOptional("BfWrite.WriteWord");
	MarkNativeAsOptional("BfWrite.WriteNum");
	MarkNativeAsOptional("BfWrite.WriteFloat");
	MarkNativeAsOptional("BfWrite.WriteString");
	MarkNativeAsOptional("BfWrite.WriteEntity");
	MarkNativeAsOptional("BfWrite.WriteAngle");
	MarkNativeAsOptional("BfWrite.WriteCoord");
	MarkNativeAsOptional("BfWrite.WriteVecCoord");
	MarkNativeAsOptional("BfWrite.WriteVecNormal");
	MarkNativeAsOptional("BfWrite.WriteAngles");
	MarkNativeAsOptional("BfRead.ReadBool");
	MarkNativeAsOptional("BfRead.ReadByte");
	MarkNativeAsOptional("BfRead.ReadChar");
	MarkNativeAsOptional("BfRead.ReadShort");
	MarkNativeAsOptional("BfRead.ReadWord");
	MarkNativeAsOptional("BfRead.ReadNum");
	MarkNativeAsOptional("BfRead.ReadFloat");
	MarkNativeAsOptional("BfRead.ReadString");
	MarkNativeAsOptional("BfRead.ReadEntity");
	MarkNativeAsOptional("BfRead.ReadAngle");
	MarkNativeAsOptional("BfRead.ReadCoord");
	MarkNativeAsOptional("BfRead.ReadVecCoord");
	MarkNativeAsOptional("BfRead.ReadVecNormal");
	MarkNativeAsOptional("BfRead.ReadAngles");
	MarkNativeAsOptional("BfRead.BytesLeft.get");

	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");

	MarkNativeAsOptional("Protobuf.ReadInt");
	MarkNativeAsOptional("Protobuf.ReadInt64");
	MarkNativeAsOptional("Protobuf.ReadFloat");
	MarkNativeAsOptional("Protobuf.ReadBool");
	MarkNativeAsOptional("Protobuf.ReadString");
	MarkNativeAsOptional("Protobuf.ReadColor");
	MarkNativeAsOptional("Protobuf.ReadAngle");
	MarkNativeAsOptional("Protobuf.ReadVector");
	MarkNativeAsOptional("Protobuf.ReadVector2D");
	MarkNativeAsOptional("Protobuf.GetRepeatedFieldCount");
	MarkNativeAsOptional("Protobuf.SetInt");
	MarkNativeAsOptional("Protobuf.SetInt64");
	MarkNativeAsOptional("Protobuf.SetFloat");
	MarkNativeAsOptional("Protobuf.SetBool");
	MarkNativeAsOptional("Protobuf.SetString");
	MarkNativeAsOptional("Protobuf.SetColor");
	MarkNativeAsOptional("Protobuf.SetAngle");
	MarkNativeAsOptional("Protobuf.SetVector");
	MarkNativeAsOptional("Protobuf.SetVector2D");
	MarkNativeAsOptional("Protobuf.AddInt");
	MarkNativeAsOptional("Protobuf.AddInt64");
	MarkNativeAsOptional("Protobuf.AddFloat");
	MarkNativeAsOptional("Protobuf.AddBool");
	MarkNativeAsOptional("Protobuf.AddString");
	MarkNativeAsOptional("Protobuf.AddColor");
	MarkNativeAsOptional("Protobuf.AddAngle");
	MarkNativeAsOptional("Protobuf.AddVector");
	MarkNativeAsOptional("Protobuf.AddVector2D");
	MarkNativeAsOptional("Protobuf.RemoveRepeatedFieldValue");
	MarkNativeAsOptional("Protobuf.ReadMessage");
	MarkNativeAsOptional("Protobuf.ReadRepeatedMessage");
	MarkNativeAsOptional("Protobuf.AddMessage");

	VerifyCoreVersion();
}


#define AUTOLOAD_EXTENSIONS
#define REQUIRE_EXTENSIONS
#define REQUIRE_PLUGIN
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _cstrike_included
 #endinput
#endif
#define _cstrike_included

#define CS_TEAM_NONE        0   /**< No team yet. */
#define CS_TEAM_SPECTATOR   1   /**< Spectators. */
#define CS_TEAM_T           2   /**< Terrorists. */
#define CS_TEAM_CT          3   /**< Counter-Terrorists. */

#define CS_SLOT_PRIMARY     0   /**< Primary weapon slot. */
#define CS_SLOT_SECONDARY   1   /**< Secondary weapon slot. */
#define CS_SLOT_KNIFE       2   /**< Knife slot. */
#define CS_SLOT_GRENADE     3   /**< Grenade slot (will only return one grenade). */
#define CS_SLOT_C4          4   /**< C4 slot. */

#define CS_DMG_HEADSHOT     (1 << 30)    /**< Headshot */

enum CSRoundEndReason
{
	CSRoundEnd_TargetBombed = 0,           /**< Target Successfully Bombed! */
	CSRoundEnd_VIPEscaped,                 /**< The VIP has escaped! - Doesn't exist on CS:GO */
	CSRoundEnd_VIPKilled,                  /**< VIP has been assassinated! - Doesn't exist on CS:GO */
	CSRoundEnd_TerroristsEscaped,          /**< The terrorists have escaped! */
	CSRoundEnd_CTStoppedEscape,            /**< The CTs have prevented most of the terrorists from escaping! */
	CSRoundEnd_TerroristsStopped,          /**< Escaping terrorists have all been neutralized! */
	CSRoundEnd_BombDefused,                /**< The bomb has been defused! */
	CSRoundEnd_CTWin,                      /**< Counter-Terrorists Win! */
	CSRoundEnd_TerroristWin,               /**< Terrorists Win! */
	CSRoundEnd_Draw,                       /**< Round Draw! */
	CSRoundEnd_HostagesRescued,            /**< All Hostages have been rescued! */
	CSRoundEnd_TargetSaved,                /**< Target has been saved! */
	CSRoundEnd_HostagesNotRescued,         /**< Hostages have not been rescued! */
	CSRoundEnd_TerroristsNotEscaped,       /**< Terrorists have not escaped! */
	CSRoundEnd_VIPNotEscaped,              /**< VIP has not escaped! - Doesn't exist on CS:GO */
	CSRoundEnd_GameStart,                  /**< Game Commencing! */
	
	// The below only exist on CS:GO
	CSRoundEnd_TerroristsSurrender,        /**< Terrorists Surrender */
	CSRoundEnd_CTSurrender,                /**< CTs Surrender */
	CSRoundEnd_TerroristsPlanted,          /**< Terrorists Planted the bomb */
	CSRoundEnd_CTsReachedHostage           /**< CTs Reached the hostage */
};

enum CSWeaponID
{
	CSWeapon_NONE = 0,
	CSWeapon_P228,
	CSWeapon_GLOCK,
	CSWeapon_SCOUT,
	CSWeapon_HEGRENADE,
	CSWeapon_XM1014,
	CSWeapon_C4,
	CSWeapon_MAC10,
	CSWeapon_AUG,
	CSWeapon_SMOKEGRENADE,
	CSWeapon_ELITE,
	CSWeapon_FIVESEVEN,
	CSWeapon_UMP45,
	CSWeapon_SG550,
	CSWeapon_GALIL,
	CSWeapon_FAMAS,
	CSWeapon_USP,
	CSWeapon_AWP,
	CSWeapon_MP5NAVY,
	CSWeapon_M249,
	CSWeapon_M3,
	CSWeapon_M4A1,
	CSWeapon_TMP,
	CSWeapon_G3SG1,
	CSWeapon_FLASHBANG,
	CSWeapon_DEAGLE,
	CSWeapon_SG552,
	CSWeapon_AK47,
	CSWeapon_KNIFE,
	CSWeapon_P90,
	CSWeapon_SHIELD,
	CSWeapon_KEVLAR,
	CSWeapon_ASSAULTSUIT,
	CSWeapon_NIGHTVISION, //Anything below is CS:GO ONLY
	CSWeapon_GALILAR,
	CSWeapon_BIZON,
	CSWeapon_MAG7,
	CSWeapon_NEGEV,
	CSWeapon_SAWEDOFF,
	CSWeapon_TEC9,
	CSWeapon_TASER,
	CSWeapon_HKP2000,
	CSWeapon_MP7,
	CSWeapon_MP9,
	CSWeapon_NOVA,
	CSWeapon_P250,
	CSWeapon_SCAR17,
	CSWeapon_SCAR20,
	CSWeapon_SG556,
	CSWeapon_SSG08,
	CSWeapon_KNIFE_GG,
	CSWeapon_MOLOTOV,
	CSWeapon_DECOY,
	CSWeapon_INCGRENADE,
	CSWeapon_DEFUSER,
	CSWeapon_HEAVYASSAULTSUIT,
	//The rest are actual item definition indexes for CS:GO
	CSWeapon_CUTTERS = 56,
	CSWeapon_HEALTHSHOT = 57,
	CSWeapon_KNIFE_T = 59,
	CSWeapon_M4A1_SILENCER = 60,
	CSWeapon_USP_SILENCER = 61,
	CSWeapon_CZ75A = 63,
	CSWeapon_REVOLVER = 64,
	CSWeapon_TAGGRENADE = 68,
	CSWeapon_FISTS = 69,
	CSWeapon_BREACHCHARGE = 70,
	CSWeapon_TABLET = 72,
	CSWeapon_MELEE = 74,
	CSWeapon_AXE = 75,
	CSWeapon_HAMMER = 76,
	CSWeapon_SPANNER = 78,
	CSWeapon_KNIFE_GHOST = 80,
	CSWeapon_FIREBOMB = 81,
	CSWeapon_DIVERSION = 82,
	CSWeapon_FRAGGRENADE = 83,
	CSWeapon_SNOWBALL = 84,
	CSWeapon_BUMPMINE = 85,
	CSWeapon_MAX_WEAPONS_NO_KNIFES, // Max without the knife item defs, useful when treating all knives as a regular knife.
	CSWeapon_BAYONET = 500,
	CSWeapon_KNIFE_FLIP = 505,
	CSWeapon_KNIFE_GUT = 506,
	CSWeapon_KNIFE_KARAMBIT = 507,
	CSWeapon_KNIFE_M9_BAYONET = 508,
	CSWeapon_KNIFE_TATICAL = 509,
	CSWeapon_KNIFE_FALCHION = 512,
	CSWeapon_KNIFE_SURVIVAL_BOWIE = 514,
	CSWeapon_KNIFE_BUTTERFLY = 515,
	CSWeapon_KNIFE_PUSH = 516,
	CSWeapon_KNIFE_CORD = 517,
	CSWeapon_KNIFE_CANIS = 518,
	CSWeapon_KNIFE_URSUS = 519,
	CSWeapon_KNIFE_GYPSY_JACKKNIFE = 520,
	CSWeapon_KNIFE_OUTDOOR = 521,
	CSWeapon_KNIFE_STILETTO = 522,
	CSWeapon_KNIFE_WIDOWMAKER = 523,
	CSWeapon_KNIFE_SKELETON = 525,
	CSWeapon_MAX_WEAPONS //THIS MUST BE LAST, EASY WAY TO CREATE LOOPS. When looping, do CS_IsValidWeaponID(i), to check.
};

/**
 * Called when a player attempts to purchase an item.
 * Return Plugin_Continue to allow the purchase or return a
 * higher action to deny.
 *
 * @param client        Client index
 * @param weapon        User input for weapon name
 */
forward Action CS_OnBuyCommand(int client, const char[] weapon);

/**
 * Called when CSWeaponDrop is called
 * Return Plugin_Continue to allow the call or return a
 * higher action to block.
 *
 * @param client        Client index
 * @param weaponIndex   Weapon index
 */
forward Action CS_OnCSWeaponDrop(int client, int weaponIndex);

/**
 * Called when game retrieves a weapon's price for a player.
 * Return Plugin_Continue to use default value or return a higher
 * action to use a newly-set price.
 * 
 * @note This can be called multiple times per weapon purchase
 * 
 * @param client        Client index
 * @param weapon        Weapon classname
 * @param price         Buffer param for the price of the weapon
 *
 * @note Not all "weapons" call GetWeaponPrice. Example: c4, knife, vest, vest helmet, night vision.
 */
forward Action CS_OnGetWeaponPrice(int client, const char[] weapon, int &price);

/**
 * Called when TerminateRound is called.
 * Return Plugin_Continue to ignore, return Plugin_Changed to continue,
 * using the given delay and reason, or return Plugin_Handled or a higher
 * action to block TerminateRound from firing.
 *
 * @param delay         Time (in seconds) until new round starts
 * @param reason        Reason for round end
 */
forward Action CS_OnTerminateRound(float &delay, CSRoundEndReason &reason);

/**
 * Respawns a player.
 *
 * @param client        Player's index.
 * @error               Invalid client index, client not in game.
 */
native void CS_RespawnPlayer(int client);

/**
 * Switches the player's team.
 *
 * @param client        Player's index.
 * @param team          Team index.
 * @error               Invalid client index, client not in game.
 */
native void CS_SwitchTeam(int client, int team);

/**
 * Forces a player to drop or toss their weapon
 *
 * @param client        Player's index.
 * @param weaponIndex   Index of weapon to drop.
 * @param toss          True to toss weapon (with velocity) or false to just drop weapon
 * @param blockhook     Set to true to stop the corresponding CS_OnCSWeaponDrop
 * @error               Invalid client index, client not in game, or invalid weapon index.
 */
native void CS_DropWeapon(int client, int weaponIndex, bool toss, bool blockhook = false);

/**
 * Forces round to end with a reason
 *
 * @param delay         Time (in seconds) to delay before new round starts
 * @param reason        Reason for the round ending
 * @param blockhook     Set to true to stop the corresponding CS_OnTerminateRound
 *                      forward from being called.
 */
native void CS_TerminateRound(float delay, CSRoundEndReason reason, bool blockhook = false);
 
/**
 * Gets a weapon name from a weapon alias
 *
 * @param alias         Weapons alias to get weapon name for.
 * @param weapon        Buffer to store weapons name
 * @param size          Size of buffer to store the weapons name.
 *
 * @note Will set the buffer to the original alias if it is not an alias to a weapon.
 */
native void CS_GetTranslatedWeaponAlias(const char[] alias, char[] weapon, int size);
 
/**
 * Gets a weapon's price
 *
 * @param client        Client to check weapon price for.
 * @param id            Weapon id for the weapon to check
 * @param defaultprice  Set to true to get defaultprice.
 * @return              Returns price of the weapon (even if modified)
 * @error               Invalid client, failing to get weapon info, or failing to get price offset.
 *
 * @note c4, knife and shield will always return 0. vest, vest helmet and night vision will always return default price.
 */
native int CS_GetWeaponPrice(int client, CSWeaponID id, bool defaultprice = false);
 
/**
 * Gets a clients clan tag
 *
 * @param client        Client index to get clan tag for.
 * @param buffer        Buffer to store clients clan tag in.
 * @param size          Size of the buffer.
 * @return              Number of non-null bytes written.
 * @error               Invalid client.
 */
native int CS_GetClientClanTag(int client, char[] buffer, int size);

/**
 * Sets a clients clan tag
 *
 * @param client        Client index to set clan tag for.
 * @param tag           Tag to set clients clan tag as.
 * @error               Invalid client.
 */
native void CS_SetClientClanTag(int client, const char[] tag);

/**
 * Gets a team's score
 *
 * @param team          Team index to get score for.
 * @return              Returns the internal team score.
 * @error               Invalid team index.
 */
native int CS_GetTeamScore(int team);

/**
 * Sets a team's score
 *
 * @param team          Team index to set score for.
 * @param value         Value to set teams score as.
 * @error               Invalid team index.
 *
 * @note This will update the scoreboard only after the scoreboard update function is called.
 *       Use SetTeamScore plus this to update the scoreboard instantly and save values correctly.
 */
native void CS_SetTeamScore(int team, int value);

/**
 * Gets a client's mvp count
 *
 * @param client        Client index to get mvp count of.
 * @return              Returns the client's internal MVP count.
 * @error               Invalid client.
 */
native int CS_GetMVPCount(int client);

/**
 * Sets a client's mvp count
 *
 * @param client        Client index to set mvp count for.
 * @param value         Value to set client's mvp count as.
 * @error               Invalid client.
 */
native void CS_SetMVPCount(int client, int value);

/**
 * Gets a client's contribution score (CS:GO only)
 *
 * @param client        Client index to get score of.
 * @return              Returns the client's score.
 * @error               Invalid client.
 */
native int CS_GetClientContributionScore(int client);

/**
 * Sets a client's contribution score (CS:GO only)
 *
 * @param client        Client index to set score for.
 * @param value         Value to set client's score as.
 * @error               Invalid client.
 */
native void CS_SetClientContributionScore(int client, int value);

/**
 * Gets a client's assists (CS:GO only)
 *
 * @param client        Client index to get assists of.
 * @return              Returns the client's assists.
 * @error               Invalid client.
 */
native int CS_GetClientAssists(int client);

/**
 * Sets a client's assists (CS:GO only)
 *
 * @param client        Client index to set assists for.
 * @param value         Value to set client's assists as.
 * @error               Invalid client.
 */
native void CS_SetClientAssists(int client, int value);

/**
 * Gets a weaponID from a alias
 *
 * @param alias         Weapon alias to attempt to get an id for.
 * @return              Returns a weapon id or 0 if failed to find a match.
 *
 * @note For best results use CS_GetTranslatedWeaponAlias on the weapon name before passing it.
 */
native CSWeaponID CS_AliasToWeaponID(const char[] alias);

/**
 * Gets a alias from a weaponID
 *
 * @param weaponID      WeaponID to get alias for.
 * @param destination   Destination string to hold the weapon alias.
 * @param len           Length of the destination array.
 * @return              Returns number of cells written.
 */
native int CS_WeaponIDToAlias(CSWeaponID weaponID, char[] destination, int len);

/**
 * Returns weather a WeaponID is valid on the current mod (css or csgo)
 *
 * @param weaponID      WeaponID to check
 * @return              Returns true if its a valid WeaponID false otherwise.
 *
 * @note This will return false always for CSWeapon_NONE. Should only be called after OnMapStart since weapon info isnt intialized before.
 */
native bool CS_IsValidWeaponID(CSWeaponID id);

/**
 * Sets a player's model based on their current class
 *
 * @param client        Player's index.
 * @error               Invalid client index, client not in game.
 */
native void CS_UpdateClientModel(int client);

/**
 * Returns a CSWeaponID equivalent based on the item definition index.
 *
 * @param iDefIndex     Definition index to get the CSWeaponID value for.
 * @return              Returns CSWeaponID value for the definition index.
 * @error               Invalid definition index.
 *
 * @note In most cases the id will be the item definition index. Works for CS:GO ONLY.
 */
native CSWeaponID CS_ItemDefIndexToID(int iDefIndex);

/**
 * Returns a item definition index equivalent based on the CSWeaponID.
 *
 * @param id            CSWeaponID to get the item definition for.
 * @return              Returns item definition index value for the weapon id.
 * @error               Invalid weapon id.
 *
 * @note In most cases the item deinition index will be the id. Works for CS:GO ONLY.
 */
native int CS_WeaponIDToItemDefIndex(CSWeaponID id);

/**
 * Do not edit below this line!
 */
public Extension __ext_cstrike = 
{
	name = "cstrike",
	file = "games/game.cstrike.ext",
	autoload = 0,
#if defined REQUIRE_EXTENSIONS
	required = 1,
#else
	required = 0,
#endif
};

#if !defined REQUIRE_EXTENSIONS
public void __ext_cstrike_SetNTVOptional()
{
	MarkNativeAsOptional("CS_RespawnPlayer");
	MarkNativeAsOptional("CS_SwitchTeam");
	MarkNativeAsOptional("CS_DropWeapon");
	MarkNativeAsOptional("CS_TerminateRound");
	MarkNativeAsOptional("CS_GetTranslatedWeaponAlias");
	MarkNativeAsOptional("CS_GetWeaponPrice");
	MarkNativeAsOptional("CS_GetClientClanTag");
	MarkNativeAsOptional("CS_SetClientClanTag");
	MarkNativeAsOptional("CS_GetTeamScore");
	MarkNativeAsOptional("CS_SetTeamScore");
	MarkNativeAsOptional("CS_GetMVPCount");
	MarkNativeAsOptional("CS_SetMVPCount");
	MarkNativeAsOptional("CS_GetClientContributionScore");
	MarkNativeAsOptional("CS_SetClientContributionScore");
	MarkNativeAsOptional("CS_GetClientAssists");
	MarkNativeAsOptional("CS_SetClientAssists");
	MarkNativeAsOptional("CS_AliasToWeaponID");
	MarkNativeAsOptional("CS_WeaponIDToAlias");
	MarkNativeAsOptional("CS_IsValidWeaponID");
	MarkNativeAsOptional("CS_UpdateClientModel");
	MarkNativeAsOptional("CS_ItemDefIndexToID");
	MarkNativeAsOptional("CS_WeaponIDToItemDefIndex");
}
#endif
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2011 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */
 
#if defined _basecomm_included
 #endinput
#endif
#define _basecomm_included

/**
 * Called when a client is muted or unmuted
 * 
 * @param   client      Client index
 * @param   muteState   True if client was muted, false otherwise
 */
forward void BaseComm_OnClientMute(int client, bool muteState);
 
 /**
 * Called when a client is gagged or ungagged
 * 
 * @param   client      Client index
 * @param   gagState    True if client was gaged, false otherwise
 */
forward void BaseComm_OnClientGag(int client, bool gagState);
 
/**
 * Returns whether or not a client is gagged
 *
 * @param client        Client index.
 * @return              True if client is gagged, false otherwise.
 */
native bool BaseComm_IsClientGagged(int client);

/**
 * Returns whether or not a client is muted
 *
 * @param client        Client index.
 * @return              True if client is muted, false otherwise.
 */
native bool BaseComm_IsClientMuted(int client);

/**
 * Sets a client's gag state
 *
 * @param client        Client index.
 * @param gagState      True to gag client, false to ungag.
 * @return              True if this caused a change in gag state, false otherwise.
 */
native bool BaseComm_SetClientGag(int client, bool gagState);

/**
 * Sets a client's mute state
 *
 * @param client        Client index.
 * @param muteState     True to mute client, false to unmute.
 * @return              True if this caused a change in mute state, false otherwise.
 */
native bool BaseComm_SetClientMute(int client, bool muteState);

/* DO NOT EDIT BELOW THIS LINE */

public SharedPlugin __pl_basecomm = 
{
	name = "basecomm",
	file = "basecomm.smx",
#if defined REQUIRE_PLUGIN
	required = 1,
#else
	required = 0,
#endif
};

#if !defined REQUIRE_PLUGIN
public void __pl_basecomm_SetNTVOptional()
{
	MarkNativeAsOptional("BaseComm_IsClientGagged");
	MarkNativeAsOptional("BaseComm_IsClientMuted");
	MarkNativeAsOptional("BaseComm_SetClientGag");
	MarkNativeAsOptional("BaseComm_SetClientMute");
}
#endif
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _clients_included
 #endinput
#endif
#define _clients_included

/**
 * Network flow directions.
 */
enum NetFlow
{
	NetFlow_Outgoing = 0,   /**< Outgoing traffic */
	NetFlow_Incoming,       /**< Incoming traffic */
	NetFlow_Both            /**< Both values added together */
};

/**
 * Auth string types.
 *
 * Note that for the Steam2 and Steam3 types, the following ids are
 * also valid values:
 * "STEAM_ID_PENDING" - Authentication is pending.
 * "STEAM_ID_LAN" - Authentication is disabled because of being on a LAN server.
 * "BOT" - The client is a bot.
 */
enum AuthIdType
{
	AuthId_Engine = 0,     /**< The game-specific auth string as returned from the engine */
	
	// The following are only available on games that support Steam authentication.
	AuthId_Steam2,         /**< Steam2 rendered format, ex "STEAM_1:1:4153990" */
	AuthId_Steam3,         /**< Steam3 rendered format, ex "[U:1:8307981]" */
	AuthId_SteamID64       /**< A SteamID64 (uint64) as a String, ex "76561197968573709" */
};

/**
 * MAXPLAYERS is not the same as MaxClients.
 * MAXPLAYERS is a hardcoded value as an upper limit.  MaxClients changes based on the server.
 */

#define MAXPLAYERS      65  /**< Maximum number of players SourceMod supports */
#define MAX_NAME_LENGTH 128 /**< Maximum buffer required to store a client name */

public const int MaxClients;   /**< Maximum number of players the server supports (dynamic) */

/**
 * Called on client connection.  If you return true, the client will be allowed in the server.
 * If you return false (or return nothing), the client will be rejected.  If the client is 
 * rejected by this forward or any other, OnClientDisconnect will not be called.
 *
 * Note: Do not write to rejectmsg if you plan on returning true.  If multiple plugins write
 * to the string buffer, it is not defined which plugin's string will be shown to the client,
 * but it is guaranteed one of them will.
 *
 * @param client        Client index.
 * @param rejectmsg     Buffer to store the rejection message when the connection is refused.
 * @param maxlen        Maximum number of characters for rejection buffer.
 * @return              True to validate client's connection, false to refuse it.
 */
forward bool OnClientConnect(int client, char[] rejectmsg, int maxlen);

/**
 * Called once a client successfully connects.  This callback is paired with OnClientDisconnect.
 *
 * @param client        Client index.
 */
forward void OnClientConnected(int client);

/**
 * Called when a client is entering the game.
 *
 * Whether a client has a steamid is undefined until OnClientAuthorized
 * is called, which may occur either before or after OnClientPutInServer.
 * Similarly, use OnClientPostAdminCheck() if you need to verify whether 
 * connecting players are admins.
 *
 * GetClientCount() will include clients as they are passed through this 
 * function, as clients are already in game at this point.
 *
 * @param client        Client index.
 */
forward void OnClientPutInServer(int client);

/**
 * Called when a client is disconnecting from the server.
 *
 * @param client        Client index.
 */
forward void OnClientDisconnect(int client);

/**
 * Called when a client is disconnected from the server.
 *
 * @param client        Client index.
 */
forward void OnClientDisconnect_Post(int client);

/**
 * Called when a client is sending a command.
 *
 * As of SourceMod 1.3, the client is guaranteed to be in-game.
 * Use command listeners (console.inc) for more advanced hooks.
 *
 * @param client        Client index.
 * @param args          Number of arguments.
 * @return              Plugin_Handled blocks the command from being sent,
 *                      and Plugin_Continue resumes normal functionality.
 */
forward Action OnClientCommand(int client, int args);

/**
 * Called when a client is sending a KeyValues command.
 *
 * @param client        Client index.
 * @param kv            Editable KeyValues data to be sent as the command.
 *                      (This handle should not be stored and will be closed
 *                      after this forward completes.)
 * @return              Plugin_Handled blocks the command from being sent,
 *                      and Plugin_Continue resumes normal functionality.
 */
forward Action OnClientCommandKeyValues(int client, KeyValues kv);

/**
 * Called after a client has sent a KeyValues command.
 *
 * @param client        Client index.
 * @param kv            KeyValues data sent as the command.
 *                      (This handle should not be stored and will be closed
 *                      after this forward completes.)
 */
forward void OnClientCommandKeyValues_Post(int client, KeyValues kv);

/**
 * Called whenever the client's settings are changed.
 *
 * @param client        Client index.
 */
forward void OnClientSettingsChanged(int client);

/**
 * Called when a client receives an auth ID.  The state of a client's 
 * authorization as an admin is not guaranteed here.  Use 
 * OnClientPostAdminCheck() if you need a client's admin status.
 *
 * This is called by bots, but the ID will be "BOT".
 *
 * @param client        Client index.
 * @param auth          Client Steam2 id, if available, else engine auth id.
 */
forward void OnClientAuthorized(int client, const char[] auth);

/**
 * Called once a client is authorized and fully in-game, but 
 * before admin checks are done.  This can be used to override 
 * the default admin checks for a client.  You should only use 
 * this for overriding; use OnClientPostAdminCheck() instead 
 * if you want notification.
 *
 * Note: If handled/blocked, PostAdminCheck must be signalled 
 * manually via NotifyPostAdminCheck().
 *
 * This callback is guaranteed to occur on all clients, and always 
 * after each OnClientPutInServer() call.
 *
 * @param client        Client index.
 * @return              Plugin_Handled to block admin checks.
 */
forward Action OnClientPreAdminCheck(int client);

/**
 * Called directly before OnClientPostAdminCheck() as a method to 
 * alter administrative permissions before plugins perform final 
 * post-connect operations.  
 *
 * In general, do not use this function unless you are specifically 
 * attempting to change access permissions.  Use OnClientPostAdminCheck() 
 * instead if you simply want to perform post-connect authorization 
 * routines.
 *
 * See OnClientPostAdminCheck() for more information.
 *
 * @param client        Client index.
 */
forward void OnClientPostAdminFilter(int client);

/**
 * Called once a client is authorized and fully in-game, and 
 * after all post-connection authorizations have been performed.  
 *
 * This callback is guaranteed to occur on all clients, and always 
 * after each OnClientPutInServer() call.
 *
 * @param client        Client index.
 */
forward void OnClientPostAdminCheck(int client);

/**
 * This function is deprecated. Use the MaxClients variable instead.
 *
 * Returns the maximum number of clients allowed on the server.  This may 
 * return 0 if called before OnMapStart(), and thus should not be called 
 * in OnPluginStart().  
 *
 * You should not globally cache the value to GetMaxClients() because it can change from 
 * SourceTV or TF2's arena mode.  Use the "MaxClients" dynamic variable documented at the 
 * top of this file.
 *
 * @return              Maximum number of clients allowed.
 * @deprecated          Use MaxClients variable instead.
 */
#pragma deprecated Use MaxClients variable instead.
native int GetMaxClients();

/**
 * Returns the maximum number of human players allowed on the server.  This is 
 * a game-specific function used on newer games to limit the number of humans
 * that can join a game and can be lower than MaxClients. It is the number often
 * reflected in the server browser or when viewing the output of the status command.
 * On unsupported games or modes without overrides, it will return the same value
 * as MaxClients.
 *
 * You should not globally cache the value to GetMaxHumanPlayers() because it can change across
 * game modes. You may still cache it locally.
 *
 * @return              Maximum number of humans allowed.
 */
native int GetMaxHumanPlayers();

/**
 * Returns the client count put in the server.
 *
 * @param inGameOnly    If false connecting players are also counted.
 * @return              Client count in the server.
 */
native int GetClientCount(bool inGameOnly=true);

/**
 * Returns the client's name.
 *
 * @param client        Player index.
 * @param name          Buffer to store the client's name.
 * @param maxlen        Maximum length of string buffer (includes NULL terminator).
 * @return              True on success, false otherwise.
 * @error               If the client is not connected an error will be thrown.
 */
native bool GetClientName(int client, char[] name, int maxlen);

/**
 * Retrieves a client's IP address.
 *
 * @param client        Player index.
 * @param ip            Buffer to store the client's ip address.
 * @param maxlen        Maximum length of string buffer (includes NULL terminator).
 * @param remport       Remove client's port from the ip string (true by default).
 * @return              True on success, false otherwise.
 * @error               If the client is not connected or the index is invalid.
 */
native bool GetClientIP(int client, char[] ip, int maxlen, bool remport=true);

/**
 * Retrieves a client's authentication string (SteamID).
 *
 * @param client        Player index.
 * @param auth          Buffer to store the client's auth string.
 * @param maxlen        Maximum length of string buffer (includes NULL terminator).
 * @param validate      Check backend validation status.
 *                      DO NOT PASS FALSE UNLESS YOU UNDERSTAND THE CONSEQUENCES,
 *                      You WILL KNOW if you need to use this, MOST WILL NOT.
 * @return              True on success, false otherwise.
 * @error               If the client is not connected or the index is invalid.
 * @deprecated          Use GetClientAuthId
 */
#pragma deprecated Use GetClientAuthId
native bool GetClientAuthString(int client, char[] auth, int maxlen, bool validate=true);

/**
 * Retrieves a client's authentication string (SteamID).
 *
 * @param client        Player index.
 * @param authType      Auth id type and format to use.
 * @param auth          Buffer to store the client's auth id.
 * @param maxlen        Maximum length of string buffer (includes NULL terminator).
 * @param validate      Check backend validation status.
 *                      DO NOT PASS FALSE UNLESS YOU UNDERSTAND THE CONSEQUENCES,
 *                      You WILL KNOW if you need to use this, MOST WILL NOT.
 * @return              True on success, false otherwise.
 * @error               If the client is not connected or the index is invalid.
 */
native bool GetClientAuthId(int client, AuthIdType authType, char[] auth, int maxlen, bool validate=true);

/**
 * Returns the client's Steam account ID, a number uniquely identifying a given Steam account.
 * This number is the basis for the various display SteamID forms, see the AuthIdType enum for examples.
 *
 * @param client        Client Index.
 * @param validate      Check backend validation status.
 *                      DO NOT PASS FALSE UNLESS YOU UNDERSTAND THE CONSEQUENCES,
 *                      You WILL KNOW if you need to use this, MOST WILL NOT.
 * @return              Steam account ID or 0 if not available.
 * @error               If the client is not connected or the index is invalid.
 */
native int GetSteamAccountID(int client, bool validate=true);

/**
 * Retrieves a client's user id, which is an index incremented for every client
 * that joins the server.
 *
 * @param client        Player index.
 * @return              User id of the client.
 * @error               If the client is not connected or the index is invalid.
 */
native int GetClientUserId(int client);

/**
 * Returns if a certain player is connected.
 *
 * @param client        Player index.
 * @return              True if player is connected to the server, false otherwise.
 */
native bool IsClientConnected(int client);

/**
 * Returns if a certain player has entered the game.
 *
 * @param client        Player index (index does not have to be connected).
 * @return              True if player has entered the game, false otherwise.
 * @error               Invalid client index.
 */
native bool IsClientInGame(int client);

/**
 * Returns if a client is in the "kick queue" (i.e. the client will be kicked 
 * shortly and thus they should not appear as valid).
 *
 * @param client        Player index (must be connected).
 * @return              True if in the kick queue, false otherwise.
 * @error               Invalid client index.
 */
native bool IsClientInKickQueue(int client);

/**
 * Backwards compatibility stock - use IsClientInGame
 * @deprecated          Renamed to IsClientInGame
 */
#pragma deprecated Use IsClientInGame() instead
stock bool IsPlayerInGame(int client)
{
	return IsClientInGame(client);
}

/**
 * Returns if a certain player has been authenticated.
 *
 * @param client        Player index.
 * @return              True if player has been authenticated, false otherwise.
 */
native bool IsClientAuthorized(int client);

/**
 * Returns if a certain player is a fake client.
 *
 * @param client        Player index.
 * @return              True if player is a fake client, false otherwise.
 */
native bool IsFakeClient(int client);

/**
 * Returns if a certain player is the SourceTV bot.
 *
 * @param client        Player index.
 * @return              True if player is the SourceTV bot, false otherwise.
 */
native bool IsClientSourceTV(int client);

/**
 * Returns if a certain player is the Replay bot.
 *
 * @param client        Player index.
 * @return              True if player is the Replay bot, false otherwise.
 */
native bool IsClientReplay(int client);

/**
 * Returns if a certain player is an observer/spectator.
 *
 * @param client        Player index.
 * @return              True if player is an observer, false otherwise.
 */
native bool IsClientObserver(int client);

/**
 * Returns if the client is alive or dead.
 *
 * Note: This function was originally in SDKTools and was moved to core.
 *
 * @param client        Player's index.
 * @return              True if the client is alive, false otherwise.
 * @error               Invalid client index, client not in game, or no mod support.
 */
native bool IsPlayerAlive(int client);

/**
 * Retrieves values from client replicated keys.
 *
 * @param client        Player's index.
 * @param key           Key string.
 * @param value         Buffer to store value.
 * @param maxlen        Maximum length of valve (UTF-8 safe).
 * @return              True on success, false otherwise.
 * @error               Invalid client index, or client not connected.
 */
native bool GetClientInfo(int client, const char[] key, char[] value, int maxlen);

/**
 * Retrieves a client's team index.
 *
 * @param client        Player's index.
 * @return              Team index the client is on (mod specific).
 * @error               Invalid client index, client not in game, or no mod support.
 */
native int GetClientTeam(int client);
 
/**
 * Sets a client's AdminId.  
 *
 * @param client        Player's index.
 * @param id            AdminId to set.  INVALID_ADMIN_ID removes admin permissions.
 * @param temp          True if the id should be freed on disconnect.
 * @error               Invalid client index, client not connected, or bogus AdminId.
 */
native void SetUserAdmin(int client, AdminId id, bool temp=false);

/**
 * Retrieves a client's AdminId.
 *
 * @param client        Player's index.
 * @return              AdminId of the client, or INVALID_ADMIN_ID if none.
 * @error               Invalid client index, or client not connected.
 */
native AdminId GetUserAdmin(int client);

/**
 * Sets access flags on a client.  If the client is not an admin,
 * a temporary, anonymous AdminId is given.
 *
 * @param client        Player's index.
 * @param ...           Flags to set on the client.
 * @error               Invalid client index, or client not connected.
 */
native void AddUserFlags(int client, AdminFlag ...);

/**
 * Removes flags from a client.  If the client is not an admin,
 * this has no effect.
 *
 * @param client        Player's index.
 * @param ...           Flags to remove from the client.
 * @error               Invalid client index, or client not connected.
 */
native void RemoveUserFlags(int client, AdminFlag ...);

/** 
 * Sets access flags on a client using bits instead of flags.  If the
 * client is not an admin, and flags not 0, a temporary, anonymous AdminId is given.
 *
 * @param client        Player's index.
 * @param flags         Bitstring of flags to set on client.
 */
native void SetUserFlagBits(int client, int flags);

/**
 * Returns client access flags.  If the client is not an admin,
 * the result is always 0.
 * 
 * @param client        Player's index.
 * @return              Flags
 * @error               Invalid client index, or client not connected.
 */
native int GetUserFlagBits(int client);

/**
 * Returns whether a user can target another user.
 * This is a helper function for CanAdminTarget.
 *
 * @param client        Player's index.
 * @param target        Target player's index.
 * @return              True if target is targettable by the player, false otherwise.
 * @error               Invalid or unconnected player indexers.
 */
native bool CanUserTarget(int client, int target);

/**
 * Runs through the Core-defined admin authorization checks on a player.
 * Has no effect if the player is already an admin.
 *
 * Note: This function is based on the internal cache only.
 *
 * @param client        Client index.
 * @return              True if access was changed, false if it did not.
 * @error               Invalid client index or client not in-game AND authorized.
 */
native bool RunAdminCacheChecks(int client);

/**
 * Signals that a player has completed post-connection admin checks.
 * Has no effect if the player has already had this event signalled.
 *
 * Note: This must be sent even if no admin id was assigned.
 *
 * @param client        Client index.
 * @error               Invalid client index or client not in-game AND authorized.
 */
native void NotifyPostAdminCheck(int client);

/** 
 * Creates a fake client.
 *
 * @param name          Name to use.
 * @return              Client index on success, 0 otherwise.
 */
native int CreateFakeClient(const char[] name);

/**
 * Sets a convar value on a fake client.
 *
 * @param client        Client index.
 * @param cvar          ConVar name.
 * @param value         ConVar value.
 * @error               Invalid client index, client not connected,
 *                      or client not a fake client.
 */
native void SetFakeClientConVar(int client, const char[] cvar, const char[] value);

/**
 * Returns the client's health.
 *
 * @param client        Player's index.
 * @return              Health value.
 * @error               Invalid client index, client not in game, or no mod support.
 */
native int GetClientHealth(int client);

/**
 * Returns the client's model name.
 *
 * @param client        Player's index.
 * @param model         Buffer to store the client's model name.
 * @param maxlen        Maximum length of string buffer (includes NULL terminator).
 * @error               Invalid client index, client not in game, or no mod support.
 */
native void GetClientModel(int client, char[] model, int maxlen);

/**
 * Returns the client's weapon name.
 *
 * @param client        Player's index.
 * @param weapon        Buffer to store the client's weapon name.
 * @param maxlen        Maximum length of string buffer (includes NULL terminator).
 * @error               Invalid client index, client not in game, or no mod support.
 */
native void GetClientWeapon(int client, char[] weapon, int maxlen);

/**
 * Returns the client's max size vector.
 *
 * @param client        Player's index.
 * @param vec           Destination vector to store the client's max size.
 * @error               Invalid client index, client not in game, or no mod support.
 */
native void GetClientMaxs(int client, float vec[3]);

/**
 * Returns the client's min size vector.
 *
 * @param client        Player's index.
 * @param vec           Destination vector to store the client's min size.
 * @error               Invalid client index, client not in game, or no mod support.
 */
native void GetClientMins(int client, float vec[3]);

/**
 * Returns the client's position angle.
 *
 * @param client        Player's index.
 * @param ang           Destination vector to store the client's position angle.
 * @error               Invalid client index, client not in game, or no mod support.
 */
native void GetClientAbsAngles(int client, float ang[3]);

/**
 * Returns the client's origin vector.
 *
 * @param client        Player's index.
 * @param vec           Destination vector to store the client's origin vector.
 * @error               Invalid client index, client not in game, or no mod support.
 */
native void GetClientAbsOrigin(int client, float vec[3]);

/**
 * Returns the client's armor.
 *
 * @param client        Player's index.
 * @return              Armor value.
 * @error               Invalid client index, client not in game, or no mod support.
 */
native int GetClientArmor(int client);

/**
 * Returns the client's death count.
 *
 * @param client        Player's index.
 * @return              Death count.
 * @error               Invalid client index, client not in game, or no mod support.
 */
native int GetClientDeaths(int client);

/**
 * Returns the client's frag count.
 *
 * @param client        Player's index.
 * @return              Frag count.
 * @error               Invalid client index, client not in game, or no mod support.
 */
native int GetClientFrags(int client);

/**
 * Returns the client's send data rate in bytes/sec.
 *
 * @param client        Player's index.
 * @return              Data rate.
 * @error               Invalid client index, client not connected, or fake client.
 */
native int GetClientDataRate(int client);

/**
 * Returns if a client is timing out
 *
 * @param client        Player's index.
 * @return              True if client is timing out, false otherwise.
 * @error               Invalid client index, client not connected, or fake client.
 */
native bool IsClientTimingOut(int client);

/**
 * Returns the client's connection time in seconds.
 *
 * @param client        Player's index.
 * @return              Connection time.
 * @error               Invalid client index, client not connected, or fake client.
 */
native float GetClientTime(int client);

/**
 * Returns the client's current latency (RTT), more accurate than GetAvgLatency but jittering.
 *
 * @param client        Player's index.
 * @param flow          Traffic flowing direction.
 * @return              Latency, or -1 if network info is not available.
 * @error               Invalid client index, client not connected, or fake client.
 */
native float GetClientLatency(int client, NetFlow flow);

/**
 * Returns the client's average packet latency in seconds.
 *
 * @param client        Player's index.
 * @param flow          Traffic flowing direction.
 * @return              Latency, or -1 if network info is not available.
 * @error               Invalid client index, client not connected, or fake client.
 */
native float GetClientAvgLatency(int client, NetFlow flow);

/**
 * Returns the client's average packet loss, values go from 0 to 1 (for percentages).
 *
 * @param client        Player's index.
 * @param flow          Traffic flowing direction.
 * @return              Average packet loss, or -1 if network info is not available.
 * @error               Invalid client index, client not connected, or fake client.
 */
native float GetClientAvgLoss(int client, NetFlow flow);

/**
 * Returns the client's average packet choke, values go from 0 to 1 (for percentages).
 *
 * @param client        Player's index.
 * @param flow          Traffic flowing direction.
 * @return              Average packet loss, or -1 if network info is not available.
 * @error               Invalid client index, client not connected, or fake client.
 */
native float GetClientAvgChoke(int client, NetFlow flow);

/**
 * Returns the client's data flow in bytes/sec.
 *
 * @param client        Player's index.
 * @param flow          Traffic flowing direction.
 * @return              Data flow.
 * @error               Invalid client index, client not connected, or fake client.
 */
native float GetClientAvgData(int client, NetFlow flow);

/**
 * Returns the client's average packet frequency in packets/sec.
 *
 * @param client        Player's index.
 * @param flow          Traffic flowing direction.
 * @return              Packet frequency.
 * @error               Invalid client index, client not connected, or fake client.
 */
native float GetClientAvgPackets(int client, NetFlow flow);

/**
 * Translates an userid index to the real player index.
 *
 * @param userid        Userid value.
 * @return              Client value.
 * @error               Returns 0 if invalid userid.
 */
native int GetClientOfUserId(int userid);

/**
 * Disconnects a client from the server as soon as the next frame starts.
 *
 * Note: Originally, KickClient() was immediate.  The delay was introduced 
 * because despite warnings, plugins were using it in ways that would crash. 
 * The new safe version can break cases that rely on immediate disconnects, 
 * but ensures that plugins do not accidentally cause crashes.
 *
 * If you need immediate disconnects, use KickClientEx().
 *
 * Note: IsClientInKickQueue() will return true before the kick occurs.
 *
 * @param client        Client index.
 * @param format        Optional formatting rules for disconnect reason.
 *                      Note that a period is automatically appended to the string by the engine.
 * @param ...           Variable number of format parameters.
 * @error               Invalid client index, or client not connected.
 */
native void KickClient(int client, const char[] format="", any ...);

/**
 * Immediately disconnects a client from the server.
 *
 * Kicking clients from certain events or callbacks may cause crashes.  If in 
 * doubt, create a short (0.1 second) timer to kick the client in the next 
 * available frame.
 *
 * @param client        Client index.
 * @param format        Optional formatting rules for disconnect reason.
 *                      Note that a period is automatically appended to the string by the engine.
 * @param ...           Variable number of format parameters.
 * @error               Invalid client index, or client not connected.
 */
native void KickClientEx(int client, const char[] format="", any ...);

/**
 * Changes a client's team through the mod's generic team changing function.
 * On CS:S, this will kill the player.
 *
 * @param client        Client index.
 * @param team          Mod-specific team index.
 * @error               Invalid client index, client not connected, or lack of 
 *                      mod support.
 */
native void ChangeClientTeam(int client, int team);

/**
 * Returns the clients unique serial identifier.
 *
 * @param client        Client index.
 * @return              Serial number.
 * @error               Invalid client index, or client not connected.
 */
native int GetClientSerial(int client);

/**
 * Returns the client index by its serial number.
 *
 * @param serial        Serial number.
 * @return              Client index, or 0 for invalid serial.
 */
native int GetClientFromSerial(int serial);
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _sdktools_client_included
 #endinput
#endif
#define _sdktools_client_included

/**
 * Sets the client to an inactive state waiting for a new map
 *
 * @param client        The client index
 */
native void InactivateClient(int client);

/**
 * Reconnect a client without dropping the netchannel
 *
 * @param client        The client index
 */
native void ReconnectClient(int client);
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */
 
#if defined _commandfilters_included
 #endinput
#endif
#define _commandfilters_included

#define MAX_TARGET_LENGTH           64

#define COMMAND_FILTER_ALIVE        (1<<0)      /**< Only allow alive players */
#define COMMAND_FILTER_DEAD         (1<<1)      /**< Only filter dead players */
#define COMMAND_FILTER_CONNECTED    (1<<2)      /**< Allow players not fully in-game */
#define COMMAND_FILTER_NO_IMMUNITY  (1<<3)      /**< Ignore immunity rules */
#define COMMAND_FILTER_NO_MULTI     (1<<4)      /**< Do not allow multiple target patterns */
#define COMMAND_FILTER_NO_BOTS      (1<<5)      /**< Do not allow bots to be targetted */

#define COMMAND_TARGET_NONE          0          /**< No target was found */
#define COMMAND_TARGET_NOT_ALIVE    -1          /**< Single client is not alive */
#define COMMAND_TARGET_NOT_DEAD     -2          /**< Single client is not dead */
#define COMMAND_TARGET_NOT_IN_GAME  -3          /**< Single client is not in game */
#define COMMAND_TARGET_IMMUNE       -4          /**< Single client is immune */
#define COMMAND_TARGET_EMPTY_FILTER -5          /**< A multi-filter (such as @all) had no targets */
#define COMMAND_TARGET_NOT_HUMAN    -6          /**< Target was not human */
#define COMMAND_TARGET_AMBIGUOUS    -7          /**< Partial name had too many targets */

/**
 * Processes a generic command target string, and resolves it to a list 
 * of clients or one client, based on filtering rules and a pattern.
 *
 * Note that you should use LoadTranslations("common.phrases") in OnPluginStart(), 
 * as that file is guaranteed to contain all of the translatable phrases that 
 * ProcessTargetString() will return.
 *
 * @param pattern       Pattern to find clients against.
 * @param admin         Admin performing the action, or 0 if the server.
 * @param targets       Array to hold targets.
 * @param max_targets   Maximum size of the targets array.
 * @param filter_flags  Filter flags.
 * @param target_name   Buffer to store the target name.
 * @param tn_maxlength  Maximum length of the target name buffer.
 * @param tn_is_ml      OUTPUT: Will be true if the target name buffer is an ML phrase,
 *                      false if it is a normal string.
 * @return              If a multi-target pattern was used, the number of clients found 
 *                      is returned.  If a single-target pattern was used, 1 is returned 
 *                      if one valid client is found.  Otherwise, a COMMAND_TARGET reason 
 *                      for failure is returned.
 */
native int ProcessTargetString(const char[] pattern,
							   int admin, 
							   int[] targets,
							   int max_targets,
							   int filter_flags,
							   char[] target_name,
							   int tn_maxlength,
							   bool &tn_is_ml);

/**
 * Replies to a client with a given message describing a targetting 
 * failure reason.
 *
 * Note: The translation phrases are found in common.phrases.txt.
 *
 * @param client        Client index, or 0 for server.
 * @param reason        COMMAND_TARGET reason.
 */
stock void ReplyToTargetError(int client, int reason)
{
	switch (reason)
	{
		case COMMAND_TARGET_NONE:
		{
			ReplyToCommand(client, "[SM] %t", "No matching client");
		}
		case COMMAND_TARGET_NOT_ALIVE:
		{
			ReplyToCommand(client, "[SM] %t", "Target must be alive");
		}
		case COMMAND_TARGET_NOT_DEAD:
		{
			ReplyToCommand(client, "[SM] %t", "Target must be dead");
		}
		case COMMAND_TARGET_NOT_IN_GAME:
		{
			ReplyToCommand(client, "[SM] %t", "Target is not in game");
		}
		case COMMAND_TARGET_IMMUNE:
		{
			ReplyToCommand(client, "[SM] %t", "Unable to target");
		}
		case COMMAND_TARGET_EMPTY_FILTER:
		{
			ReplyToCommand(client, "[SM] %t", "No matching clients");
		}
		case COMMAND_TARGET_NOT_HUMAN:
		{
			ReplyToCommand(client, "[SM] %t", "Cannot target bot");
		}
		case COMMAND_TARGET_AMBIGUOUS:
		{
			ReplyToCommand(client, "[SM] %t", "More than one client matched");
		}
	}
}

/**
 * Adds clients to a multi-target filter.
 *
 * @param pattern       Pattern name.
 * @param clients       Array to fill with unique, valid client indexes.
 * @return              True if pattern was recognized, false otherwise.
 */
typeset MultiTargetFilter {
	function bool (const char[] pattern, Handle clients);
	function bool (const char[] pattern, ArrayList clients);
}

/**
 * Adds a multi-target filter function for ProcessTargetString().
 *
 * @param pattern       Pattern to match (case sensitive).
 * @param filter        Filter function.
 * @param phrase        Descriptive phrase to display on successful match.
 * @param phraseIsML    True if phrase is multi-lingual, false otherwise.
 */
native void AddMultiTargetFilter(const char[] pattern, MultiTargetFilter filter,
                                 const char[] phrase, bool phraseIsML);

/**
 * Removes a multi-target filter function from ProcessTargetString().
 *
 * @param pattern       Pattern to match (case sensitive).
 * @param filter        Filter function.
 */
native void RemoveMultiTargetFilter(const char[] pattern, MultiTargetFilter filter);
/**
 * vim: set ts=4 sw=4 tw=99 noet :
 * =============================================================================
 * SourceMod (C)2004-2014 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _textparse_included
 #endinput
#endif
#define _textparse_included


/********************************
 * Everything below describes the SMC Parse, or "SourceMod Configuration" format.
 * This parser is entirely event based.  You must hook events to receive data.
 * The file format itself is nearly identical to Valve's KeyValues format.
 ********************************/

/**
 * Parse result directive.
 */
enum SMCResult
{
	SMCParse_Continue,          /**< Continue parsing */
	SMCParse_Halt,              /**< Stop parsing here */
	SMCParse_HaltFail           /**< Stop parsing and return failure */
};

/**
 * Parse error codes.
 */
enum SMCError
{
	SMCError_Okay = 0,          /**< No error */
	SMCError_StreamOpen,        /**< Stream failed to open */
	SMCError_StreamError,       /**< The stream died... somehow */
	SMCError_Custom,            /**< A custom handler threw an error */
	SMCError_InvalidSection1,   /**< A section was declared without quotes, and had extra tokens */
	SMCError_InvalidSection2,   /**< A section was declared without any header */
	SMCError_InvalidSection3,   /**< A section ending was declared with too many unknown tokens */
	SMCError_InvalidSection4,   /**< A section ending has no matching beginning */
	SMCError_InvalidSection5,   /**< A section beginning has no matching ending */
	SMCError_InvalidTokens,     /**< There were too many unidentifiable strings on one line */
	SMCError_TokenOverflow,     /**< The token buffer overflowed */
	SMCError_InvalidProperty1   /**< A property was declared outside of any section */
};

/**
 * Called when parsing is started.
 *
 * @param smc           The SMC Parse Handle.
 */
typedef SMC_ParseStart = function void (SMCParser smc);

/**
 * Called when the parser is entering a new section or sub-section.
 *
 * Note: Enclosing quotes are always stripped.
 *
 * @param smc           The SMC Parser.
 * @param name          String containing section name.
 * @param opt_quotes    True if the section name was quote-enclosed in the file.
 * @return              An SMCResult action to take.
 */
typedef SMC_NewSection = function SMCResult (SMCParser smc, const char[] name, bool opt_quotes);

/**
 * Called when the parser finds a new key/value pair.
 *
 * Note: Enclosing quotes are always stripped.
 *
 * @param smc           The SMCParser.
 * @param key           String containing key name.
 * @param value         String containing value name.
 * @param key_quotes    Whether or not the key was enclosed in quotes.
 * @param value_quotes  Whether or not the value was enclosed in quotes.
 * @return              An SMCResult action to take.
 */
typedef SMC_KeyValue = function SMCResult (SMCParser smc, const char[] key, const char[] value, bool key_quotes, bool value_quotes);

/** Called when the parser finds the end of the current section.
 *
 * @param smc           The SMCParser.
 * @return              An SMCResult action to take.
 */
typedef SMC_EndSection = function SMCResult (SMCParser smc);

/**
 * Called when parsing is halted.
 *
 * @param smc           The SMCParser.
 * @param halted        True if abnormally halted, false otherwise.
 * @param failed        True if parsing failed, false otherwise.
 */
typedef SMC_ParseEnd = function void (SMCParser smc, bool halted, bool failed);

/**
 * Callback for whenever a new line of text is about to be parsed.
 *
 * @param smc           The SMCParser.
 * @param line          A string containing the raw line from the file.
 * @param lineno        The line number it occurs on.
 * @return              An SMCResult action to take.
 */
typedef SMC_RawLine = function SMCResult (SMCParser smc, const char[] line, int lineno);

// An SMCParser is a callback-driven parser for SourceMod configuration files.
// SMC files are similar to Valve KeyValues format, with two key differences:
//  (1) SMC cannot handle single-item entries (that is, a key with no value).
//  (2) SMC files can have multi-line comment blocks, whereas KeyValues cannot.
methodmap SMCParser < Handle
{
	// Create a new SMC file format parser.
	public native SMCParser();

	// Parses an SMC file.
	//
	// @param file          A string containing the file path.
	// @param line          An optional variable to store the last line number read.
	// @param col           An optional variable to store the last column number read.
	// @return              An SMCParseError result.
	public native SMCError ParseFile(const char[] file, int &line = 0, int &col = 0);

	// Sets the callback for receiving SMC_ParseStart events.
	property SMC_ParseStart OnStart {
		public native set(SMC_ParseStart func);
	}

	// Sets the callback for receiving SMC_ParseEnd events.
	property SMC_ParseEnd OnEnd {
		public native set(SMC_ParseEnd func);
	}

	// Sets the callback for receiving SMC_NewSection events.
	property SMC_NewSection OnEnterSection {
		public native set(SMC_NewSection func);
	}

	// Sets the callback for receiving SMC_EndSection events.
	property SMC_EndSection OnLeaveSection {
		public native set(SMC_EndSection func);
	}

	// Sets the callback for receiving SMC_KeyValue events.
	property SMC_KeyValue OnKeyValue {
		public native set(SMC_KeyValue func);
	}

	// Sets the callback for receiving SMC_RawLine events.
	property SMC_RawLine OnRawLine {
		public native set(SMC_RawLine func);
	}

	// Gets an error string for an SMCError code.
	//
	// @param error         The SMCParseError code.
	// @param buffer        A string buffer for the error (contents undefined on failure).
	// @param buf_max       The maximum size of the buffer.
	// @return              The number of characters written to buffer.
	public native void GetErrorString(SMCError error, char[] buffer, int buf_max);
};

/**
 * Creates a new SMC file format parser.  This is used to set parse hooks.
 *
 * @return              A new Handle to an SMC Parse structure.
 */
native SMCParser SMC_CreateParser();

/**
 * Parses an SMC file.
 *
 * @param smc           A Handle to an SMC Parse structure.
 * @param file          A string containing the file path.
 * @param line          An optional by reference cell to store the last line number read.
 * @param col           An optional by reference cell to store the last column number read.
 * @return              An SMCParseError result.
 * @error               Invalid or corrupt Handle.
 */
native SMCError SMC_ParseFile(Handle smc, const char[] file, int &line=0, int &col=0);

/**
 * Gets an error string for an SMCError code.
 *
 * @note SMCError_Okay returns false.
 * @note SMCError_Custom (which is thrown on SMCParse_HaltFail) returns false.
 *
 * @param error         The SMCParseError code.
 * @param buffer        A string buffer for the error (contents undefined on failure).
 * @param buf_max       The maximum size of the buffer.
 * @return              True on success, false otherwise.
 */
native bool SMC_GetErrorString(SMCError error, char[] buffer, int buf_max);

/**
 * Sets the SMC_ParseStart function of a parse Handle.
 *
 * @param smc           Handle to an SMC Parse.
 * @param func          SMC_ParseStart function.
 * @error               Invalid or corrupt Handle.
 */
native void SMC_SetParseStart(Handle smc, SMC_ParseStart func);

/**
 * Sets the SMC_ParseEnd of a parse handle.
 *
 * @param smc           Handle to an SMC Parse.
 * @param func          SMC_ParseEnd function.
 * @error               Invalid or corrupt Handle.
 */
native void SMC_SetParseEnd(Handle smc, SMC_ParseEnd func);

/**
 * Sets the three main reader functions.
 *
 * @param smc           An SMC parse Handle.
 * @param ns            An SMC_NewSection function pointer.
 * @param kv            An SMC_KeyValue function pointer.
 * @param es            An SMC_EndSection function pointer.
 */
native void SMC_SetReaders(Handle smc, SMC_NewSection ns, SMC_KeyValue kv, SMC_EndSection es);

/**
 * Sets a raw line reader on an SMC parser Handle.
 *
 * @param smc           Handle to an SMC Parse.
 * @param func          SMC_RawLine function.
 */
native void SMC_SetRawLine(Handle smc, SMC_RawLine func);
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _eventsmsgs_included
 #endinput
#endif
#define _eventsmsgs_included

/**
 * UserMsg helper values.
 */
enum UserMsg
{
	INVALID_MESSAGE_ID = -1
};

/**
 * UserMsg message serialization formats
 */
enum UserMessageType
{
	UM_BitBuf = 0,
	UM_Protobuf
};

/**
 * @section Message Flags.
 */
#define USERMSG_RELIABLE        (1<<2)    /**< Message will be set on the reliable stream */
#define USERMSG_INITMSG         (1<<3)    /**< Message will be considered to be an initmsg */
#define USERMSG_BLOCKHOOKS      (1<<7)    /**< Prevents the message from triggering SourceMod and Metamod hooks */

/**
 * @endsection
 */

/**
 * Returns usermessage serialization type used for the current engine
 *
 * @return              The supported usermessage type.
 */
native UserMessageType GetUserMessageType();

stock Protobuf UserMessageToProtobuf(Handle msg)
{
	if (GetUserMessageType() != UM_Protobuf)
	{
		return null;
	}

	return view_as<Protobuf>(msg);
}

// Make sure to only call this on writable buffers (eg from StartMessage).
stock BfWrite UserMessageToBfWrite(Handle msg)
{
	if (GetUserMessageType() == UM_Protobuf)
	{
		return null;
	}

	return view_as<BfWrite>(msg);
}

// Make sure to only call this on readable buffers (eg from a message hook).
stock BfRead UserMessageToBfRead(Handle msg)
{
	if (GetUserMessageType() == UM_Protobuf)
	{
		return null;
	}
	
	return view_as<BfRead>(msg);
}

/**
 * Returns the ID of a given message, or -1 on failure.
 *
 * @param msg           String containing message name (case sensitive).
 * @return              A message index, or INVALID_MESSAGE_ID on failure.
 */
native UserMsg GetUserMessageId(const char[] msg);

/**
 * Retrieves the name of a message by ID.
 *
 * @param msg_id        Message index.
 * @param msg           Buffer to store the name of the message.
 * @param maxlength     Maximum length of string buffer.
 * @return              True if message index is valid, false otherwise.
 */
native bool GetUserMessageName(UserMsg msg_id, char[] msg, int maxlength);

/**
 * Starts a usermessage (network message).
 *
 * @note Only one message can be active at a time.
 * @note It is illegal to send any message while a non-intercept hook is in progress.
 *
 * @param msgname       Message name to start.
 * @param clients       Array containing player indexes to broadcast to.
 * @param numClients    Number of players in the array.
 * @param flags         Optional flags to set.
 * @return              A handle to a bf_write bit packing structure, or
 *                      INVALID_HANDLE on failure.
 * @error               Invalid message name, unable to start a message, invalid client,
 *                      or client not connected.
 */
native Handle StartMessage(const char[] msgname, const int[] clients, int numClients, int flags=0);

/**
 * Starts a usermessage (network message).
 *
 * @note Only one message can be active at a time.
 * @note It is illegal to send any message while a non-intercept hook is in progress.
 *
 * @param msg           Message index to start.
 * @param clients       Array containing player indexes to broadcast to.
 * @param numClients    Number of players in the array.
 * @param flags         Optional flags to set.
 * @return              A handle to a bf_write bit packing structure, or
 *                      INVALID_HANDLE on failure.
 * @error               Invalid message name, unable to start a message, invalid client,
 *                      or client not connected.
 */
native Handle StartMessageEx(UserMsg msg, const int[] clients, int numClients, int flags=0);

/**
 * Ends a previously started user message (network message).
 */
native void EndMessage();

/**
 * Hook function types for user messages.
*/
typeset MsgHook
{
	/**
	 * Called when a bit buffer based usermessage is hooked
	 *
	 * @param msg_id        Message index.
	 * @param msg           Handle to the input bit buffer.
	 * @param players       Array containing player indexes.
	 * @param playersNum    Number of players in the array.
	 * @param reliable      True if message is reliable, false otherwise.
	 * @param init          True if message is an initmsg, false otherwise.
	 * @return              Ignored for normal hooks.  For intercept hooks, Plugin_Handled
	 *                      blocks the message from being sent, and Plugin_Continue
	 *                      resumes normal functionality.
	 */
	function Action (UserMsg msg_id, BfRead msg, const int[] players, int playersNum, bool reliable, bool init);
	/**
	 * Called when a protobuf based usermessage is hooked
	 *
	 * @param msg_id        Message index.
	 * @param msg           Handle to the input protobuf.
	 * @param players       Array containing player indexes.
	 * @param playersNum    Number of players in the array.
	 * @param reliable      True if message is reliable, false otherwise.
	 * @param init          True if message is an initmsg, false otherwise.
	 * @return              Ignored for normal hooks.  For intercept hooks, Plugin_Handled
	 *                      blocks the message from being sent, and Plugin_Continue
	 *                      resumes normal functionality.
	 */
	function Action (UserMsg msg_id, Protobuf msg, const int[] players, int playersNum, bool reliable, bool init);
};

/**
 * Called when a message hook has completed.
 *
 * @param msg_id        Message index.
 * @param sent          True if message was sent, false if blocked.
 */
typedef MsgPostHook = function void (UserMsg msg_id, bool sent);

/**
 * Hooks a user message.
 *
 * @param msg_id        Message index.
 * @param hook          Function to use as a hook.
 * @param intercept     If intercept is true, message will be fully intercepted,
 *                      allowing the user to block the message.  Otherwise,
 *                      the hook is normal and ignores the return value.
 * @param post          Notification function.
 * @error               Invalid message index.
 */
native void HookUserMessage(UserMsg msg_id, MsgHook hook, bool intercept=false, MsgPostHook post=INVALID_FUNCTION);

/**
 * Removes one usermessage hook.
 *
 * @param msg_id        Message index.
 * @param hook          Function used for the hook.
 * @param intercept     Specifies whether the hook was an intercept hook or not.
 * @error               Invalid message index.
 */
native void UnhookUserMessage(UserMsg msg_id, MsgHook hook, bool intercept=false);

/**
 * Starts a usermessage (network message) that broadcasts to all clients.
 *
 * @note See StartMessage or StartMessageEx().
 *
 * @param msgname       Message name to start.
 * @param flags         Optional flags to set.
 * @return              A handle to a bf_write bit packing structure, or
 *                      INVALID_HANDLE on failure.
 */
stock Handle StartMessageAll(const char[] msgname, int flags=0)
{
	int total = 0;
	int[] clients = new int[MaxClients];
	for (int i = 1; i <= MaxClients; i++)
	{
		if (IsClientConnected(i))
		{
			clients[total++] = i;
		}
	}

	return StartMessage(msgname, clients, total, flags);
}

/**
 * Starts a simpler usermessage (network message) for one client.
 *
 * @note See StartMessage or StartMessageEx().
 *
 * @param msgname       Message name to start.
 * @param client        Client to send to.
 * @param flags         Optional flags to set.
 * @return              A handle to a bf_write bit packing structure, or
 *                      INVALID_HANDLE on failure.
 */
stock Handle StartMessageOne(const char[] msgname, int client, int flags=0)
{
	int players[1];
	players[0] = client;

	return StartMessage(msgname, players, 1, flags);
}
/**
 * vim: set ts=4 sw=4 tw=99 noet :
 * =============================================================================
 * SourceMod (C)2004-2014 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _convars_included
 #endinput
#endif
#define _convars_included

/**
 * Console variable bound values used with Get/SetConVarBounds()
 */
enum ConVarBounds
{
	ConVarBound_Upper = 0,
	ConVarBound_Lower
};

/**
 * Console variable query result values.
 */
enum ConVarQueryResult
{
	ConVarQuery_Okay = 0,               //< Retrieval of client convar value was successful. */
	ConVarQuery_NotFound,               //< Client convar was not found. */
	ConVarQuery_NotValid,               //< A console command with the same name was found, but there is no convar. */
	ConVarQuery_Protected               //< Client convar was found, but it is protected. The server cannot retrieve its value. */
};

/**
 * Called when a console variable's value is changed.
 * 
 * @param convar        Handle to the convar that was changed.
 * @param oldValue      String containing the value of the convar before it was changed.
 * @param newValue      String containing the new value of the convar.
 */
typedef ConVarChanged = function void (ConVar convar, const char[] oldValue, const char[] newValue);

/**
 * Creates a new console variable.
 *
 * @param name          Name of new convar.
 * @param defaultValue  String containing the default value of new convar.
 * @param description   Optional description of the convar.
 * @param flags         Optional bitstring of flags determining how the convar should be handled. See FCVAR_* constants for more details.
 * @param hasMin        Optional boolean that determines if the convar has a minimum value.
 * @param min           Minimum floating point value that the convar can have if hasMin is true.
 * @param hasMax        Optional boolean that determines if the convar has a maximum value.
 * @param max           Maximum floating point value that the convar can have if hasMax is true.
 * @return              A handle to the newly created convar. If the convar already exists, a handle to it will still be returned.
 * @error               Convar name is blank or is the same as an existing console command.
 */
native ConVar CreateConVar(
	const char[] name,
	const char[] defaultValue,
	const char[] description="",
	int flags=0,
	bool hasMin=false, float min=0.0,
	bool hasMax=false, float max=0.0);

/**
 * Searches for a console variable.
 *
 * @param name          Name of convar to find.
 * @return              A ConVar object if found; null otherwise.
 */
native ConVar FindConVar(const char[] name);

// A ConVar is a configurable, named setting in the srcds console.
methodmap ConVar < Handle
{
	// Retrieves or sets a boolean value for the convar.
	property bool BoolValue {
		public native get();
		public native set(bool b);
	}

	// Retrieves or sets an integer value for the convar.
	property int IntValue {
		public native get();
		public native set(int value);
	}

	// Retrieves or sets a float value for the convar.
	property float FloatValue {
		public native get();
		public native set(float value);
	}

	// Gets or sets the flag bits (FCVAR_*) on the convar.
	property int Flags {
		public native get();
		public native set(int flags);
	}

	// Sets the boolean value of a console variable.
	//
	// Note: The replicate and notify params are only relevant for the
	// original, Dark Messiah, and Episode 1 engines. Newer engines
	// automatically do these things when the convar value is changed.
	//
	// @param value     New boolean value.
	// @param replicate If set to true, the new convar value will be set on all clients.
	//                  This will only work if the convar has the FCVAR_REPLICATED flag
	//                  and actually exists on clients.
	// @param notify    If set to true, clients will be notified that the convar has changed.
	//                  This will only work if the convar has the FCVAR_NOTIFY flag.
	public native void SetBool(bool value, bool replicate=false, bool notify=false);

	// Sets the integer value of a console variable.
	//
	// Note: The replicate and notify params are only relevant for the
	// original, Dark Messiah, and Episode 1 engines. Newer engines
	// automatically do these things when the convar value is changed.
	//
	// @param value     New integer value.
	// @param replicate If set to true, the new convar value will be set on all clients.
	//                  This will only work if the convar has the FCVAR_REPLICATED flag
	//                  and actually exists on clients.
	// @param notify    If set to true, clients will be notified that the convar has changed.
	//                  This will only work if the convar has the FCVAR_NOTIFY flag.
	public native void SetInt(int value, bool replicate=false, bool notify=false);

	// Sets the floating point value of a console variable.
	//
	// Note: The replicate and notify params are only relevant for the
	// original, Dark Messiah, and Episode 1 engines. Newer engines
	// automatically do these things when the convar value is changed.
	//
	// @param value     New floating point value.
	// @param replicate If set to true, the new convar value will be set on all clients.
	//                  This will only work if the convar has the FCVAR_REPLICATED flag
	//                  and actually exists on clients.
	// @param notify    If set to true, clients will be notified that the convar has changed.
	//                  This will only work if the convar has the FCVAR_NOTIFY flag.
	public native void SetFloat(float value, bool replicate=false, bool notify=false);

	// Retrieves the string value of a console variable.
	//
	// @param convar     Handle to the convar.
	// @param value      Buffer to store the value of the convar.
	// @param maxlength  Maximum length of string buffer.
	public native void GetString(char[] value, int maxlength);

	// Sets the string value of a console variable.
	//
	// Note: The replicate and notify params are only relevant for the
	// original, Dark Messiah, and Episode 1 engines. Newer engines
	// automatically do these things when the convar value is changed.
	//
	// @param value      New string value.
	// @param replicate  If set to true, the new convar value will be set on all clients.
	//                   This will only work if the convar has the FCVAR_REPLICATED flag
	//                   and actually exists on clients.
	// @param notify     If set to true, clients will be notified that the convar has changed.
	//                   This will only work if the convar has the FCVAR_NOTIFY flag.
	public native void SetString(const char[] value, bool replicate=false, bool notify=false);

	// Resets the console variable to its default value.
	//
	// Note: The replicate and notify params are only relevant for the
	// original, Dark Messiah, and Episode 1 engines. Newer engines
	// automatically do these things when the convar value is changed.
	//
	// @param replicate  If set to true, the new convar value will be set on all clients.
	//                   This will only work if the convar has the FCVAR_REPLICATED flag
	//                   and actually exists on clients.
	// @param notify     If set to true, clients will be notified that the convar has changed.
	//                   This will only work if the convar has the FCVAR_NOTIFY flag.
	public native void RestoreDefault(bool replicate=false, bool notify=false);

	// Retrieves the default string value of a console variable.
	//
	// @param value      Buffer to store the default value of the convar.
	// @param maxlength  Maximum length of string buffer.
	// @return           Number of bytes written to the buffer (UTF-8 safe).
	public native int GetDefault(char[] value, int maxlength);

	// Retrieves the specified bound of a console variable.
	//
	// @param type       Type of bound to retrieve, ConVarBound_Lower or ConVarBound_Upper.
	// @param value      By-reference cell to store the specified floating point bound value.
	// @return           True if the convar has the specified bound set, false otherwise.
	public native bool GetBounds(ConVarBounds type, float &value);

	// Sets the specified bound of a console variable.
	//
	// @param type       Type of bound to set, ConVarBound_Lower or ConVarBound_Upper
	// @param set        If set to true, convar will use specified bound. If false, bound will be removed.
	// @param value      Floating point value to use as the specified bound.
	public native void SetBounds(ConVarBounds type, bool set, float value=0.0);

	// Retrieves the name of a console variable.
	//
	// @param name       Buffer to store the name of the convar.
	// @param maxlength  Maximum length of string buffer.
	public native void GetName(char[] name, int maxlength);

	// Replicates a convar value to a specific client. This does not change the actual convar value.
	//
	// @param client     Client index
	// @param value      String value to send
	// @return           True on success, false on failure
	// @error            Invalid client index, client not in game, or client is fake
	public native bool ReplicateToClient(int client, const char[] value);

	// Creates a hook for when a console variable's value is changed.
	//
	// @param callback  An OnConVarChanged function pointer.
	public native void AddChangeHook(ConVarChanged callback);

	// Removes a hook for when a console variable's value is changed.
	//
	// @param convar    Handle to the convar.
	// @param callback  An OnConVarChanged function pointer.
	// @error           No active hook on convar.
	public native void RemoveChangeHook(ConVarChanged callback);
}

/**
 * Creates a hook for when a console variable's value is changed.
 *
 * @param convar        Handle to the convar.
 * @param callback      An OnConVarChanged function pointer.
 * @error               Invalid or corrupt Handle or invalid callback function.
 */
native void HookConVarChange(Handle convar, ConVarChanged callback);

/**
 * Removes a hook for when a console variable's value is changed.
 *
 * @param convar        Handle to the convar.
 * @param callback      An OnConVarChanged function pointer.
 * @error               Invalid or corrupt Handle, invalid callback function, or no active hook on convar.
 */
native void UnhookConVarChange(Handle convar, ConVarChanged callback);

/**
 * Returns the boolean value of a console variable.
 *
 * @param convar        Handle to the convar.
 * @return              The boolean value of the convar.
 * @error               Invalid or corrupt Handle.
 */
native bool GetConVarBool(Handle convar);

/**
 * Sets the boolean value of a console variable.
 *
 * Note: The replicate and notify params are only relevant for the original, Dark Messiah, and
 * Episode 1 engines. Newer engines automatically do these things when the convar value is changed.
 *
 * @param convar        Handle to the convar.
 * @param value         New boolean value.
 * @param replicate     If set to true, the new convar value will be set on all clients.
 *                      This will only work if the convar has the FCVAR_REPLICATED flag
 *                      and actually exists on clients.
 * @param notify        If set to true, clients will be notified that the convar has changed.
 *                      This will only work if the convar has the FCVAR_NOTIFY flag.
 * @error               Invalid or corrupt Handle.
 */
native void SetConVarBool(Handle convar, bool value, bool replicate=false, bool notify=false);

/**
 * Returns the integer value of a console variable.
 *
 * @param convar        Handle to the convar.
 * @return              The integer value of the convar.
 * @error               Invalid or corrupt Handle.
 */
native int GetConVarInt(Handle convar);

/**
 * Sets the integer value of a console variable.
 *
 * Note: The replicate and notify params are only relevant for the original, Dark Messiah, and
 * Episode 1 engines. Newer engines automatically do these things when the convar value is changed.
 *
 * @param convar        Handle to the convar.
 * @param value         New integer value.
 * @param replicate     If set to true, the new convar value will be set on all clients.
 *                      This will only work if the convar has the FCVAR_REPLICATED flag
 *                      and actually exists on clients.
 * @param notify        If set to true, clients will be notified that the convar has changed.
 *                      This will only work if the convar has the FCVAR_NOTIFY flag.
 * @error               Invalid or corrupt Handle.
 */
native void SetConVarInt(Handle convar, int value, bool replicate=false, bool notify=false);

/**
 * Returns the floating point value of a console variable.
 *
 * @param convar        Handle to the convar.
 * @return              The floating point value of the convar.
 * @error               Invalid or corrupt Handle.
 */
native float GetConVarFloat(Handle convar);

/**
 * Sets the floating point value of a console variable.
 *
 * Note: The replicate and notify params are only relevant for the original, Dark Messiah, and
 * Episode 1 engines. Newer engines automatically do these things when the convar value is changed.
 *
 * @param convar        Handle to the convar.
 * @param value         New floating point value.
 * @param replicate     If set to true, the new convar value will be set on all clients.
 *                      This will only work if the convar has the FCVAR_REPLICATED flag
 *                      and actually exists on clients.
 * @param notify        If set to true, clients will be notified that the convar has changed.
 *                      This will only work if the convar has the FCVAR_NOTIFY flag.
 * @error               Invalid or corrupt Handle.
 */
native void SetConVarFloat(Handle convar, float value, bool replicate=false, bool notify=false);

/**
 * Retrieves the string value of a console variable.
 *
 * @param convar        Handle to the convar.
 * @param value         Buffer to store the value of the convar.
 * @param maxlength     Maximum length of string buffer.
 * @error               Invalid or corrupt Handle.     
 */
native void GetConVarString(Handle convar, char[] value, int maxlength);

/**
 * Sets the string value of a console variable.
 *
 * Note: The replicate and notify params are only relevant for the original, Dark Messiah, and
 * Episode 1 engines. Newer engines automatically do these things when the convar value is changed.
 *
 * @param convar        Handle to the convar.
 * @param value         New string value.
 * @param replicate     If set to true, the new convar value will be set on all clients.
 *                      This will only work if the convar has the FCVAR_REPLICATED flag
 *                      and actually exists on clients.
 * @param notify        If set to true, clients will be notified that the convar has changed.
 *                      This will only work if the convar has the FCVAR_NOTIFY flag.
 * @error               Invalid or corrupt Handle.
 */
native void SetConVarString(Handle convar, const char[] value, bool replicate=false, bool notify=false);

/**
 * Resets the console variable to its default value.
 *
 * Note: The replicate and notify params are only relevant for the original, Dark Messiah, and
 * Episode 1 engines. Newer engines automatically do these things when the convar value is changed.
 *
 * @param convar        Handle to the convar.
 * @param replicate     If set to true, the new convar value will be set on all clients.
 *                      This will only work if the convar has the FCVAR_REPLICATED flag
 *                      and actually exists on clients.
 * @param notify        If set to true, clients will be notified that the convar has changed.
 *                      This will only work if the convar has the FCVAR_NOTIFY flag.
 * @error               Invalid or corrupt Handle.
 */
native void ResetConVar(Handle convar, bool replicate=false, bool notify=false);

/**
 * Retrieves the default string value of a console variable.
 *
 * @param convar        Handle to the convar.
 * @param value         Buffer to store the default value of the convar.
 * @param maxlength     Maximum length of string buffer.
 * @return              Number of bytes written to the buffer (UTF-8 safe).
 * @error               Invalid or corrupt Handle.
 */
native int GetConVarDefault(Handle convar, char[] value, int maxlength);

/**
 * Returns the bitstring of flags on a console variable.
 *
 * @param convar        Handle to the convar.
 * @return              A bitstring containing the FCVAR_* flags that are enabled.
 * @error               Invalid or corrupt Handle.
 */
native int GetConVarFlags(Handle convar);

/**
 * Sets the bitstring of flags on a console variable.
 *
 * @param convar        Handle to the convar.
 * @param flags         A bitstring containing the FCVAR_* flags to enable.
 * @error               Invalid or corrupt Handle.
 */
native void SetConVarFlags(Handle convar, int flags);

/**
 * Retrieves the specified bound of a console variable.
 *
 * @param convar        Handle to the convar.
 * @param type          Type of bound to retrieve, ConVarBound_Lower or ConVarBound_Upper.
 * @param value         By-reference cell to store the specified floating point bound value.
 * @return              True if the convar has the specified bound set, false otherwise.
 * @error               Invalid or corrupt Handle.
 */
native bool GetConVarBounds(Handle convar, ConVarBounds type, float &value);

/**
 * Sets the specified bound of a console variable.
 *
 * @param convar        Handle to the convar.
 * @param type          Type of bound to set, ConVarBound_Lower or ConVarBound_Upper
 * @param set           If set to true, convar will use specified bound. If false, bound will be removed.
 * @param value         Floating point value to use as the specified bound.
 * @error               Invalid or corrupt Handle.
 */
native void SetConVarBounds(Handle convar, ConVarBounds type, bool set, float value=0.0);

/**
 * Retrieves the name of a console variable.
 *
 * @param convar        Handle to the convar.
 * @param name          Buffer to store the name of the convar.
 * @param maxlength     Maximum length of string buffer.
 * @error               Invalid or corrupt Handle.     
 */
native void GetConVarName(Handle convar, char[] name, int maxlength);

/**
 * Replicates a convar value to a specific client. This does not change the actual convar value.
 *
 * @param client        Client index
 * @param convar        ConVar handle
 * @param value         String value to send
 * @return              True on success, false on failure
 * @error               Invalid client index, client not in game, or client is fake
 */
native bool SendConVarValue(int client, Handle convar, const char[] value);

typeset ConVarQueryFinished
{	
	// Called when a query to retrieve a client's console variable has finished.
	//
	// @param cookie        Unique identifier of query.
	// @param client        Player index.
	// @param result        Result of query that tells one whether or not query was successful.
	//                      See ConVarQueryResult enum for more details.
	// @param convarName    Name of client convar that was queried.
	// @param convarValue   Value of client convar that was queried if successful. This will be "" if it was not.
	// @param value         Value that was passed when query was started.
	function void (QueryCookie cookie, int client, ConVarQueryResult result, const char[] cvarName, const char[] cvarValue, any value);
	
	// Called when a query to retrieve a client's console variable has finished.
	//
	// @param cookie        Unique identifier of query.
	// @param client        Player index.
	// @param result        Result of query that tells one whether or not query was successful.
	//                      See ConVarQueryResult enum for more details.
	// @param convarName    Name of client convar that was queried.
	// @param convarValue   Value of client convar that was queried if successful. This will be "" if it was not.
	function void (QueryCookie cookie, int client, ConVarQueryResult result, const char[] cvarName, const char[] cvarValue);
};

/**
 * Starts a query to retrieve the value of a client's console variable.
 *
 * @param client        Player index.
 * @param cvarName      Name of client convar to query.
 * @param callback      A function to use as a callback when the query has finished.
 * @param value         Optional value to pass to the callback function.
 * @return              A cookie that uniquely identifies the query. 
 *                      Returns QUERYCOOKIE_FAILED on failure, such as when used on a bot.
 */
native QueryCookie QueryClientConVar(int client, const char[] cvarName, ConVarQueryFinished callback, any value=0);

/**
 * Returns true if the supplied character is valid in a ConVar name.
 *
 * @param c             Character to validate.
 * @return              True is valid for ConVars, false otherwise
 */
stock bool IsValidConVarChar(int c)
{
	return (c == '_' || IsCharAlpha(c) || IsCharNumeric(c));
}
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2016 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _halflife_included
 #endinput
#endif
#define _halflife_included

#define SOURCE_SDK_UNKNOWN           0      /**< Could not determine the engine version */
#define SOURCE_SDK_ORIGINAL         10      /**< Original Source engine (still used by "The Ship") */
#define SOURCE_SDK_DARKMESSIAH      15      /**< Modified version of original engine used by Dark Messiah (no SDK) */
#define SOURCE_SDK_EPISODE1         20      /**< SDK+Engine released after Episode 1 */
#define SOURCE_SDK_EPISODE2         30      /**< SDK+Engine released after Episode 2/Orange Box */
#define SOURCE_SDK_BLOODYGOODTIME   32      /**< Modified version of ep2 engine used by Bloody Good Time (no SDK) */
#define SOURCE_SDK_EYE              33      /**< Modified version of ep2 engine used by E.Y.E Divine Cybermancy (no SDK) */
#define SOURCE_SDK_CSS              34      /**< Sometime-older version of Source 2009 SDK+Engine, used for Counter-Strike: Source */
#define SOURCE_SDK_EPISODE2VALVE    35      /**< SDK+Engine released after Episode 2/Orange Box, "Source 2009" or "Source MP" */
#define SOURCE_SDK_LEFT4DEAD        40      /**< Engine released after Left 4 Dead (no SDK yet) */
#define SOURCE_SDK_LEFT4DEAD2       50      /**< Engine released after Left 4 Dead 2 (no SDK yet) */
#define SOURCE_SDK_ALIENSWARM       60      /**< SDK+Engine released after Alien Swarm */
#define SOURCE_SDK_CSGO             80      /**< Engine released after CS:GO (no SDK yet) */
#define SOURCE_SDK_DOTA             90      /**< Engine released after Dota 2 (no SDK) */

#define MOTDPANEL_TYPE_TEXT          0      /**< Treat msg as plain text */
#define MOTDPANEL_TYPE_INDEX         1      /**< Msg is auto determined by the engine */
#define MOTDPANEL_TYPE_URL           2      /**< Treat msg as an URL link */
#define MOTDPANEL_TYPE_FILE          3      /**< Treat msg as a filename to be opened */

enum DialogType
{
	DialogType_Msg = 0,     /**< just an on screen message */
	DialogType_Menu,        /**< an options menu */
	DialogType_Text,        /**< a richtext dialog */
	DialogType_Entry,       /**< an entry box */
	DialogType_AskConnect   /**< ask the client to connect to a specified IP */
};

enum EngineVersion
{
	Engine_Unknown,             /**< Could not determine the engine version */
	Engine_Original,            /**< Original Source Engine (used by The Ship) */
	Engine_SourceSDK2006,       /**< Episode 1 Source Engine (second major SDK) */
	Engine_SourceSDK2007,       /**< Orange Box Source Engine (third major SDK) */
	Engine_Left4Dead,           /**< Left 4 Dead */
	Engine_DarkMessiah,         /**< Dark Messiah Multiplayer (based on original engine) */
	Engine_Left4Dead2 = 7,      /**< Left 4 Dead 2 */
	Engine_AlienSwarm,          /**< Alien Swarm (and Alien Swarm SDK) */
	Engine_BloodyGoodTime,      /**< Bloody Good Time */
	Engine_EYE,                 /**< E.Y.E Divine Cybermancy */
	Engine_Portal2,             /**< Portal 2 */
	Engine_CSGO,                /**< Counter-Strike: Global Offensive */
	Engine_CSS,                 /**< Counter-Strike: Source */
	Engine_DOTA,                /**< Dota 2 */
	Engine_HL2DM,               /**< Half-Life 2 Deathmatch */
	Engine_DODS,                /**< Day of Defeat: Source */
	Engine_TF2,                 /**< Team Fortress 2 */
	Engine_NuclearDawn,         /**< Nuclear Dawn */
	Engine_SDK2013,             /**< Source SDK 2013 */
	Engine_Blade,               /**< Blade Symphony */
	Engine_Insurgency,          /**< Insurgency (2013 Retail version)*/
	Engine_Contagion,           /**< Contagion */
	Engine_BlackMesa,           /**< Black Mesa Multiplayer */
	Engine_DOI                  /**< Day of Infamy */
};

enum FindMapResult
{
	// A direct match for this name was found
	FindMap_Found,
	// No match for this map name could be found.
	FindMap_NotFound,
	// A fuzzy match for this map name was found.
	// Ex: cp_dust -> cp_dustbowl, c1m1 -> c1m1_hotel
	// Only supported for maps that the engine knows about. (This excludes workshop maps on Orangebox).
	FindMap_FuzzyMatch,
	// A non-canonical match for this map name was found.
	// Ex: workshop/1234 -> workshop/cp_qualified_name.ugc1234
	// Only supported on "Orangebox" games with workshop support.
	FindMap_NonCanonical,
	// No currently available match for this map name could be found, but it may be possible to load
	// Only supported on "Orangebox" games with workshop support.
	FindMap_PossiblyAvailable
};

#define INVALID_ENT_REFERENCE 0xFFFFFFFF

/**
 * Logs a generic message to the HL2 logs.
 *
 * @param format        String format.
 * @param ...           Format arguments.
 */
native void LogToGame(const char[] format, any ...);

/**
 * Sets the seed value for the global Half-Life 2 Random Stream.
 *
 * @param seed         Seed value.
 */
native void SetRandomSeed(int seed);

/**
 * Returns a random floating point number from the Half-Life 2 Random Stream.
 *
 * @param fMin          Minimum random bound.
 * @param fMax          Maximum random bound.
 * @return              A random number between (inclusive) fMin and fMax.
 */
native float GetRandomFloat(float fMin=0.0, float fMax=1.0);

/**
 * Returns a random number from the Half-Life 2 Random Stream.
 *
 * @param nmin          Minimum random bound.
 * @param nmax          Maximum random bound.
 * @return              A random number between (inclusive) nmin and nmax.
 */
native int GetRandomInt(int nmin, int nmax);

/**
 * Returns whether a map is valid or not.
 *
 * @param map           Map name, excluding .bsp extension.
 * @return              True if valid, false otherwise.
 */
native bool IsMapValid(const char[] map);

/**
 * Returns whether a full or partial map name is found or can be resolved
 *
 * @param map           Map name (usually same as map path relative to maps/ dir,
 *                      excluding .bsp extension).
 * @param foundmap      Resolved map name. If the return is FindMap_FuzzyMatch
 *                      or FindMap_NonCanonical the buffer will be the full path.
 * @param maxlen        Maximum length to write to map var.
 * @return              Result of the find operation. Not all result types are supported on all games.
 */
native FindMapResult FindMap(const char[] map, char[] foundmap, int maxlen);

/**
 * Get the display name of a workshop map.
 *
 * Note: You do not need to call FindMap first.  This native will call FindMap internally.
 *
 * @param map           Map name (usually same as map path relative to maps/ dir,
 *                      excluding .bsp extension).
 * @param displayName   Map's display name, i.e. cp_mymapname or de_mymapname.
 *                      If FindMap returns FindMap_PossiblyAvailable or FindMap_NotFound,
 *                      the map cannot be resolved and this native will return false,
 *                      but displayName will be a copy of map.
 * @param maxlen        Maximum length to write to displayName var.
 * @return              true if FindMap returns FindMap_Found, FindMap_FuzzyMatch, or
 *                      FindMap_NonCanonical.
 *                      false if FindMap returns FindMap_PossiblyAvailable or FindMap_NotFound.
 */
native bool GetMapDisplayName(const char[] map, char[] displayName, int maxlen);

/**
 * Returns whether the server is dedicated.
 *
 * @return              True if dedicated, false otherwise.
 */
native bool IsDedicatedServer();

/**
 * Returns a high-precision time value for profiling the engine.
 *
 * @return              A floating point time value.
 */
native float GetEngineTime();

/**
 * Returns the game time based on the game tick.
 *
 * @return              Game tick time.
 */
native float GetGameTime();

/**
 * Returns the game's internal tick count.
 *
 * @return              Game tick count.
 */
native int GetGameTickCount();

/**
 * Returns the time the Game took processing the last frame.
 *
 * @return              Game frame time.
 */
native float GetGameFrameTime();

/**
 * Returns the game description from the mod.
 *
 * @param buffer        Buffer to store the description.
 * @param maxlength     Maximum size of the buffer.
 * @param original      If true, retrieves the original game description,
 *                      ignoring any potential hooks from plugins.
 * @return              Number of bytes written to the buffer (UTF-8 safe).
 */
native int GetGameDescription(char[] buffer, int maxlength, bool original=false);

/**
 * Returns the name of the game's directory.
 *
 * @param buffer        Buffer to store the directory name.
 * @param maxlength     Maximum size of the buffer.
 * @return              Number of bytes written to the buffer (UTF-8 safe).
 */
native int GetGameFolderName(char[] buffer, int maxlength);

/**
 * Returns the current map name.
 *
 * @param buffer        Buffer to store map name.
 * @param maxlength     Maximum length of buffer.
 * @return              Number of bytes written (UTF-8 safe).
 */
native int GetCurrentMap(char[] buffer, int maxlength);

/**
 * Precaches a given model.
 *
 * @param model         Name of the model to precache.
 * @param preload       If preload is true the file will be precached before level startup.
 * @return              Returns the model index, 0 for error.
 */
native int PrecacheModel(const char[] model, bool preload=false);

/**
 * Precaches a given sentence file.
 *
 * @param file          Name of the sentence file to precache.
 * @param preload       If preload is true the file will be precached before level startup.
 * @return              Returns a sentence file index.
 */
native int PrecacheSentenceFile(const char[] file, bool preload=false);

/**
 * Precaches a given decal.
 *
 * @param decal         Name of the decal to precache.
 * @param preload       If preload is true the file will be precached before level startup.
 * @return              Returns a decal index.
 */
native int PrecacheDecal(const char[] decal, bool preload=false);

/**
 * Precaches a given generic file.
 *
 * @param generic       Name of the generic file to precache.
 * @param preload       If preload is true the file will be precached before level startup.
 * @return              Returns a generic file index.
 */
native int PrecacheGeneric(const char[] generic, bool preload=false);

/**
 * Returns if a given model is precached.
 *
 * @param model         Name of the model to check.
 * @return              True if precached, false otherwise.
 */
native bool IsModelPrecached(const char[] model);

/**
 * Returns if a given decal is precached.
 *
 * @param decal         Name of the decal to check.
 * @return              True if precached, false otherwise.
 */
native bool IsDecalPrecached(const char[] decal);

/**
 * Returns if a given generic file is precached.
 *
 * @param generic       Name of the generic file to check.
 * @return              True if precached, false otherwise.
 */
native bool IsGenericPrecached(const char[] generic);

/**
 * Precaches a given sound.
 *
 * @param sound         Name of the sound to precache.
 * @param preload       If preload is true the file will be precached before level startup.
 * @return              True if successfully precached, false otherwise.
 */
native bool PrecacheSound(const char[] sound, bool preload=false);

/**
 * Returns if a given sound is precached.
 *
 * @param sound         Name of the sound to check.
 * @return              True if precached, false otherwise.
 * @deprecated          Doesn't work correctly, always returns true.
 */
#pragma deprecated Doesn't work correctly, always returns true.
native bool IsSoundPrecached(const char[] sound);

/**
 * Creates different types of ingame messages.
 *
 * @param client        Index of the client.
 * @param kv            KeyValues handle to set the menu keys and options. (Check iserverplugin.h for more information).
 * @param type          Message type to display ingame.
 * @error               Invalid client index, or client not connected.
 */
native void CreateDialog(int client, Handle kv, DialogType type);

/**
 * Guesses the SDK version a mod was compiled against.  If nothing
 * specific is known about the game, the engine version is used instead.
 *
 * The return values are guaranteed to increase chronologically (that is,
 * a later release will have a higher value).
 *
 * @return              SOURCE_SDK version code.
 * @deprecated          See GetEngineVersion()
 */
#pragma deprecated See GetEngineVersion()
native int GuessSDKVersion();

/**
 * Gets the engine version that the currently-loaded SM core was compiled against.
 *
 * The engine version values are not guaranteed to be in any particular order,
 * and should only be compared by (in)equality.
 *
 * @return              An EngineVersion value.
 */
native EngineVersion GetEngineVersion();

/**
 * Prints a message to a specific client in the chat area.
 *
 * @param client        Client index.
 * @param format        Formatting rules.
 * @param ...           Variable number of format parameters.
 * @error               If the client is not connected an error will be thrown.
 */
native void PrintToChat(int client, const char[] format, any ...);

/**
 * Prints a message to all clients in the chat area.
 *
 * @param format        Formatting rules.
 * @param ...           Variable number of format parameters.
 */
stock void PrintToChatAll(const char[] format, any ...)
{
	char buffer[254];

	for (int i = 1; i <= MaxClients; i++)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, sizeof(buffer), format, 2);
			PrintToChat(i, "%s", buffer);
		}
	}
}

/**
 * Prints a message to a specific client in the center of the screen.
 *
 * @param client        Client index.
 * @param format        Formatting rules.
 * @param ...           Variable number of format parameters.
 * @error               If the client is not connected an error will be thrown.
 */
native void PrintCenterText(int client, const char[] format, any ...);

/**
 * Prints a message to all clients in the center of the screen.
 *
 * @param format        Formatting rules.
 * @param ...           Variable number of format parameters.
 */
stock void PrintCenterTextAll(const char[] format, any ...)
{
	char buffer[254];

	for (int i = 1; i <= MaxClients; i++)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, sizeof(buffer), format, 2);
			PrintCenterText(i, "%s", buffer);
		}
	}
}

/**
 * Prints a message to a specific client with a hint box.
 *
 * @param client        Client index.
 * @param format        Formatting rules.
 * @param ...           Variable number of format parameters.
 * @error               If the client is not connected an error will be thrown.
 */
native void PrintHintText(int client, const char[] format, any ...);

/**
 * Prints a message to all clients with a hint box.
 *
 * @param format        Formatting rules.
 * @param ...           Variable number of format parameters.
 */
stock void PrintHintTextToAll(const char[] format, any ...)
{
	char buffer[254];

	for (int i = 1; i <= MaxClients; i++)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, sizeof(buffer), format, 2);
			PrintHintText(i, "%s", buffer);
		}
	}
}

/**
 * Shows a VGUI panel to a specific client.
 *
 * @param client        Client index.
 * @param name          Panel type name (Check viewport_panel_names.h to see a list of
 *                      some panel names).
 * @param Kv            KeyValues handle with all the data for the panel setup (Depends
 *                      on the panel type and may be unused).
 * @param show          True to show the panel, or false to remove it from the client screen.
 * @error               If the client is not connected an error will be thrown.
 */
native void ShowVGUIPanel(int client, const char[] name, Handle Kv=INVALID_HANDLE, bool show=true);

/**
 * Creates a HUD synchronization object.  This object is used to automatically assign and
 * re-use channels for a set of messages.
 *
 * The HUD has a hardcoded number of channels (usually 6) for displaying
 * text.  You can use any channel for any area of the screen.  Text on
 * different channels can overlap, but text on the same channel will
 * erase the old text first.  This overlapping and overwriting gets problematic.
 *
 * A HUD synchronization object automatically selects channels for you based on
 * the following heuristics:
 *  - If channel X was last used by the object, and hasn't been modified again,
 *    channel X gets re-used.
 *  - Otherwise, a new channel is chosen based on the least-recently-used channel.
 *
 * This ensures that if you display text on a sync object, that the previous text
 * displayed on it will always be cleared first.  This is because your new text
 * will either overwrite the old text on the same channel, or because another
 * channel has already erased your text.
 *
 * Note that messages can still overlap if they are on different synchronization
 * objects, or they are displayed to manual channels.
 *
 * These are particularly useful for displaying repeating or refreshing HUD text, in
 * addition to displaying multiple message sets in one area of the screen (for example,
 * center-say messages that may pop up randomly that you don't want to overlap each
 * other).
 *
 * @return              New HUD synchronization object.
 *                      The Handle can be closed with CloseHandle().
 *                      If HUD text is not supported on this mod, then
 *                      INVALID_HANDLE is returned.
 */
native Handle CreateHudSynchronizer();

/**
 * Sets the HUD parameters for drawing text.  These parameters are stored
 * globally, although nothing other than this function and SetHudTextParamsEx
 * modify them.
 *
 * You must call this function before drawing text.  If you are drawing
 * text to multiple clients, you can set the parameters once, since
 * they won't be modified.  However, as soon as you pass control back
 * to other plugins, you must reset the parameters next time you draw.
 *
 * @param x             x coordinate, from 0 to 1.  -1.0 is the center.
 * @param y             y coordinate, from 0 to 1.  -1.0 is the center.
 * @param holdTime      Number of seconds to hold the text.
 * @param r             Red color value.
 * @param g             Green color value.
 * @param b             Blue color value.
 * @param a             Alpha transparency value.
 * @param effect        0/1 causes the text to fade in and fade out.
 *                      2 causes the text to flash[?].
 * @param fxTime        Duration of chosen effect (may not apply to all effects).
 * @param fadeIn        Number of seconds to spend fading in.
 * @param fadeOut       Number of seconds to spend fading out.
 */
native void SetHudTextParams(float x, float y, float holdTime, int r, int g, int b, int a, int effect = 0,
						float fxTime=6.0, float fadeIn=0.1, float fadeOut=0.2);

/**
 * Sets the HUD parameters for drawing text.  These parameters are stored
 * globally, although nothing other than this function and SetHudTextParams
 * modify them.
 *
 * This is the same as SetHudTextParams(), except it lets you set the alternate
 * color for when effects require it.
 *
 * @param x             x coordinate, from 0 to 1.  -1.0 is the center.
 * @param y             y coordinate, from 0 to 1.  -1.0 is the center.
 * @param holdTime      Number of seconds to hold the text.
 * @param color1        First color set, array values being [red, green, blue, alpha]
 * @param color2        Second color set, array values being [red, green, blue, alpha]
 * @param effect        0/1 causes the text to fade in and fade out.
 *                      2 causes the text to flash[?].
 * @param fxTime        Duration of chosen effect (may not apply to all effects).
 * @param fadeIn        Number of seconds to spend fading in.
 * @param fadeOut       Number of seconds to spend fading out.
 */
native void SetHudTextParamsEx(float x, float y, float holdTime, int color1[4],
						  int color2[4]={255,255,255,0}, int effect = 0, float fxTime=6.0,
						  float fadeIn=0.1, float fadeOut=0.2);

/**
 * Shows a synchronized HUD message to a client.
 *
 * As of this writing, only TF, HL2MP, and SourceForts support HUD Text.
 *
 * @param client        Client index to send the message to.
 * @param sync          Synchronization object.
 * @param message       Message text or formatting rules.
 * @param ...           Message formatting parameters.
 * @return              -1 on failure, anything else on success.
 *                      This function fails if the mod does not support it.
 * @error               Client not in-game, or sync object not valid.
 */
native int ShowSyncHudText(int client, Handle sync, const char[] message, any ...);

/**
 * Clears the text on a synchronized HUD channel.
 *
 * This is not the same as sending "" because it guarantees that it won't
 * overwrite text on another channel.  For example, consider the scenario:
 *
 * 1. Your synchronized message goes to channel 3.
 * 2. Someone else's non-synchronized message goes to channel 3.
 *
 * If you were to simply send "" on your synchronized message,
 * then someone else's text could be overwritten.
 *
 * @param client        Client index to send the message to.
 * @param sync          Synchronization object.
 * @error               Client not in-game, or sync object not valid.
 */
native void ClearSyncHud(int client, Handle sync);

/**
 * Shows a HUD message to a client on the given channel.
 *
 * As of this writing, only TF, HL2MP, and SourceForts support HUD Text.
 *
 * @param client        Client index to send the message to.
 * @param channel       A channel number.
 *                      If -1, then a channel will automatically be selected
 *                      based on the least-recently-used channel.  If the
 *                      channel is any other number, it will be modulo'd with
 *                      the channel count to get a final channel number.
 * @param message       Message text or formatting rules.
 * @param ...           Message formatting parameters.
 * @return              -1 on failure (lack of mod support).
 *                      Any other return value is the channel number that was
 *                      used to render the text.
 */
native int ShowHudText(int client, int channel, const char[] message, any ...);

/**
 * Shows a MOTD panel to a specific client.
 *
 * @param client        Client index.
 * @param title         Title of the panel (printed on the top border of the window).
 * @param msg           Contents of the panel, it can be treated as an url, filename or plain text
 *                      depending on the type parameter (WARNING: msg has to be 192 bytes maximum!)
 * @param type          Determines the way to treat the message body of the panel.
 * @error               If the client is not connected an error will be thrown.
 */
stock void ShowMOTDPanel(int client, const char[] title, const char[] msg, int type=MOTDPANEL_TYPE_INDEX)
{
	char num[3];
	IntToString(type, num, sizeof(num));

	KeyValues kv = new KeyValues("data");
	kv.SetString("title", title);
	kv.SetString("type", num);
	kv.SetString("msg", msg);
	ShowVGUIPanel(client, "info", kv);
	delete kv;
}

/**
 * Displays a panel asking the client to connect to a specified IP.
 *
 * @param client        Client index.
 * @param time          Duration to hold the panel on the client's screen.
 * @param ip            Destination IP.
 * @param password      Password to connect to the destination IP. The client will be able to see this.
 */
stock void DisplayAskConnectBox(int client, float time, const char[] ip, const char[] password = "")
{
	char destination[288];
	FormatEx(destination, sizeof(destination), "%s/%s", ip, password);

	KeyValues kv = new KeyValues("data");
	kv.SetFloat("time", time);
	kv.SetString("title", destination);
	CreateDialog(client, kv, DialogType_AskConnect);
	delete kv;
}

/**
 * Converts an entity index into a serial encoded entity reference.
 *
 * @param entity        Entity index.
 * @return              Entity reference.
 */
native int EntIndexToEntRef(int entity);

/**
 * Retrieves the entity index from a reference.
 *
 * @param ref           Entity reference.
 * @return              Entity index.
 */
native int EntRefToEntIndex(int ref);

/**
 * Converts a reference into a backwards compatible version.
 *
 * @param ref           Entity reference.
 * @return              Bcompat reference.
 */
native int MakeCompatEntRef(int ref);

enum ClientRangeType
{
	RangeType_Visibility = 0,
	RangeType_Audibility
}

/**
 * Find clients that are potentially in range of a position.
 *
 * @param origin        Coordinates from which to test range.
 * @param rangeType     Range type to use for filtering clients.
 * @param clients       Array to which found client indexes will be written.
 * @param size          Maximum size of clients array.
 * @return              Number of client indexes written to clients array.
 */
native int GetClientsInRange(float origin[3], ClientRangeType rangeType, int[] clients, int size);

/**
 * Retrieves the server's authentication string (SteamID).
 *
 * Note: If called before server is connected to Steam, auth id
 * will be invalid ([I:0:1], 1, etc.)
 *
 * @param authType      Auth id type and format to use.
 *                      (Only AuthId_Steam3 and AuthId_SteamID64 are supported)
 * @param auth          Buffer to store the server's auth id.
 * @param maxlen        Maximum length of string buffer (includes NULL terminator).
 * @error               Invalid AuthIdType given.
 */
native void GetServerAuthId(AuthIdType authType, char[] auth, int maxlen);

/**
 * Returns the server's Steam account ID.
 *
 * @return              Steam account ID or 0 if not available.
 */
native int GetServerSteamAccountId();
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _sdktools_sound_included
 #endinput
#endif
#define _sdktools_sound_included

/**
 * Sound should be from the target client.
 */
#define SOUND_FROM_PLAYER       -2

/**
 * Sound should be from the listen server player.
 */
#define SOUND_FROM_LOCAL_PLAYER -1

/**
 * Sound is from the world.
 */
#define SOUND_FROM_WORLD        0

/**
 * Sound channels.
 */
enum
{
	SNDCHAN_REPLACE = -1,       /**< Unknown */
	SNDCHAN_AUTO = 0,           /**< Auto */
	SNDCHAN_WEAPON = 1,         /**< Weapons */
	SNDCHAN_VOICE = 2,          /**< Voices */
	SNDCHAN_ITEM = 3,           /**< Items */
	SNDCHAN_BODY = 4,           /**< Player? */
	SNDCHAN_STREAM = 5,         /**< "Stream channel from the static or dynamic area" */
	SNDCHAN_STATIC = 6,         /**< "Stream channel from the static area" */
	SNDCHAN_VOICE_BASE = 7,     /**< "Channel for network voice data" */
	SNDCHAN_USER_BASE = 135     /**< Anything >= this is allocated to game code */
};

/**
 * Sound flags for the sound emitter system.
 */
enum
{
	SND_NOFLAGS= 0,             /**< Nothing */
	SND_CHANGEVOL = 1,          /**< Change sound volume */
	SND_CHANGEPITCH = 2,        /**< Change sound pitch */
	SND_STOP = 3,               /**< Stop the sound */
	SND_SPAWNING = 4,           /**< Used in some cases for ambients */
	SND_DELAY = 5,              /**< Sound has an initial delay */
	SND_STOPLOOPING = 6,        /**< Stop looping all sounds on the entity */
	SND_SPEAKER = 7,            /**< Being played by a mic through a speaker */
	SND_SHOULDPAUSE = 8         /**< Pause if game is paused */
};

/**
 * Various predefined sound levels in dB.
 */
enum
{
	SNDLEVEL_NONE = 0,          /**< None */
	SNDLEVEL_RUSTLE = 20,       /**< Rustling leaves */
	SNDLEVEL_WHISPER = 25,      /**< Whispering */
	SNDLEVEL_LIBRARY = 30,      /**< In a library */
	SNDLEVEL_FRIDGE = 45,       /**< Refrigerator */
	SNDLEVEL_HOME = 50,         /**< Average home (3.9 attn) */
	SNDLEVEL_CONVO = 60,        /**< Normal conversation (2.0 attn) */
	SNDLEVEL_DRYER = 60,        /**< Clothes dryer */
	SNDLEVEL_DISHWASHER = 65,   /**< Dishwasher/washing machine (1.5 attn) */
	SNDLEVEL_CAR = 70,          /**< Car or vacuum cleaner (1.0 attn) */
	SNDLEVEL_NORMAL = 75,       /**< Normal sound level */
	SNDLEVEL_TRAFFIC = 75,      /**< Busy traffic (0.8 attn) */
	SNDLEVEL_MINIBIKE = 80,     /**< Mini-bike, alarm clock (0.7 attn) */
	SNDLEVEL_SCREAMING = 90,    /**< Screaming child (0.5 attn) */
	SNDLEVEL_TRAIN = 100,       /**< Subway train, pneumatic drill (0.4 attn) */
	SNDLEVEL_HELICOPTER = 105,  /**< Helicopter */
	SNDLEVEL_SNOWMOBILE = 110,  /**< Snow mobile */
	SNDLEVEL_AIRCRAFT = 120,    /**< Auto horn, aircraft */
	SNDLEVEL_RAIDSIREN = 130,   /**< Air raid siren */
	SNDLEVEL_GUNFIRE = 140,     /**< Gunshot, jet engine (0.27 attn) */
	SNDLEVEL_ROCKET = 180       /**< Rocket launching (0.2 attn) */
};

#define SNDVOL_NORMAL       1.0     /**< Normal volume */
#define SNDPITCH_NORMAL     100     /**< Normal pitch */
#define SNDPITCH_LOW        95      /**< A low pitch */
#define SNDPITCH_HIGH       120     /**< A high pitch */
#define SNDATTN_NONE        0.0     /**< No attenuation */
#define SNDATTN_NORMAL      0.8     /**< Normal attenuation */
#define SNDATTN_STATIC      1.25    /**< Static attenuation? */
#define SNDATTN_RICOCHET    1.5     /**< Ricochet effect */
#define SNDATTN_IDLE        2.0     /**< Idle attenuation? */

/**
 * Prefetches a sound.
 *
 * @param name          Sound file name relative to the "sound" folder.
 */
native void PrefetchSound(const char[] name);

/**
 * This function is not known to work, and may crash.  You should
 * not use it.  It is provided for backwards compatibility only.
 *
 * @param name          Sound file name relative to the "sound" folder.
 * @return              Duration in seconds.
 * @deprecated          Does not work, may crash.
 */
#pragma deprecated Does not work, may crash.
native float GetSoundDuration(const char[] name);

/**
 * Emits an ambient sound.
 *
 * @param name          Sound file name relative to the "sound" folder.
 * @param pos           Origin of sound.
 * @param entity        Entity index to associate sound with.
 * @param level         Sound level (from 0 to 255).
 * @param flags         Sound flags.
 * @param vol           Volume (from 0.0 to 1.0).
 * @param pitch         Pitch (from 0 to 255).
 * @param delay         Play delay.
 */
native void EmitAmbientSound(const char[] name,
						const float pos[3],
						int entity = SOUND_FROM_WORLD,
						int level = SNDLEVEL_NORMAL,
						int flags = SND_NOFLAGS,
						float vol = SNDVOL_NORMAL,
						int pitch = SNDPITCH_NORMAL,
						float delay = 0.0);

/**
 * Fades a client's volume level toward silence or a given percentage.
 *
 * @param client        Client index.
 * @param percent       Fade percentage.
 * @param outtime       Fade out time, in seconds.
 * @param holdtime      Hold time, in seconds.
 * @param intime        Fade in time, in seconds.
 * @error               Invalid client index or client not in game.
 */
native void FadeClientVolume(int client, float percent, float outtime, float holdtime, float intime);

/**
 * Stops a sound.
 *
 * @param entity        Entity index.
 * @param channel       Channel number.
 * @param name          Sound file name relative to the "sound" folder.
 */
native void StopSound(int entity, int channel, const char[] name);

/**
 * Emits a sound to a list of clients.
 *
 * @param clients       Array of client indexes.
 * @param numClients    Number of clients in the array.
 * @param sample        Sound file name relative to the "sound" folder.
 * @param entity        Entity to emit from.
 * @param channel       Channel to emit with.
 * @param level         Sound level.
 * @param flags         Sound flags.
 * @param volume        Sound volume.
 * @param pitch         Sound pitch.
 * @param speakerentity Unknown.
 * @param origin        Sound origin.
 * @param dir           Sound direction.
 * @param updatePos     Unknown (updates positions?)
 * @param soundtime     Alternate time to play sound for.
 * @param ...           Optional list of Float[3] arrays to specify additional origins.
 * @error               Invalid client index.
 */
native void EmitSound(const int[] clients,
				 int numClients,
				 const char[] sample,
				 int entity = SOUND_FROM_PLAYER,
				 int channel = SNDCHAN_AUTO,
				 int level = SNDLEVEL_NORMAL,
				 int flags = SND_NOFLAGS,
				 float volume = SNDVOL_NORMAL,
				 int pitch = SNDPITCH_NORMAL,
				 int speakerentity = -1,
				 const float origin[3] = NULL_VECTOR,
				 const float dir[3] = NULL_VECTOR,
				 bool updatePos = true,
				 float soundtime = 0.0,
				 any ...);

/**
 * Emits a sound or game sound to a list of clients using the latest version of the engine sound interface.
 * This native is only available in engines that are greater than or equal to Portal 2.
 *
 * @param clients       Array of client indexes.
 * @param numClients    Number of clients in the array.
 * @param soundEntry    Sound entry name.
 * @param sample        Sound file name relative to the "sound" folder.
 * @param entity        Entity to emit from.
 * @param channel       Channel to emit with.
 * @param level         Sound level.
 * @param seed          Sound seed.
 * @param flags         Sound flags.
 * @param volume        Sound volume.
 * @param pitch         Sound pitch.
 * @param speakerentity Unknown.
 * @param origin        Sound origin.
 * @param dir           Sound direction.
 * @param updatePos     Unknown (updates positions?)
 * @param soundtime     Alternate time to play sound for.
 * @param ...           Optional list of Float[3] arrays to specify additional origins.
 * @error               Invalid client index.
 */
native void EmitSoundEntry(const int[] clients,
				 int numClients,
				 const char[] soundEntry,
				 const char[] sample,
				 int entity = SOUND_FROM_PLAYER,
				 int channel = SNDCHAN_AUTO,
				 int level = SNDLEVEL_NORMAL,
				 int seed = 0,
				 int flags = SND_NOFLAGS,
				 float volume = SNDVOL_NORMAL,
				 int pitch = SNDPITCH_NORMAL,
				 int speakerentity = -1,
				 const float origin[3] = NULL_VECTOR,
				 const float dir[3] = NULL_VECTOR,
				 bool updatePos = true,
				 float soundtime = 0.0,
				 any ...);

/**
 * Emits a sentence to a list of clients.
 *
 * @param clients       Array of client indexes.
 * @param numClients    Number of clients in the array.
 * @param sentence      Sentence index (from PrecacheSentenceFile).
 * @param entity        Entity to emit from.
 * @param channel       Channel to emit with.
 * @param level         Sound level.
 * @param flags         Sound flags.
 * @param volume        Sound volume.
 * @param pitch         Sound pitch.
 * @param speakerentity Unknown.
 * @param origin        Sound origin.
 * @param dir           Sound direction.
 * @param updatePos     Unknown (updates positions?)
 * @param soundtime     Alternate time to play sound for.
 * @param ...           Optional list of Float[3] arrays to specify additional origins.
 * @error               Invalid client index.
 */
native void EmitSentence(const int[] clients,
				 int numClients,
				 int sentence,
				 int entity,
				 int channel = SNDCHAN_AUTO,
				 int level = SNDLEVEL_NORMAL,
				 int flags = SND_NOFLAGS,
				 float volume = SNDVOL_NORMAL,
				 int pitch = SNDPITCH_NORMAL,
				 int speakerentity = -1,
				 const float origin[3] = NULL_VECTOR,
				 const float dir[3] = NULL_VECTOR,
				 bool updatePos = true,
				 float soundtime = 0.0,
				 any ...);

/**
 * Calculates gain of sound on given distance with given sound level in decibel
 *
 * @param soundlevel    decibel of sound, like SNDLEVEL_NORMAL or integer value
 * @param distance      distance of sound to calculate, not meter or feet, but Source Engine`s normal Coordinate unit
 * @return              gain of sound. you can multiply this with original sound`s volume to calculate volume on given distance
 */
native float GetDistGainFromSoundLevel(int soundlevel, float distance);

/**
 * Called when an ambient sound is about to be emitted to one or more clients.
 *
 * NOTICE: all parameters can be overwritten to modify the default behavior.
 *
 * @param sample        Sound file name relative to the "sound" folder.
 * @param entity        Entity index associated to the sound.
 * @param volume        Volume (from 0.0 to 1.0).
 * @param level         Sound level (from 0 to 255).
 * @param pitch         Pitch (from 0 to 255).
 * @param pos           Origin of sound.
 * @param flags         Sound flags.
 * @param delay         Play delay.
 * @return              Plugin_Continue to allow the sound to be played, Plugin_Stop to block it,
 *                      Plugin_Changed when any parameter has been modified.
 */
typedef AmbientSHook = function Action (
  char sample[PLATFORM_MAX_PATH],
  int &entity,
  float &volume,
  int &level,
  int &pitch,
  float pos[3],
  int &flags,
  float &delay
);

typeset NormalSHook
{
	// Called when a sound is going to be emitted to one or more clients.
	// NOTICE: all params can be overwritten to modify the default behavior.
	//
	// @param clients       Array of client indexes.
	// @param numClients    Number of clients in the array (modify this value if you add/remove elements from the client array).
	// @param sample        Sound file name relative to the "sound" folder.
	// @param entity        Entity emitting the sound.
	// @param channel       Channel emitting the sound.
	// @param volume        Sound volume.
	// @param level         Sound level.
	// @param pitch         Sound pitch.
	// @param flags         Sound flags.
	// @param soundEntry    Game sound entry name. (Used in engines newer than Portal 2)
	// @param seed          Sound seed. (Used in engines newer than Portal 2)
	// @return              Plugin_Continue to allow the sound to be played, Plugin_Stop to block it,
	//                      Plugin_Changed when any parameter has been modified.
	function Action (int clients[MAXPLAYERS], int &numClients, char sample[PLATFORM_MAX_PATH],
	  int &entity, int &channel, float &volume, int &level, int &pitch, int &flags,
	  char soundEntry[PLATFORM_MAX_PATH], int &seed);

	// Deprecated. Use other prototype.
	function Action (int clients[64], int &numClients, char sample[PLATFORM_MAX_PATH],
	  int &entity, int &channel, float &volume, int &level, int &pitch, int &flags,
	  char soundEntry[PLATFORM_MAX_PATH], int &seed);

	// Deprecated. Use other prototype.
	function Action (int clients[64], int &numClients, char sample[PLATFORM_MAX_PATH],
	  int &entity, int &channel, float &volume, int &level, int &pitch, int &flags);
};

/**
 * Hooks all played ambient sounds.
 *
 * @param hook          Function to use as a hook.
 * @error               Invalid function hook.
 */
native void AddAmbientSoundHook(AmbientSHook hook);

/**
 * Hooks all played normal sounds.
 *
 * @param hook          Function to use as a hook.
 * @error               Invalid function hook.
 */
native void AddNormalSoundHook(NormalSHook hook);

/**
 * Unhooks all played ambient sounds.
 *
 * @param hook          Function used for the hook.
 * @error               Invalid function hook.
 */
native void RemoveAmbientSoundHook(AmbientSHook hook);

/**
 * Unhooks all played normal sounds.
 *
 * @param hook          Function used for the hook.
 * @error               Invalid function hook.
 */
native void RemoveNormalSoundHook(NormalSHook hook);

/**
 * Wrapper to emit sound to one client.
 *
 * @param client        Client index.
 * @param sample        Sound file name relative to the "sound" folder.
 * @param entity        Entity to emit from.
 * @param channel       Channel to emit with.
 * @param level         Sound level.
 * @param flags         Sound flags.
 * @param volume        Sound volume.
 * @param pitch         Sound pitch.
 * @param speakerentity Unknown.
 * @param origin        Sound origin.
 * @param dir           Sound direction.
 * @param updatePos     Unknown (updates positions?)
 * @param soundtime     Alternate time to play sound for.
 * @error               Invalid client index.
 */
stock void EmitSoundToClient(int client,
				 const char[] sample,
				 int entity = SOUND_FROM_PLAYER,
				 int channel = SNDCHAN_AUTO,
				 int level = SNDLEVEL_NORMAL,
				 int flags = SND_NOFLAGS,
				 float volume = SNDVOL_NORMAL,
				 int pitch = SNDPITCH_NORMAL,
				 int speakerentity = -1,
				 const float origin[3] = NULL_VECTOR,
				 const float dir[3] = NULL_VECTOR,
				 bool updatePos = true,
				 float soundtime = 0.0)
{
	int clients[1];
	clients[0] = client;
	/* Save some work for SDKTools and remove SOUND_FROM_PLAYER references */
	entity = (entity == SOUND_FROM_PLAYER) ? client : entity;
	EmitSound(clients, 1, sample, entity, channel,
		level, flags, volume, pitch, speakerentity,
		origin, dir, updatePos, soundtime);
}

/**
 * Wrapper to emit sound to all clients.
 *
 * @param sample        Sound file name relative to the "sound" folder.
 * @param entity        Entity to emit from.
 * @param channel       Channel to emit with.
 * @param level         Sound level.
 * @param flags         Sound flags.
 * @param volume        Sound volume.
 * @param pitch         Sound pitch.
 * @param speakerentity Unknown.
 * @param origin        Sound origin.
 * @param dir           Sound direction.
 * @param updatePos     Unknown (updates positions?)
 * @param soundtime     Alternate time to play sound for.
 * @error               Invalid client index.
 */
stock void EmitSoundToAll(const char[] sample,
				 int entity = SOUND_FROM_PLAYER,
				 int channel = SNDCHAN_AUTO,
				 int level = SNDLEVEL_NORMAL,
				 int flags = SND_NOFLAGS,
				 float volume = SNDVOL_NORMAL,
				 int pitch = SNDPITCH_NORMAL,
				 int speakerentity = -1,
				 const float origin[3] = NULL_VECTOR,
				 const float dir[3] = NULL_VECTOR,
				 bool updatePos = true,
				 float soundtime = 0.0)
{
	int[] clients = new int[MaxClients];
	int total = 0;

	for (int i=1; i<=MaxClients; i++)
	{
		if (IsClientInGame(i))
		{
			clients[total++] = i;
		}
	}

	if (total)
	{
		EmitSound(clients, total, sample, entity, channel,
			level, flags, volume, pitch, speakerentity,
			origin, dir, updatePos, soundtime);
	}
}

/**
 * Converts an attenuation value to a sound level.
 * This function is from the HL2SDK.
 *
 * @param attn          Attenuation value.
 * @return              Integer sound level.
 */
stock int ATTN_TO_SNDLEVEL(float attn)
{
	if (attn > 0.0)
	{
		return RoundFloat(50.0 + (20.0 / attn));
	}
	return 0;
}

/**
 * Retrieves the parameters for a game sound.
 *
 * Game sounds are found in a game's scripts/game_sound.txt or other files
 * referenced from it
 *
 * Note that if a game sound has a rndwave section, one of them will be returned
 * at random.
 *
 * @param gameSound     Name of game sound.
 * @param channel       Channel to emit with.
 * @param level         Sound level.
 * @param volume        Sound volume.
 * @param pitch         Sound pitch.
 * @param sample        Sound file name relative to the "sound" folder.
 * @param maxlength     Maximum length of sample string buffer.
 * @param entity        Entity the sound is being emitted from.
 * @return              True if the sound was successfully retrieved, false if it
 *                      was not found
 */
native bool GetGameSoundParams(const char[] gameSound,
				int &channel,
				int &soundLevel,
				float &volume,
				int &pitch,
				char[] sample,
				int maxlength,
				int entity=SOUND_FROM_PLAYER);

/**
 * Emits a game sound to a list of clients.
 *
 * Game sounds are found in a game's scripts/game_sound.txt or other files
 * referenced from it
 *
 * Note that if a game sound has a rndwave section, one of them will be returned
 * at random.
 *
 * @param clients       Array of client indexes.
 * @param numClients    Number of clients in the array.
 * @param gameSound     Name of game sound.
 * @param entity        Entity to emit from.
 * @param flags         Sound flags.
 * @param speakerentity Unknown.
 * @param origin        Sound origin.
 * @param dir           Sound direction.
 * @param updatePos     Unknown (updates positions?)
 * @param soundtime     Alternate time to play sound for.
 * @return              True if the sound was played successfully, false if it failed
 * @error               Invalid client index.
 */
stock bool EmitGameSound(const int[] clients,
				int numClients,
				const char[] gameSound,
				int entity = SOUND_FROM_PLAYER,
				int flags = SND_NOFLAGS,
				int speakerentity = -1,
				const float origin[3] = NULL_VECTOR,
				const float dir[3] = NULL_VECTOR,
				bool updatePos = true,
				float soundtime = 0.0)
{
	int channel;
	int level;
	float volume;
	int pitch;
	char sample[PLATFORM_MAX_PATH];

	if (GetGameSoundParams(gameSound, channel, level, volume, pitch, sample, sizeof(sample), entity))
	{
		EmitSound(clients, numClients, sample, entity, channel, level, flags, volume, pitch, speakerentity, origin, dir, updatePos, soundtime);
		return true;
	}

	return false;
}

/**
 * Emits an ambient game sound.
 *
 * Game sounds are found in a game's scripts/game_sound.txt or other files
 * referenced from it
 *
 * Note that if a game sound has a rndwave section, one of them will be returned
 * at random.
 *
 * @param gameSound     Name of game sound.
 * @param pos           Origin of sound.
 * @param entity        Entity index to associate sound with.
 * @param flags         Sound flags.
 * @param delay         Play delay.
 */
stock bool EmitAmbientGameSound(const char[] gameSound,
				const float pos[3],
				int entity = SOUND_FROM_WORLD,
				int flags = SND_NOFLAGS,
				float delay = 0.0)
{
	int channel; // This is never actually used for Ambients, but it's a mandatory field to GetGameSoundParams
	int level;
	float volume;
	int pitch;
	char sample[PLATFORM_MAX_PATH];

	if (GetGameSoundParams(gameSound, channel, level, volume, pitch, sample, sizeof(sample), entity))
	{
		EmitAmbientSound(sample, pos, entity, level, flags, volume, pitch, delay);
		return true;
	}

	return false;
}

/**
 * Wrapper to emit a game sound to one client.
 *
 * Game sounds are found in a game's scripts/game_sound.txt or other files
 * referenced from it
 *
 * Note that if a game sound has a rndwave section, one of them will be returned
 * at random.
 *
 * @param client        Client index.
 * @param gameSound     Name of game sound.
 * @param entity        Entity to emit from.
 * @param flags         Sound flags.
 * @param speakerentity Unknown.
 * @param origin        Sound origin.
 * @param dir           Sound direction.
 * @param updatePos     Unknown (updates positions?)
 * @param soundtime     Alternate time to play sound for.
 * @error               Invalid client index.
 */
stock bool EmitGameSoundToClient(int client,
				const char[] gameSound,
				int entity = SOUND_FROM_PLAYER,
				int flags = SND_NOFLAGS,
				int speakerentity = -1,
				const float origin[3] = NULL_VECTOR,
				const float dir[3] = NULL_VECTOR,
				bool updatePos = true,
				float soundtime = 0.0)
{
	int clients[1];
	clients[0] = client;
	/* Save some work for SDKTools and remove SOUND_FROM_PLAYER references */
	entity = (entity == SOUND_FROM_PLAYER) ? client : entity;
	return EmitGameSound(clients, 1, gameSound, entity, flags,
		speakerentity, origin, dir, updatePos, soundtime);
}

/**
 * Wrapper to emit game sound to all clients.
 *
 * Game sounds are found in a game's scripts/game_sound.txt or other files
 * referenced from it
 *
 * Note that if a game sound has a rndwave section, one of them will be returned
 * at random.
 *
 * @param gameSound     Name of game sound.
 * @param entity        Entity to emit from.
 * @param flags         Sound flags.
 * @param speakerentity Unknown.
 * @param origin        Sound origin.
 * @param dir           Sound direction.
 * @param updatePos     Unknown (updates positions?)
 * @param soundtime     Alternate time to play sound for.
 * @error               Invalid client index.
 */
stock bool EmitGameSoundToAll(const char[] gameSound,
				int entity = SOUND_FROM_PLAYER,
				int flags = SND_NOFLAGS,
				int speakerentity = -1,
				const float origin[3] = NULL_VECTOR,
				const float dir[3] = NULL_VECTOR,
				bool updatePos = true,
				float soundtime = 0.0)
{
	int[] clients = new int[MaxClients];
	int total = 0;

	for (int i=1; i<=MaxClients; i++)
	{
		if (IsClientInGame(i))
		{
			clients[total++] = i;
		}
	}

	if (!total)
	{
		return false;
	}

	return EmitGameSound(clients, total, gameSound, entity, flags,
		speakerentity, origin, dir, updatePos, soundtime);
}

/**
 * Precache a game sound.
 *
 * Most games will precache all game sounds on map start, but this is not guaranteed...
 * Team Fortress 2 is known to not pre-cache MvM game mode sounds on non-MvM maps.
 *
 * Due to the above, this native should be called before any calls to GetGameSoundParams,
 * EmitGameSound*, or EmitAmbientGameSound.
 *
 * It should be safe to pass already precached game sounds to this function.
 *
 * Note: It precaches all files for a game sound.
 *
 * @param soundname     Game sound to precache
 * @return              True if the game sound was found, false if sound did not exist
 *                      or had no files
 */
native bool PrecacheScriptSound(const char[] soundname);
